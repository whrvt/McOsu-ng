From 46f3f7f9450af7d69925955b279649a1fe57f4d0 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Fri, 6 Jun 2025 00:07:52 -0700
Subject: [PATCH 1/2] format

---
 .clang-format                     |   35 +
 include/soloud.h                  |  968 ++++----
 include/soloud_audiosource.h      |  538 ++--
 src/core/soloud.cpp               | 3795 ++++++++++++++---------------
 src/core/soloud_audiosource.cpp   |  513 ++--
 src/core/soloud_core_getters.cpp  |  543 ++---
 src/core/soloud_core_setters.cpp  |  366 +--
 src/core/soloud_core_voiceops.cpp |  204 +-
 8 files changed, 3497 insertions(+), 3465 deletions(-)
 create mode 100644 .clang-format

diff --git a/.clang-format b/.clang-format
new file mode 100644
index 0000000..0344b86
--- /dev/null
+++ b/.clang-format
@@ -0,0 +1,35 @@
+Language: C
+BasedOnStyle: Microsoft
+UseTab: ForIndentation
+IndentWidth: 4
+ColumnLimit: 165
+AllowShortFunctionsOnASingleLine: Inline
+IndentAccessModifiers: false
+AccessModifierOffset: -4
+AllowShortBlocksOnASingleLine: Empty
+AllowShortIfStatementsOnASingleLine: Never
+BraceWrapping:
+  SplitEmptyRecord: false
+  SplitEmptyNamespace: false
+AlignEscapedNewlines: DontAlign
+---
+Language: Cpp
+BasedOnStyle: Microsoft
+UseTab: ForIndentation
+IndentWidth: 4
+ColumnLimit: 165
+AllowShortFunctionsOnASingleLine: Inline
+IndentAccessModifiers: false
+AccessModifierOffset: -4
+AllowShortBlocksOnASingleLine: Empty
+AllowShortIfStatementsOnASingleLine: Never
+AlignArrayOfStructures: Left
+ExperimentalAutoDetectBinPacking: true
+BreakBeforeConceptDeclarations: Always
+BreakTemplateDeclarations: Yes
+BreakBeforeBraces: Custom
+BraceWrapping:
+  SplitEmptyRecord: false
+  SplitEmptyNamespace: false
+AlignEscapedNewlines: DontAlign
+PackConstructorInitializers: Never
diff --git a/include/soloud.h b/include/soloud.h
index 38b24c7..cf03ad6 100644
--- a/include/soloud.h
+++ b/include/soloud.h
@@ -25,8 +25,8 @@ freely, subject to the following restrictions:
 #ifndef SOLOUD_H
 #define SOLOUD_H
 
+#include <math.h>   // sin
 #include <stdlib.h> // rand
-#include <math.h> // sin
 
 #ifdef SOLOUD_NO_ASSERTS
 #define SOLOUD_ASSERT(x)
@@ -40,7 +40,14 @@ freely, subject to the following restrictions:
 #define WIN32_LEAN_AND_MEAN
 #endif
 #include <windows.h> // only needed for OutputDebugStringA, should be solved somehow.
-#define SOLOUD_ASSERT(x) if (!(x)) { char temp[200]; sprintf(temp, "%s(%d): assert(%s) failed.\n", __FILE__, __LINE__, #x); OutputDebugStringA(temp); __debugbreak(); }
+#define SOLOUD_ASSERT(x) \
+	if (!(x)) \
+	{ \
+		char temp[200]; \
+		sprintf(temp, "%s(%d): assert(%s) failed.\n", __FILE__, __LINE__, #x); \
+		OutputDebugStringA(temp); \
+		__debugbreak(); \
+	}
 #else
 #include <assert.h> // assert
 #define SOLOUD_ASSERT(x) assert(x)
@@ -63,12 +70,12 @@ freely, subject to the following restrictions:
 #define M_PI 3.14159265359
 #endif
 
-#if defined(_WIN32)||defined(_WIN64)
+#if defined(_WIN32) || defined(_WIN64)
 #define WINDOWS_VERSION
 #endif
 
 #if !defined(DISABLE_SIMD)
-#if defined(__x86_64__) || defined( _M_X64 ) || defined( __i386 ) || defined( _M_IX86 )
+#if defined(__x86_64__) || defined(_M_X64) || defined(__i386) || defined(_M_IX86)
 #define SOLOUD_SSE_INTRINSICS
 #endif
 #endif
@@ -102,495 +109,502 @@ freely, subject to the following restrictions:
 // includes depend on them.
 namespace SoLoud
 {
-	class Soloud;
-	typedef void (*mutexCallFunction)(void *aMutexPtr);
-	typedef void (*soloudCallFunction)(Soloud *aSoloud);
-	typedef unsigned int result;
-	typedef result (*soloudResultFunction)(Soloud *aSoloud);
-	typedef unsigned int handle;
-	typedef double time;
-};
+class Soloud;
+typedef void (*mutexCallFunction)(void *aMutexPtr);
+typedef void (*soloudCallFunction)(Soloud *aSoloud);
+typedef unsigned int result;
+typedef result (*soloudResultFunction)(Soloud *aSoloud);
+typedef unsigned int handle;
+typedef double time;
+}; // namespace SoLoud
 
 namespace SoLoud
 {
-	// Class that handles aligned allocations to support vectorized operations
-	class AlignedFloatBuffer
-	{
-	public:
-		float *mData; // aligned pointer
-		unsigned char *mBasePtr; // raw allocated pointer (for delete)
-		int mFloats; // size of buffer (w/out padding)
-
-		// ctor
-		AlignedFloatBuffer();
-		// Allocate and align buffer
-		result init(unsigned int aFloats);
-		// Clear data to zero.
-		void clear();
-		// dtor
-		~AlignedFloatBuffer();
-	};
+// Class that handles aligned allocations to support vectorized operations
+class AlignedFloatBuffer
+{
+public:
+	float *mData;            // aligned pointer
+	unsigned char *mBasePtr; // raw allocated pointer (for delete)
+	int mFloats;             // size of buffer (w/out padding)
+
+	// ctor
+	AlignedFloatBuffer();
+	// Allocate and align buffer
+	result init(unsigned int aFloats);
+	// Clear data to zero.
+	void clear();
+	// dtor
+	~AlignedFloatBuffer();
+};
 
-	// Lightweight class that handles small aligned buffer to support vectorized operations
-	class TinyAlignedFloatBuffer
-	{
-	public:
-		float *mData; // aligned pointer
-		unsigned char mActualData[sizeof(float) * 16 + 16];
+// Lightweight class that handles small aligned buffer to support vectorized operations
+class TinyAlignedFloatBuffer
+{
+public:
+	float *mData; // aligned pointer
+	unsigned char mActualData[sizeof(float) * 16 + 16];
 
-		// ctor
-		TinyAlignedFloatBuffer();
-	};
+	// ctor
+	TinyAlignedFloatBuffer();
 };
+}; // namespace SoLoud
 
-#include "soloud_filter.h"
-#include "soloud_fader.h"
 #include "soloud_audiosource.h"
 #include "soloud_bus.h"
-#include "soloud_queue.h"
 #include "soloud_error.h"
+#include "soloud_fader.h"
+#include "soloud_filter.h"
+#include "soloud_queue.h"
 
 namespace SoLoud
 {
 
-	// Soloud core class.
-	class Soloud
+// Soloud core class.
+class Soloud
+{
+public:
+	// Back-end data; content is up to the back-end implementation.
+	void *mBackendData;
+	// Pointer for the audio thread mutex.
+	void *mAudioThreadMutex;
+	// Flag for when we're inside the mutex, used for debugging.
+	bool mInsideAudioThreadMutex;
+	// Called by SoLoud to shut down the back-end. If NULL, not called. Should be set by back-end.
+	soloudCallFunction mBackendCleanupFunc;
+
+	// Some backends like CoreAudio on iOS must be paused/resumed in some cases. On incoming call as instance.
+	soloudResultFunction mBackendPauseFunc;
+	soloudResultFunction mBackendResumeFunc;
+
+	// CTor
+	Soloud();
+	// DTor
+	~Soloud();
+
+	enum BACKENDS
+	{
+		AUTO = 0,
+		SDL1,
+		SDL2,
+		SDL3,
+		PORTAUDIO,
+		WINMM,
+		XAUDIO2,
+		WASAPI,
+		ALSA,
+		JACK,
+		OSS,
+		OPENAL,
+		COREAUDIO,
+		OPENSLES,
+		VITA_HOMEBREW,
+		MINIAUDIO,
+		NOSOUND,
+		NULLDRIVER,
+		BACKEND_MAX,
+	};
+
+	enum FLAGS
+	{
+		// Use round-off clipper
+		CLIP_ROUNDOFF = 1,
+		ENABLE_VISUALIZATION = 2,
+		LEFT_HANDED_3D = 4,
+		NO_FPU_REGISTER_CHANGE = 8
+	};
+
+	enum WAVEFORM
+	{
+		WAVE_SQUARE = 0,
+		WAVE_SAW,
+		WAVE_SIN,
+		WAVE_TRIANGLE,
+		WAVE_BOUNCE,
+		WAVE_JAWS,
+		WAVE_HUMPS,
+		WAVE_FSQUARE,
+		WAVE_FSAW
+	};
+
+	enum RESAMPLER
 	{
-	public:
-		// Back-end data; content is up to the back-end implementation.
-		void * mBackendData;
-		// Pointer for the audio thread mutex.
-		void * mAudioThreadMutex;
-		// Flag for when we're inside the mutex, used for debugging.
-		bool mInsideAudioThreadMutex;
-		// Called by SoLoud to shut down the back-end. If NULL, not called. Should be set by back-end.
-		soloudCallFunction mBackendCleanupFunc;
-
-		// Some backends like CoreAudio on iOS must be paused/resumed in some cases. On incoming call as instance.
-		soloudResultFunction mBackendPauseFunc;
-		soloudResultFunction mBackendResumeFunc;
-
-		// CTor
-		Soloud();
-		// DTor
-		~Soloud();
-
-		enum BACKENDS
-		{
-			AUTO = 0,
-			SDL1,
-			SDL2,
-			SDL3,
-			PORTAUDIO,
-			WINMM,
-			XAUDIO2,
-			WASAPI,
-			ALSA,
-			JACK,
-			OSS,
-			OPENAL,
-			COREAUDIO,
-			OPENSLES,
-			VITA_HOMEBREW,
-			MINIAUDIO,
-			NOSOUND,
-			NULLDRIVER,
-			BACKEND_MAX,
-		};
-
-		enum FLAGS
-		{
-			// Use round-off clipper
-			CLIP_ROUNDOFF = 1,
-			ENABLE_VISUALIZATION = 2,
-			LEFT_HANDED_3D = 4,
-			NO_FPU_REGISTER_CHANGE = 8
-		};
-
-		enum WAVEFORM
-		{
-			WAVE_SQUARE = 0,
-			WAVE_SAW,
-			WAVE_SIN,
-			WAVE_TRIANGLE,
-			WAVE_BOUNCE,
-			WAVE_JAWS,
-			WAVE_HUMPS,
-			WAVE_FSQUARE,
-			WAVE_FSAW
-		};
-
-		enum RESAMPLER
-		{
-			RESAMPLER_POINT,
-			RESAMPLER_LINEAR,
-			RESAMPLER_CATMULLROM
-		};
-
-		// Initialize SoLoud. Must be called before SoLoud can be used.
-		result init(unsigned int aFlags = Soloud::CLIP_ROUNDOFF, unsigned int aBackend = Soloud::AUTO, unsigned int aSamplerate = Soloud::AUTO, unsigned int aBufferSize = Soloud::AUTO, unsigned int aChannels = 2);
-
-		result pause();
-		result resume();
-
-		// Deinitialize SoLoud. Must be called before shutting down.
-		void deinit();
-
-		// Query SoLoud version number (should equal to SOLOUD_VERSION macro)
-		unsigned int getVersion() const;
-
-		// Translate error number to an asciiz string
-		const char * getErrorString(result aErrorCode) const;
-
-		// Returns current backend ID (BACKENDS enum)
-		unsigned int getBackendId();
-		// Returns current backend string. May be NULL.
-		const char * getBackendString();
-		// Returns current backend channel count (1 mono, 2 stereo, etc)
-		unsigned int getBackendChannels();
-		// Returns current backend sample rate
-		unsigned int getBackendSamplerate();
-		// Returns current backend buffer size
-		unsigned int getBackendBufferSize();
-
-		// Set speaker position in 3d space
-		result setSpeakerPosition(unsigned int aChannel, float aX, float aY, float aZ);
-		// Get speaker position in 3d space
-		result getSpeakerPosition(unsigned int aChannel, float &aX, float &aY, float &aZ);
-
-		// Start playing a sound. Returns voice handle, which can be ignored or used to alter the playing sound's parameters. Negative volume means to use default.
-		handle play(AudioSource &aSound, float aVolume = -1.0f, float aPan = 0.0f, bool aPaused = 0, unsigned int aBus = 0);
-		// Start playing a sound delayed in relation to other sounds called via this function. Negative volume means to use default.
-		handle playClocked(time aSoundTime, AudioSource &aSound, float aVolume = -1.0f, float aPan = 0.0f, unsigned int aBus = 0);
-		// Start playing a 3d audio source
-		handle play3d(AudioSource &aSound, float aPosX, float aPosY, float aPosZ, float aVelX = 0.0f, float aVelY = 0.0f, float aVelZ = 0.0f, float aVolume = 1.0f, bool aPaused = 0, unsigned int aBus = 0);
-		// Start playing a 3d audio source, delayed in relation to other sounds called via this function.
-		handle play3dClocked(time aSoundTime, AudioSource &aSound, float aPosX, float aPosY, float aPosZ, float aVelX = 0.0f, float aVelY = 0.0f, float aVelZ = 0.0f, float aVolume = 1.0f, unsigned int aBus = 0);
-		// Start playing a sound without any panning. It will be played at full volume.
-		handle playBackground(AudioSource &aSound, float aVolume = -1.0f, bool aPaused = 0, unsigned int aBus = 0);
-
-		// Seek the audio stream to certain point in time. Some streams can't seek backwards. Relative play speed affects time.
-		result seek(handle aVoiceHandle, time aSeconds);
-		// Stop the sound.
-		void stop(handle aVoiceHandle);
-		// Stop all voices.
-		void stopAll();
-		// Stop all voices that play this sound source
-		void stopAudioSource(AudioSource &aSound);
-		// Count voices that play this audio source
-		int countAudioSource(AudioSource &aSound);
-
-		// Set a live filter parameter. Use 0 for the global filters.
-		void setFilterParameter(handle aVoiceHandle, unsigned int aFilterId, unsigned int aAttributeId, float aValue);
-		// Get a live filter parameter. Use 0 for the global filters.
-		float getFilterParameter(handle aVoiceHandle, unsigned int aFilterId, unsigned int aAttributeId);
-		// Fade a live filter parameter. Use 0 for the global filters.
-		void fadeFilterParameter(handle aVoiceHandle, unsigned int aFilterId, unsigned int aAttributeId, float aTo, time aTime);
-		// Oscillate a live filter parameter. Use 0 for the global filters.
-		void oscillateFilterParameter(handle aVoiceHandle, unsigned int aFilterId, unsigned int aAttributeId, float aFrom, float aTo, time aTime);
-
-		// Get current play time, in seconds.
-		time getStreamTime(handle aVoiceHandle);
-		// Get current sample position, in seconds.
-		time getStreamPosition(handle aVoiceHandle);
-		// Get current pause state.
-		bool getPause(handle aVoiceHandle);
-		// Get current volume.
-		float getVolume(handle aVoiceHandle);
-		// Get current overall volume (set volume * 3d volume)
-		float getOverallVolume(handle aVoiceHandle);
-		// Get current pan.
-		float getPan(handle aVoiceHandle);
-		// Get current sample rate.
-		float getSamplerate(handle aVoiceHandle);
-		// Get current voice protection state.
-		bool getProtectVoice(handle aVoiceHandle);
-		// Get the current number of busy voices.
-		unsigned int getActiveVoiceCount();
-		// Get the current number of voices in SoLoud
-		unsigned int getVoiceCount();
-		// Check if the handle is still valid, or if the sound has stopped.
-		bool isValidVoiceHandle(handle aVoiceHandle);
-		// Get current relative play speed.
-		float getRelativePlaySpeed(handle aVoiceHandle);
-		// Get current post-clip scaler value.
-		float getPostClipScaler() const;
-		// Get the current main resampler
-		unsigned int getMainResampler() const;
-		// Get current global volume
-		float getGlobalVolume() const;
-		// Get current maximum active voice setting
-		unsigned int getMaxActiveVoiceCount() const;
-		// Query whether a voice is set to loop.
-		bool getLooping(handle aVoiceHandle);
-		// Query whether a voice is set to auto-stop when it ends.
-		bool getAutoStop(handle aVoiceHandle);
-		// Get voice loop point value
-		time getLoopPoint(handle aVoiceHandle);
-
-		// Set voice loop point value
-		void setLoopPoint(handle aVoiceHandle, time aLoopPoint);
-		// Set voice's loop state
-		void setLooping(handle aVoiceHandle, bool aLooping);
-		// Set whether sound should auto-stop when it ends
-		void setAutoStop(handle aVoiceHandle, bool aAutoStop);
-		// Set current maximum active voice setting
-		result setMaxActiveVoiceCount(unsigned int aVoiceCount);
-		// Set behavior for inaudible sounds
-		void setInaudibleBehavior(handle aVoiceHandle, bool aMustTick, bool aKill);
-		// Set the global volume
-		void setGlobalVolume(float aVolume);
-		// Set the post clip scaler value
-		void setPostClipScaler(float aScaler);
-		// Set the main resampler
-		void setMainResampler(unsigned int aResampler);
-		// Set the pause state
-		void setPause(handle aVoiceHandle, bool aPause);
-		// Pause all voices
-		void setPauseAll(bool aPause);
-		// Set the relative play speed
-		result setRelativePlaySpeed(handle aVoiceHandle, float aSpeed);
-		// Set the voice protection state
-		void setProtectVoice(handle aVoiceHandle, bool aProtect);
-		// Set the sample rate
-		void setSamplerate(handle aVoiceHandle, float aSamplerate);
-		// Set panning value; -1 is left, 0 is center, 1 is right
-		void setPan(handle aVoiceHandle, float aPan);
-		// Set absolute left/right volumes
-		void setPanAbsolute(handle aVoiceHandle, float aLVolume, float aRVolume);
-		// Set channel volume (volume for a specific speaker)
-		void setChannelVolume(handle aVoiceHandle, unsigned int aChannel, float aVolume);
-		// Set overall volume
-		void setVolume(handle aVoiceHandle, float aVolume);
-		// Set delay, in samples, before starting to play samples. Calling this on a live sound will cause glitches.
-		void setDelaySamples(handle aVoiceHandle, unsigned int aSamples);
-
-		// Set up volume fader
-		void fadeVolume(handle aVoiceHandle, float aTo, time aTime);
-		// Set up panning fader
-		void fadePan(handle aVoiceHandle, float aTo, time aTime);
-		// Set up relative play speed fader
-		void fadeRelativePlaySpeed(handle aVoiceHandle, float aTo, time aTime);
-		// Set up global volume fader
-		void fadeGlobalVolume(float aTo, time aTime);
-		// Schedule a stream to pause
-		void schedulePause(handle aVoiceHandle, time aTime);
-		// Schedule a stream to stop
-		void scheduleStop(handle aVoiceHandle, time aTime);
-
-		// Set up volume oscillator
-		void oscillateVolume(handle aVoiceHandle, float aFrom, float aTo, time aTime);
-		// Set up panning oscillator
-		void oscillatePan(handle aVoiceHandle, float aFrom, float aTo, time aTime);
-		// Set up relative play speed oscillator
-		void oscillateRelativePlaySpeed(handle aVoiceHandle, float aFrom, float aTo, time aTime);
-		// Set up global volume oscillator
-		void oscillateGlobalVolume(float aFrom, float aTo, time aTime);
-
-		// Set global filters. Set to NULL to clear the filter.
-		void setGlobalFilter(unsigned int aFilterId, Filter *aFilter);
-
-		// Enable or disable visualization data gathering
-		void setVisualizationEnable(bool aEnable);
-
-		// Calculate and get 256 floats of FFT data for visualization. Visualization has to be enabled before use.
-		float *calcFFT();
-
-		// Get 256 floats of wave data for visualization. Visualization has to be enabled before use.
-		float *getWave();
-
-		// Get approximate output volume for a channel for visualization. Visualization has to be enabled before use.
-		float getApproximateVolume(unsigned int aChannel);
-
-		// Get current loop count. Returns 0 if handle is not valid. (All audio sources may not update loop count)
-		unsigned int getLoopCount(handle aVoiceHandle);
-
-		// Get audiosource-specific information from a voice.
-		float getInfo(handle aVoiceHandle, unsigned int aInfoKey);
-
-		// Create a voice group. Returns 0 if unable (out of voice groups / out of memory)
-		handle createVoiceGroup();
-		// Destroy a voice group.
-		result destroyVoiceGroup(handle aVoiceGroupHandle);
-		// Add a voice handle to a voice group
-		result addVoiceToGroup(handle aVoiceGroupHandle, handle aVoiceHandle);
-		// Is this handle a valid voice group?
-		bool isVoiceGroup(handle aVoiceGroupHandle);
-		// Is this voice group empty?
-		bool isVoiceGroupEmpty(handle aVoiceGroupHandle);
-
-		// Perform 3d audio parameter update
-		void update3dAudio();
-
-		// Set the speed of sound constant for doppler
-		result set3dSoundSpeed(float aSpeed);
-		// Get the current speed of sound constant for doppler
-		float get3dSoundSpeed();
-		// Set 3d listener parameters
-		void set3dListenerParameters(float aPosX, float aPosY, float aPosZ, float aAtX, float aAtY, float aAtZ, float aUpX, float aUpY, float aUpZ, float aVelocityX = 0.0f, float aVelocityY = 0.0f, float aVelocityZ = 0.0f);
-		// Set 3d listener position
-		void set3dListenerPosition(float aPosX, float aPosY, float aPosZ);
-		// Set 3d listener "at" vector
-		void set3dListenerAt(float aAtX, float aAtY, float aAtZ);
-		// set 3d listener "up" vector
-		void set3dListenerUp(float aUpX, float aUpY, float aUpZ);
-		// Set 3d listener velocity
-		void set3dListenerVelocity(float aVelocityX, float aVelocityY, float aVelocityZ);
-
-		// Set 3d audio source parameters
-		void set3dSourceParameters(handle aVoiceHandle, float aPosX, float aPosY, float aPosZ, float aVelocityX = 0.0f, float aVelocityY = 0.0f, float aVelocityZ = 0.0f);
-		// Set 3d audio source position
-		void set3dSourcePosition(handle aVoiceHandle, float aPosX, float aPosY, float aPosZ);
-		// Set 3d audio source velocity
-		void set3dSourceVelocity(handle aVoiceHandle, float aVelocityX, float aVelocityY, float aVelocityZ);
-		// Set 3d audio source min/max distance (distance < min means max volume)
-		void set3dSourceMinMaxDistance(handle aVoiceHandle, float aMinDistance, float aMaxDistance);
-		// Set 3d audio source attenuation parameters
-		void set3dSourceAttenuation(handle aVoiceHandle, unsigned int aAttenuationModel, float aAttenuationRolloffFactor);
-		// Set 3d audio source doppler factor to reduce or enhance doppler effect. Default = 1.0
-		void set3dSourceDopplerFactor(handle aVoiceHandle, float aDopplerFactor);
-
-		// Rest of the stuff is used internally.
-
-		// Returns mixed float samples in buffer. Called by the back-end, or user with null driver.
-		void mix(float *aBuffer, unsigned int aSamples);
-		// Returns mixed 16-bit signed integer samples in buffer. Called by the back-end, or user with null driver.
-		void mixSigned16(short *aBuffer, unsigned int aSamples);
-	public:
-		// Mix N samples * M channels. Called by other mix_ functions.
-		void mix_internal(unsigned int aSamples, unsigned int aStride);
-
-		// Handle rest of initialization (called from backend)
-		void postinit_internal(unsigned int aSamplerate, unsigned int aBufferSize, unsigned int aFlags, unsigned int aChannels);
-
-		// Update list of active voices
-		void calcActiveVoices_internal();
-		// Map resample buffers to active voices
-		void mapResampleBuffers_internal();
-		// Perform mixing for a specific bus
-		void mixBus_internal(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize, float *aScratch, unsigned int aBus, float aSamplerate, unsigned int aChannels, unsigned int aResampler);
-		// Find a free voice, stopping the oldest if no free voice is found.
-		int findFreeVoice_internal();
-		// Converts handle to voice, if the handle is valid. Returns -1 if not.
-		int getVoiceFromHandle_internal(handle aVoiceHandle) const;
-		// Converts voice + playindex into handle
-		handle getHandleFromVoice_internal(unsigned int aVoice) const;
-		// Stop voice (not handle).
-		void stopVoice_internal(unsigned int aVoice);
-		// Set voice (not handle) pan.
-		void setVoicePan_internal(unsigned int aVoice, float aPan);
-		// Set voice (not handle) relative play speed.
-		result setVoiceRelativePlaySpeed_internal(unsigned int aVoice, float aSpeed);
-		// Set voice (not handle) volume.
-		void setVoiceVolume_internal(unsigned int aVoice, float aVolume);
-		// Set voice (not handle) pause state.
-		void setVoicePause_internal(unsigned int aVoice, int aPause);
-		// Update overall volume from set and 3d volumes
-		void updateVoiceVolume_internal(unsigned int aVoice);
-		// Update overall relative play speed from set and 3d speeds
-		void updateVoiceRelativePlaySpeed_internal(unsigned int aVoice);
-		// Perform 3d audio calculation for array of voices
-		void update3dVoices_internal(unsigned int *aVoiceList, unsigned int aVoiceCount);
-		// Clip the samples in the buffer
-		void clip_internal(AlignedFloatBuffer &aBuffer, AlignedFloatBuffer &aDestBuffer, unsigned int aSamples, float aVolume0, float aVolume1);
-		// Remove all non-active voices from group
-		void trimVoiceGroup_internal(handle aVoiceGroupHandle);
-		// Get pointer to the zero-terminated array of voice handles in a voice group
-		handle * voiceGroupHandleToArray_internal(handle aVoiceGroupHandle) const;
-
-		// Lock audio thread mutex.
-		void lockAudioMutex_internal();
-		// Unlock audio thread mutex.
-		void unlockAudioMutex_internal();
-
-		// Max. number of active voices. Busses and tickable inaudibles also count against this.
-		unsigned int mMaxActiveVoices;
-		// Highest voice in use so far
-		unsigned int mHighestVoice;
-		// Scratch buffer, used for resampling.
-		AlignedFloatBuffer mScratch;
-		// Current size of the scratch, in samples.
-		unsigned int mScratchSize;
-		// Output scratch buffer, used in mix_().
-		AlignedFloatBuffer mOutputScratch;
-		// Pointers to resampler buffers, two per active voice.
-		float **mResampleData;
-		// Actual allocated memory for resampler buffers
-		AlignedFloatBuffer mResampleDataBuffer;
-		// Owners of the resample data
-		AudioSourceInstance **mResampleDataOwner;
-		// Audio voices.
-		AudioSourceInstance *mVoice[VOICE_COUNT];
-		// Resampler for the main bus
-		unsigned int mResampler;
-		// Output sample rate (not float)
-		unsigned int mSamplerate;
-		// Output channel count
-		unsigned int mChannels;
-		// Current backend ID
-		unsigned int mBackendID;
-		// Current backend string
-		const char * mBackendString;
-		// Maximum size of output buffer; used to calculate needed scratch.
-		unsigned int mBufferSize;
-		// Flags; see Soloud::FLAGS
-		unsigned int mFlags;
-		// Global volume. Applied before clipping.
-		float mGlobalVolume;
-		// Post-clip scaler. Applied after clipping.
-		float mPostClipScaler;
-		// Current play index. Used to create audio handles.
-		unsigned int mPlayIndex;
-		// Current sound source index. Used to create sound source IDs.
-		unsigned int mAudioSourceID;
-		// Fader for the global volume.
-		Fader mGlobalVolumeFader;
-		// Global stream time, for the global volume fader.
-		time mStreamTime;
-		// Last time seen by the playClocked call
-		time mLastClockedTime;
-		// Global filter
-		Filter *mFilter[FILTERS_PER_STREAM];
-		// Global filter instance
-		FilterInstance *mFilterInstance[FILTERS_PER_STREAM];
-
-		// Approximate volume for channels.
-		float mVisualizationChannelVolume[MAX_CHANNELS];
-		// Mono-mixed wave data for visualization and for visualization FFT input
-		float mVisualizationWaveData[256];
-		// FFT output data
-		float mFFTData[256];
-		// Snapshot of wave data for visualization
-		float mWaveData[256];
-
-		// 3d listener position
-		float m3dPosition[3];
-		// 3d listener look-at
-		float m3dAt[3];
-		// 3d listener up
-		float m3dUp[3];
-		// 3d listener velocity
-		float m3dVelocity[3];
-		// 3d speed of sound (for doppler)
-		float m3dSoundSpeed;
-
-		// 3d position of speakers
-		float m3dSpeakerPosition[3 * MAX_CHANNELS];
-
-		// Data related to 3d processing, separate from AudioSource so we can do 3d calculations without audio mutex.
-		AudioSourceInstance3dData m3dData[VOICE_COUNT];
-
-		// For each voice group, first int is number of ints alocated.
-		unsigned int **mVoiceGroup;
-		unsigned int mVoiceGroupCount;
-
-		// List of currently active voices
-		unsigned int mActiveVoice[VOICE_COUNT];
-		// Number of currently active voices
-		unsigned int mActiveVoiceCount;
-		// Active voices list needs to be recalculated
-		bool mActiveVoiceDirty;
+		RESAMPLER_POINT,
+		RESAMPLER_LINEAR,
+		RESAMPLER_CATMULLROM
 	};
+
+	// Initialize SoLoud. Must be called before SoLoud can be used.
+	result init(unsigned int aFlags = Soloud::CLIP_ROUNDOFF, unsigned int aBackend = Soloud::AUTO, unsigned int aSamplerate = Soloud::AUTO,
+	            unsigned int aBufferSize = Soloud::AUTO, unsigned int aChannels = 2);
+
+	result pause();
+	result resume();
+
+	// Deinitialize SoLoud. Must be called before shutting down.
+	void deinit();
+
+	// Query SoLoud version number (should equal to SOLOUD_VERSION macro)
+	unsigned int getVersion() const;
+
+	// Translate error number to an asciiz string
+	const char *getErrorString(result aErrorCode) const;
+
+	// Returns current backend ID (BACKENDS enum)
+	unsigned int getBackendId();
+	// Returns current backend string. May be NULL.
+	const char *getBackendString();
+	// Returns current backend channel count (1 mono, 2 stereo, etc)
+	unsigned int getBackendChannels();
+	// Returns current backend sample rate
+	unsigned int getBackendSamplerate();
+	// Returns current backend buffer size
+	unsigned int getBackendBufferSize();
+
+	// Set speaker position in 3d space
+	result setSpeakerPosition(unsigned int aChannel, float aX, float aY, float aZ);
+	// Get speaker position in 3d space
+	result getSpeakerPosition(unsigned int aChannel, float &aX, float &aY, float &aZ);
+
+	// Start playing a sound. Returns voice handle, which can be ignored or used to alter the playing sound's parameters. Negative volume means to use default.
+	handle play(AudioSource &aSound, float aVolume = -1.0f, float aPan = 0.0f, bool aPaused = 0, unsigned int aBus = 0);
+	// Start playing a sound delayed in relation to other sounds called via this function. Negative volume means to use default.
+	handle playClocked(time aSoundTime, AudioSource &aSound, float aVolume = -1.0f, float aPan = 0.0f, unsigned int aBus = 0);
+	// Start playing a 3d audio source
+	handle play3d(AudioSource &aSound, float aPosX, float aPosY, float aPosZ, float aVelX = 0.0f, float aVelY = 0.0f, float aVelZ = 0.0f, float aVolume = 1.0f,
+	              bool aPaused = 0, unsigned int aBus = 0);
+	// Start playing a 3d audio source, delayed in relation to other sounds called via this function.
+	handle play3dClocked(time aSoundTime, AudioSource &aSound, float aPosX, float aPosY, float aPosZ, float aVelX = 0.0f, float aVelY = 0.0f, float aVelZ = 0.0f,
+	                     float aVolume = 1.0f, unsigned int aBus = 0);
+	// Start playing a sound without any panning. It will be played at full volume.
+	handle playBackground(AudioSource &aSound, float aVolume = -1.0f, bool aPaused = 0, unsigned int aBus = 0);
+
+	// Seek the audio stream to certain point in time. Some streams can't seek backwards. Relative play speed affects time.
+	result seek(handle aVoiceHandle, time aSeconds);
+	// Stop the sound.
+	void stop(handle aVoiceHandle);
+	// Stop all voices.
+	void stopAll();
+	// Stop all voices that play this sound source
+	void stopAudioSource(AudioSource &aSound);
+	// Count voices that play this audio source
+	int countAudioSource(AudioSource &aSound);
+
+	// Set a live filter parameter. Use 0 for the global filters.
+	void setFilterParameter(handle aVoiceHandle, unsigned int aFilterId, unsigned int aAttributeId, float aValue);
+	// Get a live filter parameter. Use 0 for the global filters.
+	float getFilterParameter(handle aVoiceHandle, unsigned int aFilterId, unsigned int aAttributeId);
+	// Fade a live filter parameter. Use 0 for the global filters.
+	void fadeFilterParameter(handle aVoiceHandle, unsigned int aFilterId, unsigned int aAttributeId, float aTo, time aTime);
+	// Oscillate a live filter parameter. Use 0 for the global filters.
+	void oscillateFilterParameter(handle aVoiceHandle, unsigned int aFilterId, unsigned int aAttributeId, float aFrom, float aTo, time aTime);
+
+	// Get current play time, in seconds.
+	time getStreamTime(handle aVoiceHandle);
+	// Get current sample position, in seconds.
+	time getStreamPosition(handle aVoiceHandle);
+	// Get current pause state.
+	bool getPause(handle aVoiceHandle);
+	// Get current volume.
+	float getVolume(handle aVoiceHandle);
+	// Get current overall volume (set volume * 3d volume)
+	float getOverallVolume(handle aVoiceHandle);
+	// Get current pan.
+	float getPan(handle aVoiceHandle);
+	// Get current sample rate.
+	float getSamplerate(handle aVoiceHandle);
+	// Get current voice protection state.
+	bool getProtectVoice(handle aVoiceHandle);
+	// Get the current number of busy voices.
+	unsigned int getActiveVoiceCount();
+	// Get the current number of voices in SoLoud
+	unsigned int getVoiceCount();
+	// Check if the handle is still valid, or if the sound has stopped.
+	bool isValidVoiceHandle(handle aVoiceHandle);
+	// Get current relative play speed.
+	float getRelativePlaySpeed(handle aVoiceHandle);
+	// Get current post-clip scaler value.
+	float getPostClipScaler() const;
+	// Get the current main resampler
+	unsigned int getMainResampler() const;
+	// Get current global volume
+	float getGlobalVolume() const;
+	// Get current maximum active voice setting
+	unsigned int getMaxActiveVoiceCount() const;
+	// Query whether a voice is set to loop.
+	bool getLooping(handle aVoiceHandle);
+	// Query whether a voice is set to auto-stop when it ends.
+	bool getAutoStop(handle aVoiceHandle);
+	// Get voice loop point value
+	time getLoopPoint(handle aVoiceHandle);
+
+	// Set voice loop point value
+	void setLoopPoint(handle aVoiceHandle, time aLoopPoint);
+	// Set voice's loop state
+	void setLooping(handle aVoiceHandle, bool aLooping);
+	// Set whether sound should auto-stop when it ends
+	void setAutoStop(handle aVoiceHandle, bool aAutoStop);
+	// Set current maximum active voice setting
+	result setMaxActiveVoiceCount(unsigned int aVoiceCount);
+	// Set behavior for inaudible sounds
+	void setInaudibleBehavior(handle aVoiceHandle, bool aMustTick, bool aKill);
+	// Set the global volume
+	void setGlobalVolume(float aVolume);
+	// Set the post clip scaler value
+	void setPostClipScaler(float aScaler);
+	// Set the main resampler
+	void setMainResampler(unsigned int aResampler);
+	// Set the pause state
+	void setPause(handle aVoiceHandle, bool aPause);
+	// Pause all voices
+	void setPauseAll(bool aPause);
+	// Set the relative play speed
+	result setRelativePlaySpeed(handle aVoiceHandle, float aSpeed);
+	// Set the voice protection state
+	void setProtectVoice(handle aVoiceHandle, bool aProtect);
+	// Set the sample rate
+	void setSamplerate(handle aVoiceHandle, float aSamplerate);
+	// Set panning value; -1 is left, 0 is center, 1 is right
+	void setPan(handle aVoiceHandle, float aPan);
+	// Set absolute left/right volumes
+	void setPanAbsolute(handle aVoiceHandle, float aLVolume, float aRVolume);
+	// Set channel volume (volume for a specific speaker)
+	void setChannelVolume(handle aVoiceHandle, unsigned int aChannel, float aVolume);
+	// Set overall volume
+	void setVolume(handle aVoiceHandle, float aVolume);
+	// Set delay, in samples, before starting to play samples. Calling this on a live sound will cause glitches.
+	void setDelaySamples(handle aVoiceHandle, unsigned int aSamples);
+
+	// Set up volume fader
+	void fadeVolume(handle aVoiceHandle, float aTo, time aTime);
+	// Set up panning fader
+	void fadePan(handle aVoiceHandle, float aTo, time aTime);
+	// Set up relative play speed fader
+	void fadeRelativePlaySpeed(handle aVoiceHandle, float aTo, time aTime);
+	// Set up global volume fader
+	void fadeGlobalVolume(float aTo, time aTime);
+	// Schedule a stream to pause
+	void schedulePause(handle aVoiceHandle, time aTime);
+	// Schedule a stream to stop
+	void scheduleStop(handle aVoiceHandle, time aTime);
+
+	// Set up volume oscillator
+	void oscillateVolume(handle aVoiceHandle, float aFrom, float aTo, time aTime);
+	// Set up panning oscillator
+	void oscillatePan(handle aVoiceHandle, float aFrom, float aTo, time aTime);
+	// Set up relative play speed oscillator
+	void oscillateRelativePlaySpeed(handle aVoiceHandle, float aFrom, float aTo, time aTime);
+	// Set up global volume oscillator
+	void oscillateGlobalVolume(float aFrom, float aTo, time aTime);
+
+	// Set global filters. Set to NULL to clear the filter.
+	void setGlobalFilter(unsigned int aFilterId, Filter *aFilter);
+
+	// Enable or disable visualization data gathering
+	void setVisualizationEnable(bool aEnable);
+
+	// Calculate and get 256 floats of FFT data for visualization. Visualization has to be enabled before use.
+	float *calcFFT();
+
+	// Get 256 floats of wave data for visualization. Visualization has to be enabled before use.
+	float *getWave();
+
+	// Get approximate output volume for a channel for visualization. Visualization has to be enabled before use.
+	float getApproximateVolume(unsigned int aChannel);
+
+	// Get current loop count. Returns 0 if handle is not valid. (All audio sources may not update loop count)
+	unsigned int getLoopCount(handle aVoiceHandle);
+
+	// Get audiosource-specific information from a voice.
+	float getInfo(handle aVoiceHandle, unsigned int aInfoKey);
+
+	// Create a voice group. Returns 0 if unable (out of voice groups / out of memory)
+	handle createVoiceGroup();
+	// Destroy a voice group.
+	result destroyVoiceGroup(handle aVoiceGroupHandle);
+	// Add a voice handle to a voice group
+	result addVoiceToGroup(handle aVoiceGroupHandle, handle aVoiceHandle);
+	// Is this handle a valid voice group?
+	bool isVoiceGroup(handle aVoiceGroupHandle);
+	// Is this voice group empty?
+	bool isVoiceGroupEmpty(handle aVoiceGroupHandle);
+
+	// Perform 3d audio parameter update
+	void update3dAudio();
+
+	// Set the speed of sound constant for doppler
+	result set3dSoundSpeed(float aSpeed);
+	// Get the current speed of sound constant for doppler
+	float get3dSoundSpeed();
+	// Set 3d listener parameters
+	void set3dListenerParameters(float aPosX, float aPosY, float aPosZ, float aAtX, float aAtY, float aAtZ, float aUpX, float aUpY, float aUpZ,
+	                             float aVelocityX = 0.0f, float aVelocityY = 0.0f, float aVelocityZ = 0.0f);
+	// Set 3d listener position
+	void set3dListenerPosition(float aPosX, float aPosY, float aPosZ);
+	// Set 3d listener "at" vector
+	void set3dListenerAt(float aAtX, float aAtY, float aAtZ);
+	// set 3d listener "up" vector
+	void set3dListenerUp(float aUpX, float aUpY, float aUpZ);
+	// Set 3d listener velocity
+	void set3dListenerVelocity(float aVelocityX, float aVelocityY, float aVelocityZ);
+
+	// Set 3d audio source parameters
+	void set3dSourceParameters(handle aVoiceHandle, float aPosX, float aPosY, float aPosZ, float aVelocityX = 0.0f, float aVelocityY = 0.0f,
+	                           float aVelocityZ = 0.0f);
+	// Set 3d audio source position
+	void set3dSourcePosition(handle aVoiceHandle, float aPosX, float aPosY, float aPosZ);
+	// Set 3d audio source velocity
+	void set3dSourceVelocity(handle aVoiceHandle, float aVelocityX, float aVelocityY, float aVelocityZ);
+	// Set 3d audio source min/max distance (distance < min means max volume)
+	void set3dSourceMinMaxDistance(handle aVoiceHandle, float aMinDistance, float aMaxDistance);
+	// Set 3d audio source attenuation parameters
+	void set3dSourceAttenuation(handle aVoiceHandle, unsigned int aAttenuationModel, float aAttenuationRolloffFactor);
+	// Set 3d audio source doppler factor to reduce or enhance doppler effect. Default = 1.0
+	void set3dSourceDopplerFactor(handle aVoiceHandle, float aDopplerFactor);
+
+	// Rest of the stuff is used internally.
+
+	// Returns mixed float samples in buffer. Called by the back-end, or user with null driver.
+	void mix(float *aBuffer, unsigned int aSamples);
+	// Returns mixed 16-bit signed integer samples in buffer. Called by the back-end, or user with null driver.
+	void mixSigned16(short *aBuffer, unsigned int aSamples);
+
+public:
+	// Mix N samples * M channels. Called by other mix_ functions.
+	void mix_internal(unsigned int aSamples, unsigned int aStride);
+
+	// Handle rest of initialization (called from backend)
+	void postinit_internal(unsigned int aSamplerate, unsigned int aBufferSize, unsigned int aFlags, unsigned int aChannels);
+
+	// Update list of active voices
+	void calcActiveVoices_internal();
+	// Map resample buffers to active voices
+	void mapResampleBuffers_internal();
+	// Perform mixing for a specific bus
+	void mixBus_internal(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize, float *aScratch, unsigned int aBus, float aSamplerate,
+	                     unsigned int aChannels, unsigned int aResampler);
+	// Find a free voice, stopping the oldest if no free voice is found.
+	int findFreeVoice_internal();
+	// Converts handle to voice, if the handle is valid. Returns -1 if not.
+	int getVoiceFromHandle_internal(handle aVoiceHandle) const;
+	// Converts voice + playindex into handle
+	handle getHandleFromVoice_internal(unsigned int aVoice) const;
+	// Stop voice (not handle).
+	void stopVoice_internal(unsigned int aVoice);
+	// Set voice (not handle) pan.
+	void setVoicePan_internal(unsigned int aVoice, float aPan);
+	// Set voice (not handle) relative play speed.
+	result setVoiceRelativePlaySpeed_internal(unsigned int aVoice, float aSpeed);
+	// Set voice (not handle) volume.
+	void setVoiceVolume_internal(unsigned int aVoice, float aVolume);
+	// Set voice (not handle) pause state.
+	void setVoicePause_internal(unsigned int aVoice, int aPause);
+	// Update overall volume from set and 3d volumes
+	void updateVoiceVolume_internal(unsigned int aVoice);
+	// Update overall relative play speed from set and 3d speeds
+	void updateVoiceRelativePlaySpeed_internal(unsigned int aVoice);
+	// Perform 3d audio calculation for array of voices
+	void update3dVoices_internal(unsigned int *aVoiceList, unsigned int aVoiceCount);
+	// Clip the samples in the buffer
+	void clip_internal(AlignedFloatBuffer &aBuffer, AlignedFloatBuffer &aDestBuffer, unsigned int aSamples, float aVolume0, float aVolume1);
+	// Remove all non-active voices from group
+	void trimVoiceGroup_internal(handle aVoiceGroupHandle);
+	// Get pointer to the zero-terminated array of voice handles in a voice group
+	handle *voiceGroupHandleToArray_internal(handle aVoiceGroupHandle) const;
+
+	// Lock audio thread mutex.
+	void lockAudioMutex_internal();
+	// Unlock audio thread mutex.
+	void unlockAudioMutex_internal();
+
+	// Max. number of active voices. Busses and tickable inaudibles also count against this.
+	unsigned int mMaxActiveVoices;
+	// Highest voice in use so far
+	unsigned int mHighestVoice;
+	// Scratch buffer, used for resampling.
+	AlignedFloatBuffer mScratch;
+	// Current size of the scratch, in samples.
+	unsigned int mScratchSize;
+	// Output scratch buffer, used in mix_().
+	AlignedFloatBuffer mOutputScratch;
+	// Pointers to resampler buffers, two per active voice.
+	float **mResampleData;
+	// Actual allocated memory for resampler buffers
+	AlignedFloatBuffer mResampleDataBuffer;
+	// Owners of the resample data
+	AudioSourceInstance **mResampleDataOwner;
+	// Audio voices.
+	AudioSourceInstance *mVoice[VOICE_COUNT];
+	// Resampler for the main bus
+	unsigned int mResampler;
+	// Output sample rate (not float)
+	unsigned int mSamplerate;
+	// Output channel count
+	unsigned int mChannels;
+	// Current backend ID
+	unsigned int mBackendID;
+	// Current backend string
+	const char *mBackendString;
+	// Maximum size of output buffer; used to calculate needed scratch.
+	unsigned int mBufferSize;
+	// Flags; see Soloud::FLAGS
+	unsigned int mFlags;
+	// Global volume. Applied before clipping.
+	float mGlobalVolume;
+	// Post-clip scaler. Applied after clipping.
+	float mPostClipScaler;
+	// Current play index. Used to create audio handles.
+	unsigned int mPlayIndex;
+	// Current sound source index. Used to create sound source IDs.
+	unsigned int mAudioSourceID;
+	// Fader for the global volume.
+	Fader mGlobalVolumeFader;
+	// Global stream time, for the global volume fader.
+	time mStreamTime;
+	// Last time seen by the playClocked call
+	time mLastClockedTime;
+	// Global filter
+	Filter *mFilter[FILTERS_PER_STREAM];
+	// Global filter instance
+	FilterInstance *mFilterInstance[FILTERS_PER_STREAM];
+
+	// Approximate volume for channels.
+	float mVisualizationChannelVolume[MAX_CHANNELS];
+	// Mono-mixed wave data for visualization and for visualization FFT input
+	float mVisualizationWaveData[256];
+	// FFT output data
+	float mFFTData[256];
+	// Snapshot of wave data for visualization
+	float mWaveData[256];
+
+	// 3d listener position
+	float m3dPosition[3];
+	// 3d listener look-at
+	float m3dAt[3];
+	// 3d listener up
+	float m3dUp[3];
+	// 3d listener velocity
+	float m3dVelocity[3];
+	// 3d speed of sound (for doppler)
+	float m3dSoundSpeed;
+
+	// 3d position of speakers
+	float m3dSpeakerPosition[3 * MAX_CHANNELS];
+
+	// Data related to 3d processing, separate from AudioSource so we can do 3d calculations without audio mutex.
+	AudioSourceInstance3dData m3dData[VOICE_COUNT];
+
+	// For each voice group, first int is number of ints alocated.
+	unsigned int **mVoiceGroup;
+	unsigned int mVoiceGroupCount;
+
+	// List of currently active voices
+	unsigned int mActiveVoice[VOICE_COUNT];
+	// Number of currently active voices
+	unsigned int mActiveVoiceCount;
+	// Active voices list needs to be recalculated
+	bool mActiveVoiceDirty;
 };
+}; // namespace SoLoud
 
 #endif
diff --git a/include/soloud_audiosource.h b/include/soloud_audiosource.h
index c155705..b91a1ce 100644
--- a/include/soloud_audiosource.h
+++ b/include/soloud_audiosource.h
@@ -31,291 +31,291 @@ freely, subject to the following restrictions:
 
 namespace SoLoud
 {
-	class AudioSource;	
-	class AudioSourceInstance;
-	class AudioSourceInstance3dData;
+class AudioSource;
+class AudioSourceInstance;
+class AudioSourceInstance3dData;
 
-	class AudioCollider
-	{
-	public:
-		// Calculate volume multiplier. Assumed to return value between 0 and 1.
-		virtual float collide(Soloud *aSoloud, AudioSourceInstance3dData *aAudioInstance3dData,	int aUserData) = 0;
-	};
+class AudioCollider
+{
+public:
+	// Calculate volume multiplier. Assumed to return value between 0 and 1.
+	virtual float collide(Soloud *aSoloud, AudioSourceInstance3dData *aAudioInstance3dData, int aUserData) = 0;
+};
 
-	class AudioAttenuator
-	{
-	public:
-		virtual float attenuate(float aDistance, float aMinDistance, float aMaxDistance, float aRolloffFactor) = 0;
-	};
+class AudioAttenuator
+{
+public:
+	virtual float attenuate(float aDistance, float aMinDistance, float aMaxDistance, float aRolloffFactor) = 0;
+};
 
-	class AudioSourceInstance3dData
-	{
-	public:
-		// ctor
-		AudioSourceInstance3dData();
-		// Set settings from audiosource
-		void init(AudioSource &aSource);
-		// 3d position
-		float m3dPosition[3];
-		// 3d velocity
-		float m3dVelocity[3];
-		// 3d cone direction
-		/*
-		float m3dConeDirection[3];
-		// 3d cone inner angle
-		float m3dConeInnerAngle;
-		// 3d cone outer angle
-		float m3dConeOuterAngle;
-		// 3d cone outer volume multiplier
-		float m3dConeOuterVolume;
-		*/
-		// 3d min distance
-		float m3dMinDistance;
-		// 3d max distance
-		float m3dMaxDistance;
-		// 3d attenuation rolloff factor
-		float m3dAttenuationRolloff;
-		// 3d attenuation model
-		unsigned int m3dAttenuationModel;
-		// 3d doppler factor
-		float m3dDopplerFactor;
-		// Pointer to a custom audio collider object
-		AudioCollider *mCollider;
-		// Pointer to a custom audio attenuator object
-		AudioAttenuator *mAttenuator;
-		// User data related to audio collider
-		int mColliderData;
+class AudioSourceInstance3dData
+{
+public:
+	// ctor
+	AudioSourceInstance3dData();
+	// Set settings from audiosource
+	void init(AudioSource &aSource);
+	// 3d position
+	float m3dPosition[3];
+	// 3d velocity
+	float m3dVelocity[3];
+	// 3d cone direction
+	/*
+	float m3dConeDirection[3];
+	// 3d cone inner angle
+	float m3dConeInnerAngle;
+	// 3d cone outer angle
+	float m3dConeOuterAngle;
+	// 3d cone outer volume multiplier
+	float m3dConeOuterVolume;
+	*/
+	// 3d min distance
+	float m3dMinDistance;
+	// 3d max distance
+	float m3dMaxDistance;
+	// 3d attenuation rolloff factor
+	float m3dAttenuationRolloff;
+	// 3d attenuation model
+	unsigned int m3dAttenuationModel;
+	// 3d doppler factor
+	float m3dDopplerFactor;
+	// Pointer to a custom audio collider object
+	AudioCollider *mCollider;
+	// Pointer to a custom audio attenuator object
+	AudioAttenuator *mAttenuator;
+	// User data related to audio collider
+	int mColliderData;
 
-		// Doppler sample rate multiplier
-		float mDopplerValue;		
-		// Overall 3d volume
-		float m3dVolume;
-		// Channel volume
-		float mChannelVolume[MAX_CHANNELS];
-		// Copy of flags
-		unsigned int mFlags;
-		// Latest handle for this voice
-		handle mHandle;
-	};
+	// Doppler sample rate multiplier
+	float mDopplerValue;
+	// Overall 3d volume
+	float m3dVolume;
+	// Channel volume
+	float mChannelVolume[MAX_CHANNELS];
+	// Copy of flags
+	unsigned int mFlags;
+	// Latest handle for this voice
+	handle mHandle;
+};
 
-	// Base class for audio instances
-	class AudioSourceInstance
+// Base class for audio instances
+class AudioSourceInstance
+{
+public:
+	enum FLAGS
 	{
-	public:
-		enum FLAGS
-		{			
-			// This audio instance loops (if supported)
-			LOOPING = 1,
-			// This audio instance is protected - won't get stopped if we run out of voices
-			PROTECTED = 2,
-			// This audio instance is paused
-			PAUSED = 4,
-			// This audio instance is affected by 3d processing
-			PROCESS_3D = 8,
-			// This audio instance has listener-relative 3d coordinates
-			LISTENER_RELATIVE = 16,
-			// Currently inaudible
-			INAUDIBLE = 32,
-			// If inaudible, should be killed (default = don't kill kill)
-			INAUDIBLE_KILL = 64,
-			// If inaudible, should still be ticked (default = pause)
-			INAUDIBLE_TICK = 128,
-			// Don't auto-stop sound
-			DISABLE_AUTOSTOP = 256
-		};
-		// Ctor
-		AudioSourceInstance();
-		// Dtor
-		virtual ~AudioSourceInstance();
-		// Play index; used to identify instances from handles
-		unsigned int mPlayIndex;
-		// Loop count
-		unsigned int mLoopCount;
-		// Flags; see AudioSourceInstance::FLAGS
-		unsigned int mFlags;
-		// Pan value, for getPan()
-		float mPan;
-		// Volume for each channel (panning)
-		float mChannelVolume[MAX_CHANNELS];
-		// Set volume
-		float mSetVolume;
-		// Overall volume overall = set * 3d
-		float mOverallVolume;
-		// Base samplerate; samplerate = base samplerate * relative play speed
-		float mBaseSamplerate;
-		// Samplerate; samplerate = base samplerate * relative play speed
-		float mSamplerate;
-		// Number of channels this audio source produces
-		unsigned int mChannels;
-		// Relative play speed; samplerate = base samplerate * relative play speed
-		float mSetRelativePlaySpeed;
-		// Overall relative plays peed; overall = set * 3d
-		float mOverallRelativePlaySpeed;
-		// How long this stream has played, in seconds.
-		time mStreamTime;
-		// Position of this stream, in seconds.
-		time mStreamPosition;
-		// Fader for the audio panning
-		Fader mPanFader;
-		// Fader for the audio volume
-		Fader mVolumeFader;
-		// Fader for the relative play speed
-		Fader mRelativePlaySpeedFader;
-		// Fader used to schedule pausing of the stream
-		Fader mPauseScheduler;
-		// Fader used to schedule stopping of the stream
-		Fader mStopScheduler;
-		// Affected by some fader
-		int mActiveFader;
-		// Current channel volumes, used to ramp the volume changes to avoid clicks
-		float mCurrentChannelVolume[MAX_CHANNELS];
-		// ID of the sound source that generated this instance
-		unsigned int mAudioSourceID;
-		// Handle of the bus this audio instance is playing on. 0 for root.
-		unsigned int mBusHandle;
-		// Filter pointer
-		FilterInstance *mFilter[FILTERS_PER_STREAM];
-		// Initialize instance. Mostly internal use.
-		void init(AudioSource &aSource, int aPlayIndex);
-		// Pointers to buffers for the resampler
-		float *mResampleData[2];
-		// Sub-sample playhead; 16.16 fixed point
-		unsigned int mSrcOffset;
-		// Samples left over from earlier pass
-		unsigned int mLeftoverSamples;
-		// Number of samples to delay streaming
-		unsigned int mDelaySamples;
-		// When looping, start playing from this time
-		time mLoopPoint;
-
-		// Get N samples from the stream to the buffer. Report samples written.
-		virtual unsigned int getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize) = 0;
-		// Has the stream ended?
-		virtual bool hasEnded() = 0;
-		// Seek to certain place in the stream. Base implementation is generic "tape" seek (and slow).
-		virtual result seek(time aSeconds, float *mScratch, unsigned int mScratchSize);
-		// Rewind stream. Base implementation returns NOT_IMPLEMENTED, meaning it can't rewind.
-		virtual result rewind();
-		// Get information. Returns 0 by default.
-		virtual float getInfo(unsigned int aInfoKey);
+		// This audio instance loops (if supported)
+		LOOPING = 1,
+		// This audio instance is protected - won't get stopped if we run out of voices
+		PROTECTED = 2,
+		// This audio instance is paused
+		PAUSED = 4,
+		// This audio instance is affected by 3d processing
+		PROCESS_3D = 8,
+		// This audio instance has listener-relative 3d coordinates
+		LISTENER_RELATIVE = 16,
+		// Currently inaudible
+		INAUDIBLE = 32,
+		// If inaudible, should be killed (default = don't kill kill)
+		INAUDIBLE_KILL = 64,
+		// If inaudible, should still be ticked (default = pause)
+		INAUDIBLE_TICK = 128,
+		// Don't auto-stop sound
+		DISABLE_AUTOSTOP = 256
 	};
+	// Ctor
+	AudioSourceInstance();
+	// Dtor
+	virtual ~AudioSourceInstance();
+	// Play index; used to identify instances from handles
+	unsigned int mPlayIndex;
+	// Loop count
+	unsigned int mLoopCount;
+	// Flags; see AudioSourceInstance::FLAGS
+	unsigned int mFlags;
+	// Pan value, for getPan()
+	float mPan;
+	// Volume for each channel (panning)
+	float mChannelVolume[MAX_CHANNELS];
+	// Set volume
+	float mSetVolume;
+	// Overall volume overall = set * 3d
+	float mOverallVolume;
+	// Base samplerate; samplerate = base samplerate * relative play speed
+	float mBaseSamplerate;
+	// Samplerate; samplerate = base samplerate * relative play speed
+	float mSamplerate;
+	// Number of channels this audio source produces
+	unsigned int mChannels;
+	// Relative play speed; samplerate = base samplerate * relative play speed
+	float mSetRelativePlaySpeed;
+	// Overall relative plays peed; overall = set * 3d
+	float mOverallRelativePlaySpeed;
+	// How long this stream has played, in seconds.
+	time mStreamTime;
+	// Position of this stream, in seconds.
+	time mStreamPosition;
+	// Fader for the audio panning
+	Fader mPanFader;
+	// Fader for the audio volume
+	Fader mVolumeFader;
+	// Fader for the relative play speed
+	Fader mRelativePlaySpeedFader;
+	// Fader used to schedule pausing of the stream
+	Fader mPauseScheduler;
+	// Fader used to schedule stopping of the stream
+	Fader mStopScheduler;
+	// Affected by some fader
+	int mActiveFader;
+	// Current channel volumes, used to ramp the volume changes to avoid clicks
+	float mCurrentChannelVolume[MAX_CHANNELS];
+	// ID of the sound source that generated this instance
+	unsigned int mAudioSourceID;
+	// Handle of the bus this audio instance is playing on. 0 for root.
+	unsigned int mBusHandle;
+	// Filter pointer
+	FilterInstance *mFilter[FILTERS_PER_STREAM];
+	// Initialize instance. Mostly internal use.
+	void init(AudioSource &aSource, int aPlayIndex);
+	// Pointers to buffers for the resampler
+	float *mResampleData[2];
+	// Sub-sample playhead; 16.16 fixed point
+	unsigned int mSrcOffset;
+	// Samples left over from earlier pass
+	unsigned int mLeftoverSamples;
+	// Number of samples to delay streaming
+	unsigned int mDelaySamples;
+	// When looping, start playing from this time
+	time mLoopPoint;
 
-	class Soloud;
+	// Get N samples from the stream to the buffer. Report samples written.
+	virtual unsigned int getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize) = 0;
+	// Has the stream ended?
+	virtual bool hasEnded() = 0;
+	// Seek to certain place in the stream. Base implementation is generic "tape" seek (and slow).
+	virtual result seek(time aSeconds, float *mScratch, unsigned int mScratchSize);
+	// Rewind stream. Base implementation returns NOT_IMPLEMENTED, meaning it can't rewind.
+	virtual result rewind();
+	// Get information. Returns 0 by default.
+	virtual float getInfo(unsigned int aInfoKey);
+};
+
+class Soloud;
 
-	// Base class for audio sources
-	class AudioSource
+// Base class for audio sources
+class AudioSource
+{
+public:
+	enum FLAGS
 	{
-	public:
-		enum FLAGS
-		{
-			// The instances from this audio source should loop
-			SHOULD_LOOP = 1,
-			// Only one instance of this audio source should play at the same time
-			SINGLE_INSTANCE = 2,
-			// Visualization data gathering enabled. Only for busses.
-			VISUALIZATION_DATA = 4,
-			// Audio instances created from this source are affected by 3d processing
-			PROCESS_3D = 8,
-			// Audio instances created from this source have listener-relative 3d coordinates
-			LISTENER_RELATIVE = 16,
-			// Delay start of sound by the distance from listener
-			DISTANCE_DELAY = 32,
-			// If inaudible, should be killed (default)
-			INAUDIBLE_KILL = 64,
-			// If inaudible, should still be ticked (default = pause)
-			INAUDIBLE_TICK = 128,
-			// Disable auto-stop
-			DISABLE_AUTOSTOP = 256
-		};
-		enum ATTENUATION_MODELS
-		{
-			// No attenuation
-			NO_ATTENUATION = 0,
-			// Inverse distance attenuation model
-			INVERSE_DISTANCE = 1,
-			// Linear distance attenuation model
-			LINEAR_DISTANCE = 2,
-			// Exponential distance attenuation model
-			EXPONENTIAL_DISTANCE = 3
-		};
+		// The instances from this audio source should loop
+		SHOULD_LOOP = 1,
+		// Only one instance of this audio source should play at the same time
+		SINGLE_INSTANCE = 2,
+		// Visualization data gathering enabled. Only for busses.
+		VISUALIZATION_DATA = 4,
+		// Audio instances created from this source are affected by 3d processing
+		PROCESS_3D = 8,
+		// Audio instances created from this source have listener-relative 3d coordinates
+		LISTENER_RELATIVE = 16,
+		// Delay start of sound by the distance from listener
+		DISTANCE_DELAY = 32,
+		// If inaudible, should be killed (default)
+		INAUDIBLE_KILL = 64,
+		// If inaudible, should still be ticked (default = pause)
+		INAUDIBLE_TICK = 128,
+		// Disable auto-stop
+		DISABLE_AUTOSTOP = 256
+	};
+	enum ATTENUATION_MODELS
+	{
+		// No attenuation
+		NO_ATTENUATION = 0,
+		// Inverse distance attenuation model
+		INVERSE_DISTANCE = 1,
+		// Linear distance attenuation model
+		LINEAR_DISTANCE = 2,
+		// Exponential distance attenuation model
+		EXPONENTIAL_DISTANCE = 3
+	};
 
-		// Flags. See AudioSource::FLAGS
-		unsigned int mFlags;
-		// Base sample rate, used to initialize instances
-		float mBaseSamplerate;
-		// Default volume for created instances
-		float mVolume;
-		// Number of channels this audio source produces
-		unsigned int mChannels;
-		// Sound source ID. Assigned by SoLoud the first time it's played.
-		unsigned int mAudioSourceID;
-		// 3d min distance
-		float m3dMinDistance;
-		// 3d max distance
-		float m3dMaxDistance;
-		// 3d attenuation rolloff factor
-		float m3dAttenuationRolloff;
-		// 3d attenuation model
-		unsigned int m3dAttenuationModel;
-		// 3d doppler factor
-		float m3dDopplerFactor;
-		// Filter pointer
-		Filter *mFilter[FILTERS_PER_STREAM];
-		// Pointer to the Soloud object. Needed to stop all instances in dtor.
-		Soloud *mSoloud;
-		// Pointer to a custom audio collider object
-		AudioCollider *mCollider;
-		// Pointer to custom attenuator object
-		AudioAttenuator *mAttenuator;
-		// User data related to audio collider
-		int mColliderData;
-		// When looping, start playing from this time
-		time mLoopPoint;
+	// Flags. See AudioSource::FLAGS
+	unsigned int mFlags;
+	// Base sample rate, used to initialize instances
+	float mBaseSamplerate;
+	// Default volume for created instances
+	float mVolume;
+	// Number of channels this audio source produces
+	unsigned int mChannels;
+	// Sound source ID. Assigned by SoLoud the first time it's played.
+	unsigned int mAudioSourceID;
+	// 3d min distance
+	float m3dMinDistance;
+	// 3d max distance
+	float m3dMaxDistance;
+	// 3d attenuation rolloff factor
+	float m3dAttenuationRolloff;
+	// 3d attenuation model
+	unsigned int m3dAttenuationModel;
+	// 3d doppler factor
+	float m3dDopplerFactor;
+	// Filter pointer
+	Filter *mFilter[FILTERS_PER_STREAM];
+	// Pointer to the Soloud object. Needed to stop all instances in dtor.
+	Soloud *mSoloud;
+	// Pointer to a custom audio collider object
+	AudioCollider *mCollider;
+	// Pointer to custom attenuator object
+	AudioAttenuator *mAttenuator;
+	// User data related to audio collider
+	int mColliderData;
+	// When looping, start playing from this time
+	time mLoopPoint;
 
-		// CTor
-		AudioSource();
-		// Set default volume for instances
-		void setVolume(float aVolume);
-		// Set the looping of the instances created from this audio source
-		void setLooping(bool aLoop);
-		// Set whether only one instance of this sound should ever be playing at the same time
-		void setSingleInstance(bool aSingleInstance);
-		// Set whether audio should auto-stop when it ends or not
-		void setAutoStop(bool aAutoStop);
-		
-		// Set the minimum and maximum distances for 3d audio source (closer to min distance = max vol)
-		void set3dMinMaxDistance(float aMinDistance, float aMaxDistance);
-		// Set attenuation model and rolloff factor for 3d audio source
-		void set3dAttenuation(unsigned int aAttenuationModel, float aAttenuationRolloffFactor);
-		// Set doppler factor to reduce or enhance doppler effect, default = 1.0
-		void set3dDopplerFactor(float aDopplerFactor);
-		// Set the coordinates for this audio source to be relative to listener's coordinates.
-		void set3dListenerRelative(bool aListenerRelative);
-		// Enable delaying the start of the sound based on the distance.
-		void set3dDistanceDelay(bool aDistanceDelay);
+	// CTor
+	AudioSource();
+	// Set default volume for instances
+	void setVolume(float aVolume);
+	// Set the looping of the instances created from this audio source
+	void setLooping(bool aLoop);
+	// Set whether only one instance of this sound should ever be playing at the same time
+	void setSingleInstance(bool aSingleInstance);
+	// Set whether audio should auto-stop when it ends or not
+	void setAutoStop(bool aAutoStop);
 
-		// Set a custom 3d audio collider. Set to NULL to disable.
-		void set3dCollider(AudioCollider *aCollider, int aUserData = 0);
-		// Set a custom attenuator. Set to NULL to disable.
-		void set3dAttenuator(AudioAttenuator *aAttenuator);
+	// Set the minimum and maximum distances for 3d audio source (closer to min distance = max vol)
+	void set3dMinMaxDistance(float aMinDistance, float aMaxDistance);
+	// Set attenuation model and rolloff factor for 3d audio source
+	void set3dAttenuation(unsigned int aAttenuationModel, float aAttenuationRolloffFactor);
+	// Set doppler factor to reduce or enhance doppler effect, default = 1.0
+	void set3dDopplerFactor(float aDopplerFactor);
+	// Set the coordinates for this audio source to be relative to listener's coordinates.
+	void set3dListenerRelative(bool aListenerRelative);
+	// Enable delaying the start of the sound based on the distance.
+	void set3dDistanceDelay(bool aDistanceDelay);
 
-		// Set behavior for inaudible sounds
-		void setInaudibleBehavior(bool aMustTick, bool aKill);
+	// Set a custom 3d audio collider. Set to NULL to disable.
+	void set3dCollider(AudioCollider *aCollider, int aUserData = 0);
+	// Set a custom attenuator. Set to NULL to disable.
+	void set3dAttenuator(AudioAttenuator *aAttenuator);
 
-		// Set time to jump to when looping
-		void setLoopPoint(time aLoopPoint);
-		// Get current loop point value
-		time getLoopPoint();
+	// Set behavior for inaudible sounds
+	void setInaudibleBehavior(bool aMustTick, bool aKill);
 
-		// Set filter. Set to NULL to clear the filter.
-		virtual void setFilter(unsigned int aFilterId, Filter *aFilter);
-		// DTor
-		virtual ~AudioSource();
-		// Create instance from the audio source. Called from within Soloud class.
-		virtual AudioSourceInstance *createInstance() = 0;
-		// Stop all instances of this audio source
-		void stop();
-	};
+	// Set time to jump to when looping
+	void setLoopPoint(time aLoopPoint);
+	// Get current loop point value
+	time getLoopPoint();
+
+	// Set filter. Set to NULL to clear the filter.
+	virtual void setFilter(unsigned int aFilterId, Filter *aFilter);
+	// DTor
+	virtual ~AudioSource();
+	// Create instance from the audio source. Called from within Soloud class.
+	virtual AudioSourceInstance *createInstance() = 0;
+	// Stop all instances of this audio source
+	void stop();
 };
+}; // namespace SoLoud
 
 #endif
diff --git a/src/core/soloud.cpp b/src/core/soloud.cpp
index ee0301e..4e58d72 100644
--- a/src/core/soloud.cpp
+++ b/src/core/soloud.cpp
@@ -22,14 +22,14 @@ freely, subject to the following restrictions:
    distribution.
 */
 
-#include <string.h>
-#include <stdlib.h>
-#include <math.h> // sin
 #include <float.h> // _controlfp
+#include <math.h>  // sin
+#include <stdlib.h>
+#include <string.h>
+
+#include "soloud_fft.h"
 #include "soloud_internal.h"
 #include "soloud_thread.h"
-#include "soloud_fft.h"
-
 
 #ifdef SOLOUD_SSE_INTRINSICS
 #include <xmmintrin.h>
@@ -38,920 +38,937 @@ freely, subject to the following restrictions:
 #endif
 #endif
 
-//#define FLOATING_POINT_DEBUG
+// #define FLOATING_POINT_DEBUG
 
-
-#if !defined(WITH_SDL2) && !defined(WITH_SDL1) && !defined(WITH_PORTAUDIO) && \
-   !defined(WITH_OPENAL) && !defined(WITH_XAUDIO2) && !defined(WITH_WINMM) && \
-   !defined(WITH_WASAPI) && !defined(WITH_OSS) && !defined(WITH_SDL1_STATIC) && \
-   !defined(WITH_SDL2_STATIC) && !defined(WITH_SDL3_STATIC) && !defined(WITH_ALSA) && !defined(WITH_OPENSLES) && \
-   !defined(WITH_NULL) && !defined(WITH_COREAUDIO) && !defined(WITH_VITA_HOMEBREW) &&\
-   !defined(WITH_JACK) && !defined(WITH_NOSOUND) && !defined(WITH_MINIAUDIO)
+#if !defined(WITH_SDL2) && !defined(WITH_SDL1) && !defined(WITH_PORTAUDIO) && !defined(WITH_OPENAL) && !defined(WITH_XAUDIO2) && !defined(WITH_WINMM) && \
+    !defined(WITH_WASAPI) && !defined(WITH_OSS) && !defined(WITH_SDL1_STATIC) && !defined(WITH_SDL2_STATIC) && !defined(WITH_SDL3_STATIC) && !defined(WITH_ALSA) && \
+    !defined(WITH_OPENSLES) && !defined(WITH_NULL) && !defined(WITH_COREAUDIO) && !defined(WITH_VITA_HOMEBREW) && !defined(WITH_JACK) && !defined(WITH_NOSOUND) && \
+    !defined(WITH_MINIAUDIO)
 #error It appears you haven't enabled any of the back-ends. Please #define one or more of the WITH_ defines (or use premake) '
 #endif
 
-
 namespace SoLoud
 {
-	AlignedFloatBuffer::AlignedFloatBuffer()
-	{
-		mBasePtr = 0;
-		mData = 0;
-		mFloats = 0;
-	}
+AlignedFloatBuffer::AlignedFloatBuffer()
+{
+	mBasePtr = 0;
+	mData = 0;
+	mFloats = 0;
+}
 
-	result AlignedFloatBuffer::init(unsigned int aFloats)
-	{
-		delete[] mBasePtr;
-		mBasePtr = 0;
-		mData = 0;
-		mFloats = aFloats;
+result AlignedFloatBuffer::init(unsigned int aFloats)
+{
+	delete[] mBasePtr;
+	mBasePtr = 0;
+	mData = 0;
+	mFloats = aFloats;
 #ifndef SOLOUD_SSE_INTRINSICS
-		mBasePtr = new unsigned char[aFloats * sizeof(float)];
-		if (mBasePtr == NULL)
-			return OUT_OF_MEMORY;
-		mData = (float*)mBasePtr;
+	mBasePtr = new unsigned char[aFloats * sizeof(float)];
+	if (mBasePtr == NULL)
+		return OUT_OF_MEMORY;
+	mData = (float *)mBasePtr;
 #else
-		mBasePtr = new unsigned char[aFloats * sizeof(float) + 16];
-		if (mBasePtr == NULL)
-			return OUT_OF_MEMORY;
-		mData = (float *)(((size_t)mBasePtr + 15)&~15);
+	mBasePtr = new unsigned char[aFloats * sizeof(float) + 16];
+	if (mBasePtr == NULL)
+		return OUT_OF_MEMORY;
+	mData = (float *)(((size_t)mBasePtr + 15) & ~15);
 #endif
-		return SO_NO_ERROR;
-	}
+	return SO_NO_ERROR;
+}
 
-	void AlignedFloatBuffer::clear()
-	{
-		memset(mData, 0, sizeof(float) * mFloats);
-	}
+void AlignedFloatBuffer::clear()
+{
+	memset(mData, 0, sizeof(float) * mFloats);
+}
 
-	AlignedFloatBuffer::~AlignedFloatBuffer()
+AlignedFloatBuffer::~AlignedFloatBuffer()
+{
+	delete[] mBasePtr;
+}
+
+TinyAlignedFloatBuffer::TinyAlignedFloatBuffer()
+{
+	unsigned char *basePtr = &mActualData[0];
+	mData = (float *)(((size_t)basePtr + 15) & ~15);
+}
+
+Soloud::Soloud()
+{
+#ifdef FLOATING_POINT_DEBUG
+	unsigned int u;
+	u = _controlfp(0, 0);
+	u = u & ~(_EM_INVALID | /*_EM_DENORMAL |*/ _EM_ZERODIVIDE | _EM_OVERFLOW /*| _EM_UNDERFLOW  | _EM_INEXACT*/);
+	_controlfp(u, _MCW_EM);
+#endif
+	mResampler = SOLOUD_DEFAULT_RESAMPLER;
+	mInsideAudioThreadMutex = false;
+	mScratchSize = 0;
+	mSamplerate = 0;
+	mBufferSize = 0;
+	mFlags = 0;
+	mGlobalVolume = 0;
+	mPlayIndex = 0;
+	mBackendData = NULL;
+	mAudioThreadMutex = NULL;
+	mPostClipScaler = 0;
+	mBackendCleanupFunc = NULL;
+	mBackendPauseFunc = NULL;
+	mBackendResumeFunc = NULL;
+	mChannels = 2;
+	mStreamTime = 0;
+	mLastClockedTime = 0;
+	mAudioSourceID = 1;
+	mBackendString = 0;
+	mBackendID = 0;
+	mActiveVoiceDirty = true;
+	mActiveVoiceCount = 0;
+	int i;
+	for (i = 0; i < VOICE_COUNT; i++)
+		mActiveVoice[i] = 0;
+	for (i = 0; i < FILTERS_PER_STREAM; i++)
 	{
-		delete[] mBasePtr;
+		mFilter[i] = NULL;
+		mFilterInstance[i] = NULL;
 	}
-
-	TinyAlignedFloatBuffer::TinyAlignedFloatBuffer()
+	for (i = 0; i < 256; i++)
 	{
-		unsigned char * basePtr = &mActualData[0];
-		mData = (float *)(((size_t)basePtr + 15)&~15);
+		mFFTData[i] = 0;
+		mVisualizationWaveData[i] = 0;
+		mWaveData[i] = 0;
 	}
-
-	Soloud::Soloud()
+	for (i = 0; i < MAX_CHANNELS; i++)
 	{
-#ifdef FLOATING_POINT_DEBUG
-		unsigned int u;
-		u = _controlfp(0, 0);
-		u = u & ~(_EM_INVALID | /*_EM_DENORMAL |*/ _EM_ZERODIVIDE | _EM_OVERFLOW /*| _EM_UNDERFLOW  | _EM_INEXACT*/);
-		_controlfp(u, _MCW_EM);
-#endif
-		mResampler = SOLOUD_DEFAULT_RESAMPLER;
-		mInsideAudioThreadMutex = false;
-		mScratchSize = 0;
-		mSamplerate = 0;
-		mBufferSize = 0;
-		mFlags = 0;
-		mGlobalVolume = 0;
-		mPlayIndex = 0;
-		mBackendData = NULL;
-		mAudioThreadMutex = NULL;
-		mPostClipScaler = 0;
-		mBackendCleanupFunc = NULL;
-		mBackendPauseFunc = NULL;
-		mBackendResumeFunc = NULL;
-		mChannels = 2;		
-		mStreamTime = 0;
-		mLastClockedTime = 0;
-		mAudioSourceID = 1;
-		mBackendString = 0;
-		mBackendID = 0;
-		mActiveVoiceDirty = true;
-		mActiveVoiceCount = 0;
-		int i;
-		for (i = 0; i < VOICE_COUNT; i++)
-			mActiveVoice[i] = 0;
-		for (i = 0; i < FILTERS_PER_STREAM; i++)
-		{
-			mFilter[i] = NULL;
-			mFilterInstance[i] = NULL;
-		}
-		for (i = 0; i < 256; i++)
-		{
-			mFFTData[i] = 0;
-			mVisualizationWaveData[i] = 0;
-			mWaveData[i] = 0;
-		}
-		for (i = 0; i < MAX_CHANNELS; i++)
-		{
-			mVisualizationChannelVolume[i] = 0;
-		}
-		for (i = 0; i < VOICE_COUNT; i++)
-		{
-			mVoice[i] = 0;
-		}
-		mVoiceGroup = 0;
-		mVoiceGroupCount = 0;
-
-		m3dPosition[0] = 0;
-		m3dPosition[1] = 0;
-		m3dPosition[2] = 0;
-		m3dAt[0] = 0;
-		m3dAt[1] = 0;
-		m3dAt[2] = -1;
-		m3dUp[0] = 0;
-		m3dUp[1] = 1;
-		m3dUp[2] = 0;		
-		m3dVelocity[0] = 0;
-		m3dVelocity[1] = 0;
-		m3dVelocity[2] = 0;		
-		m3dSoundSpeed = 343.3f;
-		mMaxActiveVoices = 16;
-		mHighestVoice = 0;
-		mResampleData = NULL;
-		mResampleDataOwner = NULL;
-		for (i = 0; i < 3 * MAX_CHANNELS; i++)
-			m3dSpeakerPosition[i] = 0;
+		mVisualizationChannelVolume[i] = 0;
 	}
-
-	Soloud::~Soloud()
+	for (i = 0; i < VOICE_COUNT; i++)
 	{
-		// let's stop all sounds before deinit, so we don't mess up our mutexes
-		stopAll();
-		deinit();
-		unsigned int i;
-		for (i = 0; i < FILTERS_PER_STREAM; i++)
-		{
-			delete mFilterInstance[i];
-		}
-		for (i = 0; i < mVoiceGroupCount; i++)
-			delete[] mVoiceGroup[i];
-		delete[] mVoiceGroup;
+		mVoice[i] = 0;
 	}
+	mVoiceGroup = 0;
+	mVoiceGroupCount = 0;
+
+	m3dPosition[0] = 0;
+	m3dPosition[1] = 0;
+	m3dPosition[2] = 0;
+	m3dAt[0] = 0;
+	m3dAt[1] = 0;
+	m3dAt[2] = -1;
+	m3dUp[0] = 0;
+	m3dUp[1] = 1;
+	m3dUp[2] = 0;
+	m3dVelocity[0] = 0;
+	m3dVelocity[1] = 0;
+	m3dVelocity[2] = 0;
+	m3dSoundSpeed = 343.3f;
+	mMaxActiveVoices = 16;
+	mHighestVoice = 0;
+	mResampleData = NULL;
+	mResampleDataOwner = NULL;
+	for (i = 0; i < 3 * MAX_CHANNELS; i++)
+		m3dSpeakerPosition[i] = 0;
+}
 
-	void Soloud::deinit()
+Soloud::~Soloud()
+{
+	// let's stop all sounds before deinit, so we don't mess up our mutexes
+	stopAll();
+	deinit();
+	unsigned int i;
+	for (i = 0; i < FILTERS_PER_STREAM; i++)
 	{
-		// Make sure no audio operation is currently pending
-		lockAudioMutex_internal();
-		unlockAudioMutex_internal();
-		SOLOUD_ASSERT(!mInsideAudioThreadMutex);
-		stopAll();
-		if (mBackendCleanupFunc)
-			mBackendCleanupFunc(this);
-		mBackendCleanupFunc = 0;
-		if (mAudioThreadMutex)
-			Thread::destroyMutex(mAudioThreadMutex);
-		mAudioThreadMutex = NULL;
-
-		delete[] mResampleData;
-		mResampleData = NULL;
-		delete[] mResampleDataOwner;
-		mResampleDataOwner = NULL;
+		delete mFilterInstance[i];
 	}
+	for (i = 0; i < mVoiceGroupCount; i++)
+		delete[] mVoiceGroup[i];
+	delete[] mVoiceGroup;
+}
 
-	result Soloud::init(unsigned int aFlags, unsigned int aBackend, unsigned int aSamplerate, unsigned int aBufferSize, unsigned int aChannels)
-	{		
-		if (aBackend >= BACKEND_MAX || aChannels == 3 || aChannels == 5 || aChannels == 7 || aChannels > MAX_CHANNELS)
-			return INVALID_PARAMETER;
+void Soloud::deinit()
+{
+	// Make sure no audio operation is currently pending
+	lockAudioMutex_internal();
+	unlockAudioMutex_internal();
+	SOLOUD_ASSERT(!mInsideAudioThreadMutex);
+	stopAll();
+	if (mBackendCleanupFunc)
+		mBackendCleanupFunc(this);
+	mBackendCleanupFunc = 0;
+	if (mAudioThreadMutex)
+		Thread::destroyMutex(mAudioThreadMutex);
+	mAudioThreadMutex = NULL;
+
+	delete[] mResampleData;
+	mResampleData = NULL;
+	delete[] mResampleDataOwner;
+	mResampleDataOwner = NULL;
+}
 
-		deinit();
+result Soloud::init(unsigned int aFlags, unsigned int aBackend, unsigned int aSamplerate, unsigned int aBufferSize, unsigned int aChannels)
+{
+	if (aBackend >= BACKEND_MAX || aChannels == 3 || aChannels == 5 || aChannels == 7 || aChannels > MAX_CHANNELS)
+		return INVALID_PARAMETER;
 
-		mAudioThreadMutex = Thread::createMutex();
+	deinit();
 
-		mBackendID = 0;
-		mBackendString = 0;
+	mAudioThreadMutex = Thread::createMutex();
 
-		int samplerate = 44100;
-		int buffersize = 2048;
-		int inited = 0;
+	mBackendID = 0;
+	mBackendString = 0;
 
-		if (aSamplerate != Soloud::AUTO) samplerate = aSamplerate;
-		if (aBufferSize != Soloud::AUTO) buffersize = aBufferSize;
+	int samplerate = 44100;
+	int buffersize = 2048;
+	int inited = 0;
 
-#if defined(WITH_SDL1_STATIC)
-		if (!inited &&
-			(aBackend == Soloud::SDL1 || 
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
+	if (aSamplerate != Soloud::AUTO)
+		samplerate = aSamplerate;
+	if (aBufferSize != Soloud::AUTO)
+		buffersize = aBufferSize;
 
-			int ret = sdl1static_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::SDL1;
-			}
+#if defined(WITH_SDL1_STATIC)
+	if (!inited && (aBackend == Soloud::SDL1 || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = sdl1static_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::SDL1;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_SDL2_STATIC)
-		if (!inited &&
-			(aBackend == Soloud::SDL2 ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = sdl2static_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::SDL2;
-			}
+	if (!inited && (aBackend == Soloud::SDL2 || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;
+		int ret = sdl2static_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::SDL2;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_SDL3_STATIC)
-		if (!inited &&
-			(aBackend == Soloud::SDL3 ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = sdl3static_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::SDL3;
-			}
+	if (!inited && (aBackend == Soloud::SDL3 || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;
+		int ret = sdl3static_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::SDL3;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_SDL2)
-		if (!inited &&
-			(aBackend == Soloud::SDL2 ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = sdl2_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::SDL2;
-			}
+	if (!inited && (aBackend == Soloud::SDL2 || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;
+		int ret = sdl2_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::SDL2;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_SDL1)
-		if (!inited &&
-			(aBackend == Soloud::SDL1 || 
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = sdl1_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::SDL1;
-			}
+	if (!inited && (aBackend == Soloud::SDL1 || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = sdl1_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::SDL1;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_MINIAUDIO)
-		if (!inited &&
-			(aBackend == Soloud::MINIAUDIO ||
-				aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = miniaudio_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::MINIAUDIO;
-			}
+	if (!inited && (aBackend == Soloud::MINIAUDIO || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;
+		int ret = miniaudio_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::MINIAUDIO;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_PORTAUDIO)
-		if (!inited &&
-			(aBackend == Soloud::PORTAUDIO ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = portaudio_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::PORTAUDIO;
-			}
+	if (!inited && (aBackend == Soloud::PORTAUDIO || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = portaudio_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::PORTAUDIO;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_XAUDIO2)
-		if (!inited &&
-			(aBackend == Soloud::XAUDIO2 ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 4096;
-
-			int ret = xaudio2_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::XAUDIO2;
-			}
+	if (!inited && (aBackend == Soloud::XAUDIO2 || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 4096;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = xaudio2_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::XAUDIO2;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_WINMM)
-		if (!inited &&
-			(aBackend == Soloud::WINMM ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 4096;
-
-			int ret = winmm_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::WINMM;
-			}
+	if (!inited && (aBackend == Soloud::WINMM || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 4096;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = winmm_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::WINMM;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_WASAPI)
-		if (!inited &&
-			(aBackend == Soloud::WASAPI ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 4096;
-			if (aSamplerate == Soloud::AUTO) samplerate = 48000;
-
-			int ret = wasapi_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::WASAPI;
-			}
+	if (!inited && (aBackend == Soloud::WASAPI || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 4096;
+		if (aSamplerate == Soloud::AUTO)
+			samplerate = 48000;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = wasapi_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::WASAPI;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_ALSA)
-		if (!inited &&
-			(aBackend == Soloud::ALSA ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = alsa_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::ALSA;
-			}
+	if (!inited && (aBackend == Soloud::ALSA || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = alsa_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::ALSA;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_JACK)
-		if (!inited &&
-			(aBackend == Soloud::JACK ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = jack_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::JACK;
-			}
+	if (!inited && (aBackend == Soloud::JACK || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = jack_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::JACK;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_OSS)
-		if (!inited &&
-			(aBackend == Soloud::OSS ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = oss_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::OSS;
-			}
+	if (!inited && (aBackend == Soloud::OSS || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = oss_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::OSS;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_OPENAL)
-		if (!inited &&
-			(aBackend == Soloud::OPENAL ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 4096;
-
-			int ret = openal_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::OPENAL;
-			}
+	if (!inited && (aBackend == Soloud::OPENAL || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 4096;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = openal_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::OPENAL;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_COREAUDIO)
-		if (!inited &&
-			(aBackend == Soloud::COREAUDIO ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = coreaudio_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::COREAUDIO;
-			}
+	if (!inited && (aBackend == Soloud::COREAUDIO || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = coreaudio_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::COREAUDIO;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_OPENSLES)
-		if (!inited &&
-			(aBackend == Soloud::OPENSLES ||
-			aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 4096;
-
-			int ret = opensles_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::OPENSLES;
-			}
+	if (!inited && (aBackend == Soloud::OPENSLES || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 4096;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+		int ret = opensles_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::OPENSLES;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_VITA_HOMEBREW)
-		if (!inited &&
-			(aBackend == Soloud::VITA_HOMEBREW || 
-			aBackend == Soloud::AUTO))
+	if (!inited && (aBackend == Soloud::VITA_HOMEBREW || aBackend == Soloud::AUTO))
+	{
+		int ret = vita_homebrew_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
 		{
-			int ret = vita_homebrew_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::VITA_HOMEBREW;
-			}
-
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;			
+			inited = 1;
+			mBackendID = Soloud::VITA_HOMEBREW;
 		}
+
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
 #endif
 
 #if defined(WITH_NOSOUND)
-		if (!inited &&
-			(aBackend == Soloud::NOSOUND ||
-				aBackend == Soloud::AUTO))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = nosound_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::NOSOUND;
-			}
+	if (!inited && (aBackend == Soloud::NOSOUND || aBackend == Soloud::AUTO))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0 && aBackend != Soloud::AUTO)
-				return ret;
+		int ret = nosound_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::NOSOUND;
 		}
-#endif
 
+		if (ret != 0 && aBackend != Soloud::AUTO)
+			return ret;
+	}
+#endif
 
 #if defined(WITH_NULL)
-		if (!inited &&
-			(aBackend == Soloud::NULLDRIVER))
-		{
-			if (aBufferSize == Soloud::AUTO) buffersize = 2048;
-
-			int ret = null_init(this, aFlags, samplerate, buffersize, aChannels);
-			if (ret == 0)
-			{
-				inited = 1;
-				mBackendID = Soloud::NULLDRIVER;
-			}
+	if (!inited && (aBackend == Soloud::NULLDRIVER))
+	{
+		if (aBufferSize == Soloud::AUTO)
+			buffersize = 2048;
 
-			if (ret != 0)
-				return ret;			
+		int ret = null_init(this, aFlags, samplerate, buffersize, aChannels);
+		if (ret == 0)
+		{
+			inited = 1;
+			mBackendID = Soloud::NULLDRIVER;
 		}
-#endif
 
-		if (!inited && aBackend != Soloud::AUTO)
-			return NOT_IMPLEMENTED;
-		if (!inited)
-			return UNKNOWN_ERROR;
-		return 0;
+		if (ret != 0)
+			return ret;
 	}
+#endif
 
-	result Soloud::pause()
-	{
-		if (mBackendPauseFunc)
-			return mBackendPauseFunc(this);
-
+	if (!inited && aBackend != Soloud::AUTO)
 		return NOT_IMPLEMENTED;
-	}
+	if (!inited)
+		return UNKNOWN_ERROR;
+	return 0;
+}
 
-	result Soloud::resume()
-	{
-		if (mBackendResumeFunc)
-			return mBackendResumeFunc(this);
+result Soloud::pause()
+{
+	if (mBackendPauseFunc)
+		return mBackendPauseFunc(this);
 
-		return NOT_IMPLEMENTED;
-	}
+	return NOT_IMPLEMENTED;
+}
 
+result Soloud::resume()
+{
+	if (mBackendResumeFunc)
+		return mBackendResumeFunc(this);
 
-	void Soloud::postinit_internal(unsigned int aSamplerate, unsigned int aBufferSize, unsigned int aFlags, unsigned int aChannels)
-	{		
-		mGlobalVolume = 1;
-		mChannels = aChannels;
-		mSamplerate = aSamplerate;
-		mBufferSize = aBufferSize;
-		mScratchSize = (aBufferSize + 15) & (~0xf); // round to the next div by 16
-		if (mScratchSize < SAMPLE_GRANULARITY * 2) mScratchSize = SAMPLE_GRANULARITY * 2;
-		if (mScratchSize < 4096) mScratchSize = 4096;
-		mScratch.init(mScratchSize * MAX_CHANNELS);
-		mOutputScratch.init(mScratchSize * MAX_CHANNELS);
-		mResampleData = new float*[mMaxActiveVoices * 2];
-		mResampleDataOwner = new AudioSourceInstance*[mMaxActiveVoices];
-		mResampleDataBuffer.init(mMaxActiveVoices * 2 * SAMPLE_GRANULARITY * MAX_CHANNELS);
-		unsigned int i;		
-		for (i = 0; i < mMaxActiveVoices * 2; i++)
-			mResampleData[i] = mResampleDataBuffer.mData + (SAMPLE_GRANULARITY * MAX_CHANNELS * i);
-		for (i = 0; i < mMaxActiveVoices; i++)
-			mResampleDataOwner[i] = NULL;
-		mFlags = aFlags;
-		mPostClipScaler = 0.95f;
-		switch (mChannels)
-		{
-		case 1:
-			m3dSpeakerPosition[0 * 3 + 0] = 0;
-			m3dSpeakerPosition[0 * 3 + 1] = 0;
-			m3dSpeakerPosition[0 * 3 + 2] = 1;
-			break;
-		case 2:
-			m3dSpeakerPosition[0 * 3 + 0] = 2;
-			m3dSpeakerPosition[0 * 3 + 1] = 0;
-			m3dSpeakerPosition[0 * 3 + 2] = 1;
-			m3dSpeakerPosition[1 * 3 + 0] = -2;
-			m3dSpeakerPosition[1 * 3 + 1] = 0;
-			m3dSpeakerPosition[1 * 3 + 2] = 1;
-			break;
-		case 4:
-			m3dSpeakerPosition[0 * 3 + 0] = 2;
-			m3dSpeakerPosition[0 * 3 + 1] = 0;
-			m3dSpeakerPosition[0 * 3 + 2] = 1;
-			m3dSpeakerPosition[1 * 3 + 0] = -2;
-			m3dSpeakerPosition[1 * 3 + 1] = 0;
-			m3dSpeakerPosition[1 * 3 + 2] = 1;
-			// I suppose technically the second pair should be straight left & right,
-			// but I prefer moving them a bit back to mirror the front speakers.
-			m3dSpeakerPosition[2 * 3 + 0] = 2;
-			m3dSpeakerPosition[2 * 3 + 1] = 0;
-			m3dSpeakerPosition[2 * 3 + 2] = -1;
-			m3dSpeakerPosition[3 * 3 + 0] = -2;
-			m3dSpeakerPosition[3 * 3 + 1] = 0;
-			m3dSpeakerPosition[3 * 3 + 2] = -1;
-			break;
-		case 6:
-			m3dSpeakerPosition[0 * 3 + 0] = 2;
-			m3dSpeakerPosition[0 * 3 + 1] = 0;
-			m3dSpeakerPosition[0 * 3 + 2] = 1;
-			m3dSpeakerPosition[1 * 3 + 0] = -2;
-			m3dSpeakerPosition[1 * 3 + 1] = 0;
-			m3dSpeakerPosition[1 * 3 + 2] = 1;
-
-			// center and subwoofer. 
-			m3dSpeakerPosition[2 * 3 + 0] = 0;
-			m3dSpeakerPosition[2 * 3 + 1] = 0;
-			m3dSpeakerPosition[2 * 3 + 2] = 1;
-			// Sub should be "mix of everything". We'll handle it as a special case and make it a null vector.
-			m3dSpeakerPosition[3 * 3 + 0] = 0;
-			m3dSpeakerPosition[3 * 3 + 1] = 0;
-			m3dSpeakerPosition[3 * 3 + 2] = 0;
-
-			// I suppose technically the second pair should be straight left & right,
-			// but I prefer moving them a bit back to mirror the front speakers.
-			m3dSpeakerPosition[4 * 3 + 0] = 2;
-			m3dSpeakerPosition[4 * 3 + 1] = 0;
-			m3dSpeakerPosition[4 * 3 + 2] = -1;
-			m3dSpeakerPosition[5 * 3 + 0] = -2;
-			m3dSpeakerPosition[5 * 3 + 1] = 0;
-			m3dSpeakerPosition[5 * 3 + 2] = -1;
-			break;
-		case 8:
-			m3dSpeakerPosition[0 * 3 + 0] = 2;
-			m3dSpeakerPosition[0 * 3 + 1] = 0;
-			m3dSpeakerPosition[0 * 3 + 2] = 1;
-			m3dSpeakerPosition[1 * 3 + 0] = -2;
-			m3dSpeakerPosition[1 * 3 + 1] = 0;
-			m3dSpeakerPosition[1 * 3 + 2] = 1;
-
-			// center and subwoofer. 
-			m3dSpeakerPosition[2 * 3 + 0] = 0;
-			m3dSpeakerPosition[2 * 3 + 1] = 0;
-			m3dSpeakerPosition[2 * 3 + 2] = 1;
-			// Sub should be "mix of everything". We'll handle it as a special case and make it a null vector.
-			m3dSpeakerPosition[3 * 3 + 0] = 0;
-			m3dSpeakerPosition[3 * 3 + 1] = 0;
-			m3dSpeakerPosition[3 * 3 + 2] = 0;
-
-			// side
-			m3dSpeakerPosition[4 * 3 + 0] = 2;
-			m3dSpeakerPosition[4 * 3 + 1] = 0;
-			m3dSpeakerPosition[4 * 3 + 2] = 0;
-			m3dSpeakerPosition[5 * 3 + 0] = -2;
-			m3dSpeakerPosition[5 * 3 + 1] = 0;
-			m3dSpeakerPosition[5 * 3 + 2] = 0;
-
-			// back
-			m3dSpeakerPosition[6 * 3 + 0] = 2;
-			m3dSpeakerPosition[6 * 3 + 1] = 0;
-			m3dSpeakerPosition[6 * 3 + 2] = -1;
-			m3dSpeakerPosition[7 * 3 + 0] = -2;
-			m3dSpeakerPosition[7 * 3 + 1] = 0;
-			m3dSpeakerPosition[7 * 3 + 2] = -1;
-			break;
-		}
+	return NOT_IMPLEMENTED;
+}
+
+void Soloud::postinit_internal(unsigned int aSamplerate, unsigned int aBufferSize, unsigned int aFlags, unsigned int aChannels)
+{
+	mGlobalVolume = 1;
+	mChannels = aChannels;
+	mSamplerate = aSamplerate;
+	mBufferSize = aBufferSize;
+	mScratchSize = (aBufferSize + 15) & (~0xf); // round to the next div by 16
+	if (mScratchSize < SAMPLE_GRANULARITY * 2)
+		mScratchSize = SAMPLE_GRANULARITY * 2;
+	if (mScratchSize < 4096)
+		mScratchSize = 4096;
+	mScratch.init(mScratchSize * MAX_CHANNELS);
+	mOutputScratch.init(mScratchSize * MAX_CHANNELS);
+	mResampleData = new float *[mMaxActiveVoices * 2];
+	mResampleDataOwner = new AudioSourceInstance *[mMaxActiveVoices];
+	mResampleDataBuffer.init(mMaxActiveVoices * 2 * SAMPLE_GRANULARITY * MAX_CHANNELS);
+	unsigned int i;
+	for (i = 0; i < mMaxActiveVoices * 2; i++)
+		mResampleData[i] = mResampleDataBuffer.mData + (SAMPLE_GRANULARITY * MAX_CHANNELS * i);
+	for (i = 0; i < mMaxActiveVoices; i++)
+		mResampleDataOwner[i] = NULL;
+	mFlags = aFlags;
+	mPostClipScaler = 0.95f;
+	switch (mChannels)
+	{
+	case 1:
+		m3dSpeakerPosition[0 * 3 + 0] = 0;
+		m3dSpeakerPosition[0 * 3 + 1] = 0;
+		m3dSpeakerPosition[0 * 3 + 2] = 1;
+		break;
+	case 2:
+		m3dSpeakerPosition[0 * 3 + 0] = 2;
+		m3dSpeakerPosition[0 * 3 + 1] = 0;
+		m3dSpeakerPosition[0 * 3 + 2] = 1;
+		m3dSpeakerPosition[1 * 3 + 0] = -2;
+		m3dSpeakerPosition[1 * 3 + 1] = 0;
+		m3dSpeakerPosition[1 * 3 + 2] = 1;
+		break;
+	case 4:
+		m3dSpeakerPosition[0 * 3 + 0] = 2;
+		m3dSpeakerPosition[0 * 3 + 1] = 0;
+		m3dSpeakerPosition[0 * 3 + 2] = 1;
+		m3dSpeakerPosition[1 * 3 + 0] = -2;
+		m3dSpeakerPosition[1 * 3 + 1] = 0;
+		m3dSpeakerPosition[1 * 3 + 2] = 1;
+		// I suppose technically the second pair should be straight left & right,
+		// but I prefer moving them a bit back to mirror the front speakers.
+		m3dSpeakerPosition[2 * 3 + 0] = 2;
+		m3dSpeakerPosition[2 * 3 + 1] = 0;
+		m3dSpeakerPosition[2 * 3 + 2] = -1;
+		m3dSpeakerPosition[3 * 3 + 0] = -2;
+		m3dSpeakerPosition[3 * 3 + 1] = 0;
+		m3dSpeakerPosition[3 * 3 + 2] = -1;
+		break;
+	case 6:
+		m3dSpeakerPosition[0 * 3 + 0] = 2;
+		m3dSpeakerPosition[0 * 3 + 1] = 0;
+		m3dSpeakerPosition[0 * 3 + 2] = 1;
+		m3dSpeakerPosition[1 * 3 + 0] = -2;
+		m3dSpeakerPosition[1 * 3 + 1] = 0;
+		m3dSpeakerPosition[1 * 3 + 2] = 1;
+
+		// center and subwoofer.
+		m3dSpeakerPosition[2 * 3 + 0] = 0;
+		m3dSpeakerPosition[2 * 3 + 1] = 0;
+		m3dSpeakerPosition[2 * 3 + 2] = 1;
+		// Sub should be "mix of everything". We'll handle it as a special case and make it a null vector.
+		m3dSpeakerPosition[3 * 3 + 0] = 0;
+		m3dSpeakerPosition[3 * 3 + 1] = 0;
+		m3dSpeakerPosition[3 * 3 + 2] = 0;
+
+		// I suppose technically the second pair should be straight left & right,
+		// but I prefer moving them a bit back to mirror the front speakers.
+		m3dSpeakerPosition[4 * 3 + 0] = 2;
+		m3dSpeakerPosition[4 * 3 + 1] = 0;
+		m3dSpeakerPosition[4 * 3 + 2] = -1;
+		m3dSpeakerPosition[5 * 3 + 0] = -2;
+		m3dSpeakerPosition[5 * 3 + 1] = 0;
+		m3dSpeakerPosition[5 * 3 + 2] = -1;
+		break;
+	case 8:
+		m3dSpeakerPosition[0 * 3 + 0] = 2;
+		m3dSpeakerPosition[0 * 3 + 1] = 0;
+		m3dSpeakerPosition[0 * 3 + 2] = 1;
+		m3dSpeakerPosition[1 * 3 + 0] = -2;
+		m3dSpeakerPosition[1 * 3 + 1] = 0;
+		m3dSpeakerPosition[1 * 3 + 2] = 1;
+
+		// center and subwoofer.
+		m3dSpeakerPosition[2 * 3 + 0] = 0;
+		m3dSpeakerPosition[2 * 3 + 1] = 0;
+		m3dSpeakerPosition[2 * 3 + 2] = 1;
+		// Sub should be "mix of everything". We'll handle it as a special case and make it a null vector.
+		m3dSpeakerPosition[3 * 3 + 0] = 0;
+		m3dSpeakerPosition[3 * 3 + 1] = 0;
+		m3dSpeakerPosition[3 * 3 + 2] = 0;
+
+		// side
+		m3dSpeakerPosition[4 * 3 + 0] = 2;
+		m3dSpeakerPosition[4 * 3 + 1] = 0;
+		m3dSpeakerPosition[4 * 3 + 2] = 0;
+		m3dSpeakerPosition[5 * 3 + 0] = -2;
+		m3dSpeakerPosition[5 * 3 + 1] = 0;
+		m3dSpeakerPosition[5 * 3 + 2] = 0;
+
+		// back
+		m3dSpeakerPosition[6 * 3 + 0] = 2;
+		m3dSpeakerPosition[6 * 3 + 1] = 0;
+		m3dSpeakerPosition[6 * 3 + 2] = -1;
+		m3dSpeakerPosition[7 * 3 + 0] = -2;
+		m3dSpeakerPosition[7 * 3 + 1] = 0;
+		m3dSpeakerPosition[7 * 3 + 2] = -1;
+		break;
 	}
+}
 
-	const char * Soloud::getErrorString(result aErrorCode) const
+const char *Soloud::getErrorString(result aErrorCode) const
+{
+	switch (aErrorCode)
 	{
-		switch (aErrorCode)
-		{
-		case SO_NO_ERROR: return "No error";
-		case INVALID_PARAMETER: return "Some parameter is invalid";
-		case FILE_NOT_FOUND: return "File not found";
-		case FILE_LOAD_FAILED: return "File found, but could not be loaded";
-		case DLL_NOT_FOUND: return "DLL not found, or wrong DLL";
-		case OUT_OF_MEMORY: return "Out of memory";
-		case NOT_IMPLEMENTED: return "Feature not implemented";
+	case SO_NO_ERROR:
+		return "No error";
+	case INVALID_PARAMETER:
+		return "Some parameter is invalid";
+	case FILE_NOT_FOUND:
+		return "File not found";
+	case FILE_LOAD_FAILED:
+		return "File found, but could not be loaded";
+	case DLL_NOT_FOUND:
+		return "DLL not found, or wrong DLL";
+	case OUT_OF_MEMORY:
+		return "Out of memory";
+	case NOT_IMPLEMENTED:
+		return "Feature not implemented";
 		/*case UNKNOWN_ERROR: return "Other error";*/
-		}
-		return "Other error";
 	}
+	return "Other error";
+}
 
+float *Soloud::getWave()
+{
+	int i;
+	lockAudioMutex_internal();
+	for (i = 0; i < 256; i++)
+		mWaveData[i] = mVisualizationWaveData[i];
+	unlockAudioMutex_internal();
+	return mWaveData;
+}
 
-	float * Soloud::getWave()
-	{
-		int i;
-		lockAudioMutex_internal();
-		for (i = 0; i < 256; i++)
-			mWaveData[i] = mVisualizationWaveData[i];
-		unlockAudioMutex_internal();
-		return mWaveData;
-	}
+float Soloud::getApproximateVolume(unsigned int aChannel)
+{
+	if (aChannel > mChannels)
+		return 0;
+	float vol = 0;
+	lockAudioMutex_internal();
+	vol = mVisualizationChannelVolume[aChannel];
+	unlockAudioMutex_internal();
+	return vol;
+}
 
-	float Soloud::getApproximateVolume(unsigned int aChannel)
+float *Soloud::calcFFT()
+{
+	lockAudioMutex_internal();
+	float temp[1024];
+	int i;
+	for (i = 0; i < 256; i++)
 	{
-		if (aChannel > mChannels)
-			return 0;
-		float vol = 0;
-		lockAudioMutex_internal();
-		vol = mVisualizationChannelVolume[aChannel];
-		unlockAudioMutex_internal();
-		return vol;
+		temp[i * 2] = mVisualizationWaveData[i];
+		temp[i * 2 + 1] = 0;
+		temp[i + 512] = 0;
+		temp[i + 768] = 0;
 	}
+	unlockAudioMutex_internal();
 
+	SoLoud::FFT::fft1024(temp);
 
-	float * Soloud::calcFFT()
+	for (i = 0; i < 256; i++)
 	{
-		lockAudioMutex_internal();
-		float temp[1024];
-		int i;
-		for (i = 0; i < 256; i++)
-		{
-			temp[i*2] = mVisualizationWaveData[i];
-			temp[i*2+1] = 0;
-			temp[i+512] = 0;
-			temp[i+768] = 0;
-		}
-		unlockAudioMutex_internal();
-
-		SoLoud::FFT::fft1024(temp);
-
-		for (i = 0; i < 256; i++)
-		{
-			float real = temp[i * 2];
-			float imag = temp[i * 2 + 1];
-			mFFTData[i] = (float)sqrt(real*real+imag*imag);
-		}
-
-		return mFFTData;
+		float real = temp[i * 2];
+		float imag = temp[i * 2 + 1];
+		mFFTData[i] = (float)sqrt(real * real + imag * imag);
 	}
 
+	return mFFTData;
+}
+
 #if defined(SOLOUD_SSE_INTRINSICS)
-	void Soloud::clip_internal(AlignedFloatBuffer &aBuffer, AlignedFloatBuffer &aDestBuffer, unsigned int aSamples, float aVolume0, float aVolume1)
-	{
-		float vd = (aVolume1 - aVolume0) / aSamples;
-		float v = aVolume0;
-		unsigned int i, j, c, d;
-		unsigned int samplequads = (aSamples + 3) / 4; // rounded up
+void Soloud::clip_internal(AlignedFloatBuffer &aBuffer, AlignedFloatBuffer &aDestBuffer, unsigned int aSamples, float aVolume0, float aVolume1)
+{
+	float vd = (aVolume1 - aVolume0) / aSamples;
+	float v = aVolume0;
+	unsigned int i, j, c, d;
+	unsigned int samplequads = (aSamples + 3) / 4; // rounded up
 
-		// Clip
-		if (mFlags & CLIP_ROUNDOFF)
+	// Clip
+	if (mFlags & CLIP_ROUNDOFF)
+	{
+		float nb = -1.65f;
+		__m128 negbound = _mm_load_ps1(&nb);
+		float pb = 1.65f;
+		__m128 posbound = _mm_load_ps1(&pb);
+		float ls = 0.87f;
+		__m128 linearscale = _mm_load_ps1(&ls);
+		float cs = -0.1f;
+		__m128 cubicscale = _mm_load_ps1(&cs);
+		float nw = -0.9862875f;
+		__m128 negwall = _mm_load_ps1(&nw);
+		float pw = 0.9862875f;
+		__m128 poswall = _mm_load_ps1(&pw);
+		__m128 postscale = _mm_load_ps1(&mPostClipScaler);
+		TinyAlignedFloatBuffer volumes;
+		volumes.mData[0] = v;
+		volumes.mData[1] = v + vd;
+		volumes.mData[2] = v + vd + vd;
+		volumes.mData[3] = v + vd + vd + vd;
+		vd *= 4;
+		__m128 vdelta = _mm_load_ps1(&vd);
+		c = 0;
+		d = 0;
+		for (j = 0; j < mChannels; j++)
 		{
-			float nb = -1.65f;		__m128 negbound = _mm_load_ps1(&nb);
-			float pb = 1.65f;		__m128 posbound = _mm_load_ps1(&pb);
-			float ls = 0.87f;		__m128 linearscale = _mm_load_ps1(&ls);
-			float cs = -0.1f;		__m128 cubicscale = _mm_load_ps1(&cs);
-			float nw = -0.9862875f;	__m128 negwall = _mm_load_ps1(&nw);
-			float pw = 0.9862875f;	__m128 poswall = _mm_load_ps1(&pw);
-			__m128 postscale = _mm_load_ps1(&mPostClipScaler);
-			TinyAlignedFloatBuffer volumes;
-			volumes.mData[0] = v;
-			volumes.mData[1] = v + vd;
-			volumes.mData[2] = v + vd + vd;
-			volumes.mData[3] = v + vd + vd + vd;
-			vd *= 4;
-			__m128 vdelta = _mm_load_ps1(&vd);
-			c = 0;
-			d = 0;
-			for (j = 0; j < mChannels; j++)
-			{
-				__m128 vol = _mm_load_ps(volumes.mData);
+			__m128 vol = _mm_load_ps(volumes.mData);
 
-				for (i = 0; i < samplequads; i++)
-				{
-					//float f1 = origdata[c] * v;	c++; v += vd;
-					__m128 f = _mm_load_ps(&aBuffer.mData[c]);
-					c += 4;
-					f = _mm_mul_ps(f, vol);
-					vol = _mm_add_ps(vol, vdelta);
-
-					//float u1 = (f1 > -1.65f);
-					__m128 u = _mm_cmpgt_ps(f, negbound);
-
-					//float o1 = (f1 < 1.65f);
-					__m128 o = _mm_cmplt_ps(f, posbound);
-
-					//f1 = (0.87f * f1 - 0.1f * f1 * f1 * f1) * u1 * o1;
-					__m128 lin = _mm_mul_ps(f, linearscale);
-					__m128 cubic = _mm_mul_ps(f, f);
-					cubic = _mm_mul_ps(cubic, f);
-					cubic = _mm_mul_ps(cubic, cubicscale);
-					f = _mm_add_ps(cubic, lin);
-
-					//f1 = f1 * u1 + !u1 * -0.9862875f;
-					__m128 lowmask = _mm_andnot_ps(u, negwall);
-					__m128 ilowmask = _mm_and_ps(u, f);
-					f = _mm_add_ps(lowmask, ilowmask);
-
-					//f1 = f1 * o1 + !o1 * 0.9862875f;
-					__m128 himask = _mm_andnot_ps(o, poswall);
-					__m128 ihimask = _mm_and_ps(o, f);
-					f = _mm_add_ps(himask, ihimask);
-
-					// outdata[d] = f1 * postclip; d++;
-					f = _mm_mul_ps(f, postscale);
-					_mm_store_ps(&aDestBuffer.mData[d], f);
-					d += 4;
-				}
+			for (i = 0; i < samplequads; i++)
+			{
+				// float f1 = origdata[c] * v;	c++; v += vd;
+				__m128 f = _mm_load_ps(&aBuffer.mData[c]);
+				c += 4;
+				f = _mm_mul_ps(f, vol);
+				vol = _mm_add_ps(vol, vdelta);
+
+				// float u1 = (f1 > -1.65f);
+				__m128 u = _mm_cmpgt_ps(f, negbound);
+
+				// float o1 = (f1 < 1.65f);
+				__m128 o = _mm_cmplt_ps(f, posbound);
+
+				// f1 = (0.87f * f1 - 0.1f * f1 * f1 * f1) * u1 * o1;
+				__m128 lin = _mm_mul_ps(f, linearscale);
+				__m128 cubic = _mm_mul_ps(f, f);
+				cubic = _mm_mul_ps(cubic, f);
+				cubic = _mm_mul_ps(cubic, cubicscale);
+				f = _mm_add_ps(cubic, lin);
+
+				// f1 = f1 * u1 + !u1 * -0.9862875f;
+				__m128 lowmask = _mm_andnot_ps(u, negwall);
+				__m128 ilowmask = _mm_and_ps(u, f);
+				f = _mm_add_ps(lowmask, ilowmask);
+
+				// f1 = f1 * o1 + !o1 * 0.9862875f;
+				__m128 himask = _mm_andnot_ps(o, poswall);
+				__m128 ihimask = _mm_and_ps(o, f);
+				f = _mm_add_ps(himask, ihimask);
+
+				// outdata[d] = f1 * postclip; d++;
+				f = _mm_mul_ps(f, postscale);
+				_mm_store_ps(&aDestBuffer.mData[d], f);
+				d += 4;
 			}
 		}
-		else
+	}
+	else
+	{
+		float nb = -1.0f;
+		__m128 negbound = _mm_load_ps1(&nb);
+		float pb = 1.0f;
+		__m128 posbound = _mm_load_ps1(&pb);
+		__m128 postscale = _mm_load_ps1(&mPostClipScaler);
+		TinyAlignedFloatBuffer volumes;
+		volumes.mData[0] = v;
+		volumes.mData[1] = v + vd;
+		volumes.mData[2] = v + vd + vd;
+		volumes.mData[3] = v + vd + vd + vd;
+		vd *= 4;
+		__m128 vdelta = _mm_load_ps1(&vd);
+		c = 0;
+		d = 0;
+		for (j = 0; j < mChannels; j++)
 		{
-			float nb = -1.0f;	__m128 negbound = _mm_load_ps1(&nb);
-			float pb = 1.0f;	__m128 posbound = _mm_load_ps1(&pb);
-			__m128 postscale = _mm_load_ps1(&mPostClipScaler);
-			TinyAlignedFloatBuffer volumes;
-			volumes.mData[0] = v;
-			volumes.mData[1] = v + vd;
-			volumes.mData[2] = v + vd + vd;
-			volumes.mData[3] = v + vd + vd + vd;
-			vd *= 4;
-			__m128 vdelta = _mm_load_ps1(&vd);
-			c = 0;
-			d = 0;
-			for (j = 0; j < mChannels; j++)
+			__m128 vol = _mm_load_ps(volumes.mData);
+			for (i = 0; i < samplequads; i++)
 			{
-				__m128 vol = _mm_load_ps(volumes.mData);
-				for (i = 0; i < samplequads; i++) 
-				{
-					//float f1 = aBuffer.mData[c] * v; c++; v += vd;
-					__m128 f = _mm_load_ps(&aBuffer.mData[c]);
-					c += 4;
-					f = _mm_mul_ps(f, vol);
-					vol = _mm_add_ps(vol, vdelta);
-
-					//f1 = (f1 <= -1) ? -1 : (f1 >= 1) ? 1 : f1;
-					f = _mm_max_ps(f, negbound);
-					f = _mm_min_ps(f, posbound);
-
-					//aDestBuffer.mData[d] = f1 * mPostClipScaler; d++;
-					f = _mm_mul_ps(f, postscale);
-					_mm_store_ps(&aDestBuffer.mData[d], f);
-					d += 4;
-				}
+				// float f1 = aBuffer.mData[c] * v; c++; v += vd;
+				__m128 f = _mm_load_ps(&aBuffer.mData[c]);
+				c += 4;
+				f = _mm_mul_ps(f, vol);
+				vol = _mm_add_ps(vol, vdelta);
+
+				// f1 = (f1 <= -1) ? -1 : (f1 >= 1) ? 1 : f1;
+				f = _mm_max_ps(f, negbound);
+				f = _mm_min_ps(f, posbound);
+
+				// aDestBuffer.mData[d] = f1 * mPostClipScaler; d++;
+				f = _mm_mul_ps(f, postscale);
+				_mm_store_ps(&aDestBuffer.mData[d], f);
+				d += 4;
 			}
 		}
 	}
+}
 #else // fallback code
-	void Soloud::clip_internal(AlignedFloatBuffer &aBuffer, AlignedFloatBuffer &aDestBuffer, unsigned int aSamples, float aVolume0, float aVolume1)
+void Soloud::clip_internal(AlignedFloatBuffer &aBuffer, AlignedFloatBuffer &aDestBuffer, unsigned int aSamples, float aVolume0, float aVolume1)
+{
+	float vd = (aVolume1 - aVolume0) / aSamples;
+	float v = aVolume0;
+	unsigned int i, j, c, d;
+	unsigned int samplequads = (aSamples + 3) / 4; // rounded up
+	// Clip
+	if (mFlags & CLIP_ROUNDOFF)
 	{
-		float vd = (aVolume1 - aVolume0) / aSamples;
-		float v = aVolume0;
-		unsigned int i, j, c, d;
-		unsigned int samplequads = (aSamples + 3) / 4; // rounded up
-		// Clip
-		if (mFlags & CLIP_ROUNDOFF)
+		c = 0;
+		d = 0;
+		for (j = 0; j < mChannels; j++)
 		{
-			c = 0;
-			d = 0;
-			for (j = 0; j < mChannels; j++)
+			v = aVolume0;
+			for (i = 0; i < samplequads; i++)
 			{
-				v = aVolume0;
-				for (i = 0; i < samplequads; i++)
-				{
-					float f1 = aBuffer.mData[c] * v; c++; v += vd;
-					float f2 = aBuffer.mData[c] * v; c++; v += vd;
-					float f3 = aBuffer.mData[c] * v; c++; v += vd;
-					float f4 = aBuffer.mData[c] * v; c++; v += vd;
-
-					f1 = (f1 <= -1.65f) ? -0.9862875f : (f1 >= 1.65f) ? 0.9862875f : (0.87f * f1 - 0.1f * f1 * f1 * f1);
-					f2 = (f2 <= -1.65f) ? -0.9862875f : (f2 >= 1.65f) ? 0.9862875f : (0.87f * f2 - 0.1f * f2 * f2 * f2);
-					f3 = (f3 <= -1.65f) ? -0.9862875f : (f3 >= 1.65f) ? 0.9862875f : (0.87f * f3 - 0.1f * f3 * f3 * f3);
-					f4 = (f4 <= -1.65f) ? -0.9862875f : (f4 >= 1.65f) ? 0.9862875f : (0.87f * f4 - 0.1f * f4 * f4 * f4);
-
-					aDestBuffer.mData[d] = f1 * mPostClipScaler; d++;
-					aDestBuffer.mData[d] = f2 * mPostClipScaler; d++;
-					aDestBuffer.mData[d] = f3 * mPostClipScaler; d++;
-					aDestBuffer.mData[d] = f4 * mPostClipScaler; d++;
-				}
+				float f1 = aBuffer.mData[c] * v;
+				c++;
+				v += vd;
+				float f2 = aBuffer.mData[c] * v;
+				c++;
+				v += vd;
+				float f3 = aBuffer.mData[c] * v;
+				c++;
+				v += vd;
+				float f4 = aBuffer.mData[c] * v;
+				c++;
+				v += vd;
+
+				f1 = (f1 <= -1.65f) ? -0.9862875f : (f1 >= 1.65f) ? 0.9862875f : (0.87f * f1 - 0.1f * f1 * f1 * f1);
+				f2 = (f2 <= -1.65f) ? -0.9862875f : (f2 >= 1.65f) ? 0.9862875f : (0.87f * f2 - 0.1f * f2 * f2 * f2);
+				f3 = (f3 <= -1.65f) ? -0.9862875f : (f3 >= 1.65f) ? 0.9862875f : (0.87f * f3 - 0.1f * f3 * f3 * f3);
+				f4 = (f4 <= -1.65f) ? -0.9862875f : (f4 >= 1.65f) ? 0.9862875f : (0.87f * f4 - 0.1f * f4 * f4 * f4);
+
+				aDestBuffer.mData[d] = f1 * mPostClipScaler;
+				d++;
+				aDestBuffer.mData[d] = f2 * mPostClipScaler;
+				d++;
+				aDestBuffer.mData[d] = f3 * mPostClipScaler;
+				d++;
+				aDestBuffer.mData[d] = f4 * mPostClipScaler;
+				d++;
 			}
 		}
-		else
+	}
+	else
+	{
+		c = 0;
+		d = 0;
+		for (j = 0; j < mChannels; j++)
 		{
-			c = 0;
-			d = 0;
-			for (j = 0; j < mChannels; j++)
+			v = aVolume0;
+			for (i = 0; i < samplequads; i++)
 			{
-				v = aVolume0;
-				for (i = 0; i < samplequads; i++) 
-				{
-					float f1 = aBuffer.mData[c] * v; c++; v += vd;
-					float f2 = aBuffer.mData[c] * v; c++; v += vd;
-					float f3 = aBuffer.mData[c] * v; c++; v += vd;
-					float f4 = aBuffer.mData[c] * v; c++; v += vd;
-
-					f1 = (f1 <= -1) ? -1 : (f1 >= 1) ? 1 : f1;
-					f2 = (f2 <= -1) ? -1 : (f2 >= 1) ? 1 : f2;
-					f3 = (f3 <= -1) ? -1 : (f3 >= 1) ? 1 : f3;
-					f4 = (f4 <= -1) ? -1 : (f4 >= 1) ? 1 : f4;
-
-					aDestBuffer.mData[d] = f1 * mPostClipScaler; d++;
-					aDestBuffer.mData[d] = f2 * mPostClipScaler; d++;
-					aDestBuffer.mData[d] = f3 * mPostClipScaler; d++;
-					aDestBuffer.mData[d] = f4 * mPostClipScaler; d++;
+				float f1 = aBuffer.mData[c] * v;
+				c++;
+				v += vd;
+				float f2 = aBuffer.mData[c] * v;
+				c++;
+				v += vd;
+				float f3 = aBuffer.mData[c] * v;
+				c++;
+				v += vd;
+				float f4 = aBuffer.mData[c] * v;
+				c++;
+				v += vd;
+
+				f1 = (f1 <= -1) ? -1 : (f1 >= 1) ? 1 : f1;
+				f2 = (f2 <= -1) ? -1 : (f2 >= 1) ? 1 : f2;
+				f3 = (f3 <= -1) ? -1 : (f3 >= 1) ? 1 : f3;
+				f4 = (f4 <= -1) ? -1 : (f4 >= 1) ? 1 : f4;
+
+				aDestBuffer.mData[d] = f1 * mPostClipScaler;
+				d++;
+				aDestBuffer.mData[d] = f2 * mPostClipScaler;
+				d++;
+				aDestBuffer.mData[d] = f3 * mPostClipScaler;
+				d++;
+				aDestBuffer.mData[d] = f4 * mPostClipScaler;
+				d++;
 			}
 		}
 	}
@@ -962,1382 +979,1356 @@ namespace SoLoud
 #define FIXPOINT_FRAC_MUL (1 << FIXPOINT_FRAC_BITS)
 #define FIXPOINT_FRAC_MASK ((1 << FIXPOINT_FRAC_BITS) - 1)
 
-	static float catmullrom(float t, float p0, float p1, float p2, float p3)
-	{
-		return 0.5f * (
-			(2 * p1) +
-			(-p0 + p2) * t +
-			(2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t +
-			(-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t
-			);
-	}
+static float catmullrom(float t, float p0, float p1, float p2, float p3)
+{
+	return 0.5f * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t + (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t);
+}
 
-	static void resample_catmullrom(float* aSrc,
-		float* aSrc1,
-		float* aDst,
-		int aSrcOffset,
-		int aDstSampleCount,
-		int aStepFixed)
-	{
-		int i;
-		int pos = aSrcOffset;
+static void resample_catmullrom(float *aSrc, float *aSrc1, float *aDst, int aSrcOffset, int aDstSampleCount, int aStepFixed)
+{
+	int i;
+	int pos = aSrcOffset;
 
-		for (i = 0; i < aDstSampleCount; i++, pos += aStepFixed)
-		{
-			int p = pos >> FIXPOINT_FRAC_BITS;
-			int f = pos & FIXPOINT_FRAC_MASK;
+	for (i = 0; i < aDstSampleCount; i++, pos += aStepFixed)
+	{
+		int p = pos >> FIXPOINT_FRAC_BITS;
+		int f = pos & FIXPOINT_FRAC_MASK;
 
-			float s0, s1, s2, s3;
+		float s0, s1, s2, s3;
 
-			if (p < 3)
-			{
-				s3 = aSrc1[512 + p - 3];
-			}
-			else
-			{
-				s3 = aSrc[p - 3];
-			}
+		if (p < 3)
+		{
+			s3 = aSrc1[512 + p - 3];
+		}
+		else
+		{
+			s3 = aSrc[p - 3];
+		}
 
-			if (p < 2)
-			{
-				s2 = aSrc1[512 + p - 2];
-			}
-			else
-			{
-				s2 = aSrc[p - 2];
-			}
+		if (p < 2)
+		{
+			s2 = aSrc1[512 + p - 2];
+		}
+		else
+		{
+			s2 = aSrc[p - 2];
+		}
 
-			if (p < 1)
-			{
-				s1 = aSrc1[512 + p - 1];
-			}
-			else
-			{
-				s1 = aSrc[p - 1];
-			}
+		if (p < 1)
+		{
+			s1 = aSrc1[512 + p - 1];
+		}
+		else
+		{
+			s1 = aSrc[p - 1];
+		}
 
-			s0 = aSrc[p];
+		s0 = aSrc[p];
 
-			aDst[i] = catmullrom(f / (float)FIXPOINT_FRAC_MUL, s3, s2, s1, s0);
-		}
+		aDst[i] = catmullrom(f / (float)FIXPOINT_FRAC_MUL, s3, s2, s1, s0);
 	}
+}
 
-	static void resample_linear(float* aSrc,
-		float* aSrc1,
-		float* aDst,
-		int aSrcOffset,
-		int aDstSampleCount,
-		int aStepFixed)
-	{
-		int i;
-		int pos = aSrcOffset;
+static void resample_linear(float *aSrc, float *aSrc1, float *aDst, int aSrcOffset, int aDstSampleCount, int aStepFixed)
+{
+	int i;
+	int pos = aSrcOffset;
 
-		for (i = 0; i < aDstSampleCount; i++, pos += aStepFixed)
-		{
-			int p = pos >> FIXPOINT_FRAC_BITS;
-			int f = pos & FIXPOINT_FRAC_MASK;
+	for (i = 0; i < aDstSampleCount; i++, pos += aStepFixed)
+	{
+		int p = pos >> FIXPOINT_FRAC_BITS;
+		int f = pos & FIXPOINT_FRAC_MASK;
 #ifdef _DEBUG
-			if (p >= SAMPLE_GRANULARITY || p < 0)
-			{
-				// This should never actually happen
-				p = SAMPLE_GRANULARITY - 1;
-			}
-#endif
-			float s1 = aSrc1[SAMPLE_GRANULARITY - 1];
-			float s2 = aSrc[p];
-			if (p != 0)
-			{
-				s1 = aSrc[p - 1];
-			}
-			aDst[i] = s1 + (s2 - s1) * f * (1 / (float)FIXPOINT_FRAC_MUL);
+		if (p >= SAMPLE_GRANULARITY || p < 0)
+		{
+			// This should never actually happen
+			p = SAMPLE_GRANULARITY - 1;
 		}
-	}
-
-	static void resample_point(float* aSrc,
-		float* aSrc1,
-		float* aDst,
-		int aSrcOffset,
-		int aDstSampleCount,
-		int aStepFixed)
-	{
-		int i;
-		int pos = aSrcOffset;
-
-		for (i = 0; i < aDstSampleCount; i++, pos += aStepFixed)
+#endif
+		float s1 = aSrc1[SAMPLE_GRANULARITY - 1];
+		float s2 = aSrc[p];
+		if (p != 0)
 		{
-			int p = pos >> FIXPOINT_FRAC_BITS;
-			aDst[i] = aSrc[p];
+			s1 = aSrc[p - 1];
 		}
+		aDst[i] = s1 + (s2 - s1) * f * (1 / (float)FIXPOINT_FRAC_MUL);
 	}
+}
 
+static void resample_point(float *aSrc, float *aSrc1, float *aDst, int aSrcOffset, int aDstSampleCount, int aStepFixed)
+{
+	int i;
+	int pos = aSrcOffset;
 
-
-	void panAndExpand(AudioSourceInstance *aVoice, float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize, float *aScratch, unsigned int aChannels)
+	for (i = 0; i < aDstSampleCount; i++, pos += aStepFixed)
 	{
+		int p = pos >> FIXPOINT_FRAC_BITS;
+		aDst[i] = aSrc[p];
+	}
+}
+
+void panAndExpand(AudioSourceInstance *aVoice, float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize, float *aScratch, unsigned int aChannels)
+{
 #ifdef SOLOUD_SSE_INTRINSICS
-		SOLOUD_ASSERT(((size_t)aBuffer & 0xf) == 0);
-		SOLOUD_ASSERT(((size_t)aScratch & 0xf) == 0);
-		SOLOUD_ASSERT(((size_t)aBufferSize & 0xf) == 0);
+	SOLOUD_ASSERT(((size_t)aBuffer & 0xf) == 0);
+	SOLOUD_ASSERT(((size_t)aScratch & 0xf) == 0);
+	SOLOUD_ASSERT(((size_t)aBufferSize & 0xf) == 0);
 #endif
-		float pan[MAX_CHANNELS]; // current speaker volume
-		float pand[MAX_CHANNELS]; // destination speaker volume
-		float pani[MAX_CHANNELS]; // speaker volume increment per sample
-		unsigned int j, k;
-		for (k = 0; k < aChannels; k++)
+	float pan[MAX_CHANNELS];  // current speaker volume
+	float pand[MAX_CHANNELS]; // destination speaker volume
+	float pani[MAX_CHANNELS]; // speaker volume increment per sample
+	unsigned int j, k;
+	for (k = 0; k < aChannels; k++)
+	{
+		pan[k] = aVoice->mCurrentChannelVolume[k];
+		pand[k] = aVoice->mChannelVolume[k] * aVoice->mOverallVolume;
+		pani[k] = (pand[k] - pan[k]) / aSamplesToRead; // TODO: this is a bit inconsistent.. but it's a hack to begin with
+	}
+
+	int ofs = 0;
+	switch (aChannels)
+	{
+	case 1: // Target is mono. Sum everything. (1->1, 2->1, 4->1, 6->1, 8->1)
+		for (j = 0, ofs = 0; j < aVoice->mChannels; j++, ofs += aBufferSize)
 		{
-			pan[k] = aVoice->mCurrentChannelVolume[k];
-			pand[k] = aVoice->mChannelVolume[k] * aVoice->mOverallVolume;
-			pani[k] = (pand[k] - pan[k]) / aSamplesToRead; // TODO: this is a bit inconsistent.. but it's a hack to begin with
+			pan[0] = aVoice->mCurrentChannelVolume[0];
+			for (k = 0; k < aSamplesToRead; k++)
+			{
+				pan[0] += pani[0];
+				aBuffer[k] += aScratch[ofs + k] * pan[0];
+			}
 		}
-
-		int ofs = 0;
-		switch (aChannels)
+		break;
+	case 2:
+		switch (aVoice->mChannels)
 		{
-		case 1: // Target is mono. Sum everything. (1->1, 2->1, 4->1, 6->1, 8->1)
-			for (j = 0, ofs = 0; j < aVoice->mChannels; j++, ofs += aBufferSize)
+		case 8: // 8->2, just sum lefties and righties, add a bit of center and sub?
+			for (j = 0; j < aSamplesToRead; j++)
 			{
-				pan[0] = aVoice->mCurrentChannelVolume[0];
-				for (k = 0; k < aSamplesToRead; k++)
-				{
-					pan[0] += pani[0];
-					aBuffer[k] += aScratch[ofs + k] * pan[0];
-				}
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				float s5 = aScratch[aBufferSize * 4 + j];
+				float s6 = aScratch[aBufferSize * 5 + j];
+				float s7 = aScratch[aBufferSize * 6 + j];
+				float s8 = aScratch[aBufferSize * 7 + j];
+				aBuffer[j + 0] += 0.2f * (s1 + s3 + s4 + s5 + s7) * pan[0];
+				aBuffer[j + aBufferSize] += 0.2f * (s2 + s3 + s4 + s6 + s8) * pan[1];
 			}
 			break;
-		case 2:
-			switch (aVoice->mChannels)
+		case 6: // 6->2, just sum lefties and righties, add a bit of center and sub?
+			for (j = 0; j < aSamplesToRead; j++)
 			{
-			case 8: // 8->2, just sum lefties and righties, add a bit of center and sub?
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					float s5 = aScratch[aBufferSize * 4 + j];
-					float s6 = aScratch[aBufferSize * 5 + j];
-					float s7 = aScratch[aBufferSize * 6 + j];
-					float s8 = aScratch[aBufferSize * 7 + j];
-					aBuffer[j + 0]           += 0.2f * (s1 + s3 + s4 + s5 + s7) * pan[0];
-					aBuffer[j + aBufferSize] += 0.2f * (s2 + s3 + s4 + s6 + s8) * pan[1];
-				}
-				break;
-			case 6: // 6->2, just sum lefties and righties, add a bit of center and sub?
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					float s5 = aScratch[aBufferSize * 4 + j];
-					float s6 = aScratch[aBufferSize * 5 + j];
-					aBuffer[j + 0] += 0.3f * (s1 + s3 + s4 + s5) * pan[0];
-					aBuffer[j + aBufferSize] += 0.3f * (s2 + s3 + s4 + s6) * pan[1];
-				}
-				break;
-			case 4: // 4->2, just sum lefties and righties
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					aBuffer[j + 0] += 0.5f * (s1 + s3) * pan[0];
-					aBuffer[j + aBufferSize] += 0.5f * (s2 + s4) * pan[1];
-				}
-				break;
-			case 2: // 2->2
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				float s5 = aScratch[aBufferSize * 4 + j];
+				float s6 = aScratch[aBufferSize * 5 + j];
+				aBuffer[j + 0] += 0.3f * (s1 + s3 + s4 + s5) * pan[0];
+				aBuffer[j + aBufferSize] += 0.3f * (s2 + s3 + s4 + s6) * pan[1];
+			}
+			break;
+		case 4: // 4->2, just sum lefties and righties
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				aBuffer[j + 0] += 0.5f * (s1 + s3) * pan[0];
+				aBuffer[j + aBufferSize] += 0.5f * (s2 + s4) * pan[1];
+			}
+			break;
+		case 2: // 2->2
 #if defined(SOLOUD_SSE_INTRINSICS)
+		{
+			int c = 0;
+			// if ((aBufferSize & 3) == 0)
+			{
+				unsigned int samplequads = aSamplesToRead / 4; // rounded down
+				TinyAlignedFloatBuffer pan0;
+				pan0.mData[0] = pan[0] + pani[0];
+				pan0.mData[1] = pan[0] + pani[0] * 2;
+				pan0.mData[2] = pan[0] + pani[0] * 3;
+				pan0.mData[3] = pan[0] + pani[0] * 4;
+				TinyAlignedFloatBuffer pan1;
+				pan1.mData[0] = pan[1] + pani[1];
+				pan1.mData[1] = pan[1] + pani[1] * 2;
+				pan1.mData[2] = pan[1] + pani[1] * 3;
+				pan1.mData[3] = pan[1] + pani[1] * 4;
+				pani[0] *= 4;
+				pani[1] *= 4;
+				__m128 pan0delta = _mm_load_ps1(&pani[0]);
+				__m128 pan1delta = _mm_load_ps1(&pani[1]);
+				__m128 p0 = _mm_load_ps(pan0.mData);
+				__m128 p1 = _mm_load_ps(pan1.mData);
+
+				for (j = 0; j < samplequads; j++)
 				{
-					int c = 0;
-					//if ((aBufferSize & 3) == 0)
-					{
-						unsigned int samplequads = aSamplesToRead / 4; // rounded down
-						TinyAlignedFloatBuffer pan0;
-						pan0.mData[0] = pan[0] + pani[0];
-						pan0.mData[1] = pan[0] + pani[0] * 2;
-						pan0.mData[2] = pan[0] + pani[0] * 3;
-						pan0.mData[3] = pan[0] + pani[0] * 4;
-						TinyAlignedFloatBuffer pan1;
-						pan1.mData[0] = pan[1] + pani[1];
-						pan1.mData[1] = pan[1] + pani[1] * 2;
-						pan1.mData[2] = pan[1] + pani[1] * 3;
-						pan1.mData[3] = pan[1] + pani[1] * 4;
-						pani[0] *= 4;
-						pani[1] *= 4;
-						__m128 pan0delta = _mm_load_ps1(&pani[0]);
-						__m128 pan1delta = _mm_load_ps1(&pani[1]);
-						__m128 p0 = _mm_load_ps(pan0.mData);
-						__m128 p1 = _mm_load_ps(pan1.mData);
-
-						for (j = 0; j < samplequads; j++)
-						{
-							__m128 f0 = _mm_load_ps(aScratch + c);
-							__m128 c0 = _mm_mul_ps(f0, p0);
-							__m128 f1 = _mm_load_ps(aScratch + c + aBufferSize);
-							__m128 c1 = _mm_mul_ps(f1, p1);
-							__m128 o0 = _mm_load_ps(aBuffer + c);
-							__m128 o1 = _mm_load_ps(aBuffer + c + aBufferSize);
-							c0 = _mm_add_ps(c0, o0);
-							c1 = _mm_add_ps(c1, o1);
-							_mm_store_ps(aBuffer + c, c0);
-							_mm_store_ps(aBuffer + c + aBufferSize, c1);
-							p0 = _mm_add_ps(p0, pan0delta);
-							p1 = _mm_add_ps(p1, pan1delta);
-							c += 4;
-						}
-					}
-					
-					// If buffer size or samples to read are not divisible by 4, handle leftovers
-					for (j = c; j < aSamplesToRead; j++)
-					{
-						pan[0] += pani[0];
-						pan[1] += pani[1];
-						float s1 = aScratch[j];
-						float s2 = aScratch[aBufferSize + j];
-						aBuffer[j + 0] += s1 * pan[0];
-						aBuffer[j + aBufferSize] += s2 * pan[1];
-					}
+					__m128 f0 = _mm_load_ps(aScratch + c);
+					__m128 c0 = _mm_mul_ps(f0, p0);
+					__m128 f1 = _mm_load_ps(aScratch + c + aBufferSize);
+					__m128 c1 = _mm_mul_ps(f1, p1);
+					__m128 o0 = _mm_load_ps(aBuffer + c);
+					__m128 o1 = _mm_load_ps(aBuffer + c + aBufferSize);
+					c0 = _mm_add_ps(c0, o0);
+					c1 = _mm_add_ps(c1, o1);
+					_mm_store_ps(aBuffer + c, c0);
+					_mm_store_ps(aBuffer + c + aBufferSize, c1);
+					p0 = _mm_add_ps(p0, pan0delta);
+					p1 = _mm_add_ps(p1, pan1delta);
+					c += 4;
 				}
+			}
+
+			// If buffer size or samples to read are not divisible by 4, handle leftovers
+			for (j = c; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+			}
+		}
 #else // fallback
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-				}
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+			}
 #endif
-				break;
-			case 1: // 1->2
+		break;
+		case 1: // 1->2
 #if defined(SOLOUD_SSE_INTRINSICS)
+		{
+			int c = 0;
+			// if ((aBufferSize & 3) == 0)
+			{
+				unsigned int samplequads = aSamplesToRead / 4; // rounded down
+				TinyAlignedFloatBuffer pan0;
+				pan0.mData[0] = pan[0] + pani[0];
+				pan0.mData[1] = pan[0] + pani[0] * 2;
+				pan0.mData[2] = pan[0] + pani[0] * 3;
+				pan0.mData[3] = pan[0] + pani[0] * 4;
+				TinyAlignedFloatBuffer pan1;
+				pan1.mData[0] = pan[1] + pani[1];
+				pan1.mData[1] = pan[1] + pani[1] * 2;
+				pan1.mData[2] = pan[1] + pani[1] * 3;
+				pan1.mData[3] = pan[1] + pani[1] * 4;
+				pani[0] *= 4;
+				pani[1] *= 4;
+				__m128 pan0delta = _mm_load_ps1(&pani[0]);
+				__m128 pan1delta = _mm_load_ps1(&pani[1]);
+				__m128 p0 = _mm_load_ps(pan0.mData);
+				__m128 p1 = _mm_load_ps(pan1.mData);
+
+				for (j = 0; j < samplequads; j++)
 				{
-					int c = 0;
-					//if ((aBufferSize & 3) == 0)
-					{
-						unsigned int samplequads = aSamplesToRead / 4; // rounded down
-						TinyAlignedFloatBuffer pan0;
-						pan0.mData[0] = pan[0] + pani[0];
-						pan0.mData[1] = pan[0] + pani[0] * 2;
-						pan0.mData[2] = pan[0] + pani[0] * 3;
-						pan0.mData[3] = pan[0] + pani[0] * 4;
-						TinyAlignedFloatBuffer pan1;
-						pan1.mData[0] = pan[1] + pani[1];
-						pan1.mData[1] = pan[1] + pani[1] * 2;
-						pan1.mData[2] = pan[1] + pani[1] * 3;
-						pan1.mData[3] = pan[1] + pani[1] * 4;
-						pani[0] *= 4;
-						pani[1] *= 4;
-						__m128 pan0delta = _mm_load_ps1(&pani[0]);
-						__m128 pan1delta = _mm_load_ps1(&pani[1]);
-						__m128 p0 = _mm_load_ps(pan0.mData);
-						__m128 p1 = _mm_load_ps(pan1.mData);
-
-						for (j = 0; j < samplequads; j++)
-						{
-							__m128 f = _mm_load_ps(aScratch + c);
-							__m128 c0 = _mm_mul_ps(f, p0);
-							__m128 c1 = _mm_mul_ps(f, p1);
-							__m128 o0 = _mm_load_ps(aBuffer + c);
-							__m128 o1 = _mm_load_ps(aBuffer + c + aBufferSize);
-							c0 = _mm_add_ps(c0, o0);
-							c1 = _mm_add_ps(c1, o1);
-							_mm_store_ps(aBuffer + c, c0);
-							_mm_store_ps(aBuffer + c + aBufferSize, c1);
-							p0 = _mm_add_ps(p0, pan0delta);
-							p1 = _mm_add_ps(p1, pan1delta);
-							c += 4;
-						}
-					}
-					// If buffer size or samples to read are not divisible by 4, handle leftovers
-					for (j = c; j < aSamplesToRead; j++)
-					{
-						pan[0] += pani[0];
-						pan[1] += pani[1];
-						float s = aScratch[j];
-						aBuffer[j + 0] += s * pan[0];
-						aBuffer[j + aBufferSize] += s * pan[1];
-					}
+					__m128 f = _mm_load_ps(aScratch + c);
+					__m128 c0 = _mm_mul_ps(f, p0);
+					__m128 c1 = _mm_mul_ps(f, p1);
+					__m128 o0 = _mm_load_ps(aBuffer + c);
+					__m128 o1 = _mm_load_ps(aBuffer + c + aBufferSize);
+					c0 = _mm_add_ps(c0, o0);
+					c1 = _mm_add_ps(c1, o1);
+					_mm_store_ps(aBuffer + c, c0);
+					_mm_store_ps(aBuffer + c + aBufferSize, c1);
+					p0 = _mm_add_ps(p0, pan0delta);
+					p1 = _mm_add_ps(p1, pan1delta);
+					c += 4;
 				}
+			}
+			// If buffer size or samples to read are not divisible by 4, handle leftovers
+			for (j = c; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				float s = aScratch[j];
+				aBuffer[j + 0] += s * pan[0];
+				aBuffer[j + aBufferSize] += s * pan[1];
+			}
+		}
 #else // fallback
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					float s = aScratch[j];
-					aBuffer[j + 0] += s * pan[0];
-					aBuffer[j + aBufferSize] += s * pan[1];
-				}
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				float s = aScratch[j];
+				aBuffer[j + 0] += s * pan[0];
+				aBuffer[j + aBufferSize] += s * pan[1];
+			}
 #endif
-				break;
+		break;
+		}
+		break;
+	case 4:
+		switch (aVoice->mChannels)
+		{
+		case 8: // 8->4, add a bit of center, sub?
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				float s5 = aScratch[aBufferSize * 4 + j];
+				float s6 = aScratch[aBufferSize * 5 + j];
+				float s7 = aScratch[aBufferSize * 6 + j];
+				float s8 = aScratch[aBufferSize * 7 + j];
+				float c = (s3 + s4) * 0.7f;
+				aBuffer[j + 0] += s1 * pan[0] + c;
+				aBuffer[j + aBufferSize] += s2 * pan[1] + c;
+				aBuffer[j + aBufferSize * 2] += 0.5f * (s5 + s7) * pan[2];
+				aBuffer[j + aBufferSize * 3] += 0.5f * (s6 + s8) * pan[3];
 			}
 			break;
-		case 4:
-			switch (aVoice->mChannels)
+		case 6: // 6->4, add a bit of center, sub?
+			for (j = 0; j < aSamplesToRead; j++)
 			{
-			case 8: // 8->4, add a bit of center, sub?
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					float s5 = aScratch[aBufferSize * 4 + j];
-					float s6 = aScratch[aBufferSize * 5 + j];
-					float s7 = aScratch[aBufferSize * 6 + j];
-					float s8 = aScratch[aBufferSize * 7 + j];
-					float c = (s3 + s4) * 0.7f;
-					aBuffer[j + 0]               += s1 * pan[0] + c;
-					aBuffer[j + aBufferSize]     += s2 * pan[1] + c;
-					aBuffer[j + aBufferSize * 2] += 0.5f * (s5 + s7) * pan[2];
-					aBuffer[j + aBufferSize * 3] += 0.5f * (s6 + s8) * pan[3];
-				}
-				break;
-			case 6: // 6->4, add a bit of center, sub?
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					float s5 = aScratch[aBufferSize * 4 + j];
-					float s6 = aScratch[aBufferSize * 5 + j];
-					float c = (s3 + s4) * 0.7f;
-					aBuffer[j + 0] += s1 * pan[0] + c;
-					aBuffer[j + aBufferSize] += s2 * pan[1] + c;
-					aBuffer[j + aBufferSize * 2] += s5 * pan[2];
-					aBuffer[j + aBufferSize * 3] += s6 * pan[3];
-				}
-				break;
-			case 4: // 4->4
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-					aBuffer[j + aBufferSize * 2] += s3 * pan[2];
-					aBuffer[j + aBufferSize * 3] += s4 * pan[3];
-				}
-				break;
-			case 2: // 2->4
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-					aBuffer[j + aBufferSize * 2] += s1 * pan[2];
-					aBuffer[j + aBufferSize * 3] += s2 * pan[3];
-				}
-				break;
-			case 1: // 1->4
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					float s = aScratch[j];
-					aBuffer[j + 0] += s * pan[0];
-					aBuffer[j + aBufferSize] += s * pan[1];
-					aBuffer[j + aBufferSize * 2] += s * pan[2];
-					aBuffer[j + aBufferSize * 3] += s * pan[3];
-				}
-				break;
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				float s5 = aScratch[aBufferSize * 4 + j];
+				float s6 = aScratch[aBufferSize * 5 + j];
+				float c = (s3 + s4) * 0.7f;
+				aBuffer[j + 0] += s1 * pan[0] + c;
+				aBuffer[j + aBufferSize] += s2 * pan[1] + c;
+				aBuffer[j + aBufferSize * 2] += s5 * pan[2];
+				aBuffer[j + aBufferSize * 3] += s6 * pan[3];
 			}
 			break;
-		case 6:
-			switch (aVoice->mChannels)
+		case 4: // 4->4
+			for (j = 0; j < aSamplesToRead; j++)
 			{
-			case 8: // 8->6
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					pan[4] += pani[4];
-					pan[5] += pani[5];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					float s5 = aScratch[aBufferSize * 4 + j];
-					float s6 = aScratch[aBufferSize * 5 + j];
-					float s7 = aScratch[aBufferSize * 6 + j];
-					float s8 = aScratch[aBufferSize * 7 + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-					aBuffer[j + aBufferSize * 2] += s3 * pan[2];
-					aBuffer[j + aBufferSize * 3] += s4 * pan[3];
-					aBuffer[j + aBufferSize * 4] += 0.5f * (s5 + s7) * pan[4];
-					aBuffer[j + aBufferSize * 5] += 0.5f * (s6 + s8) * pan[5];
-				}
-				break;
-			case 6: // 6->6
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					pan[4] += pani[4];
-					pan[5] += pani[5];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					float s5 = aScratch[aBufferSize * 4 + j];
-					float s6 = aScratch[aBufferSize * 5 + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-					aBuffer[j + aBufferSize * 2] += s3 * pan[2];
-					aBuffer[j + aBufferSize * 3] += s4 * pan[3];
-					aBuffer[j + aBufferSize * 4] += s5 * pan[4];
-					aBuffer[j + aBufferSize * 5] += s6 * pan[5];
-				}
-				break;
-			case 4: // 4->6
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					pan[4] += pani[4];
-					pan[5] += pani[5];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-					aBuffer[j + aBufferSize * 2] += 0.5f * (s1 + s2) * pan[2];
-					aBuffer[j + aBufferSize * 3] += 0.25f * (s1 + s2 + s3 + s4) * pan[3];
-					aBuffer[j + aBufferSize * 4] += s3 * pan[4];
-					aBuffer[j + aBufferSize * 5] += s4 * pan[5];
-				}
-				break;
-			case 2: // 2->6
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					pan[4] += pani[4];
-					pan[5] += pani[5];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-					aBuffer[j + aBufferSize * 2] += 0.5f * (s1 + s2) * pan[2];
-					aBuffer[j + aBufferSize * 3] += 0.5f * (s1 + s2) * pan[3];
-					aBuffer[j + aBufferSize * 4] += s1 * pan[4];
-					aBuffer[j + aBufferSize * 5] += s2 * pan[5];
-				}
-				break;
-			case 1: // 1->6
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					pan[4] += pani[4];
-					pan[5] += pani[5];
-					float s = aScratch[j];
-					aBuffer[j + 0] += s * pan[0];
-					aBuffer[j + aBufferSize] += s * pan[1];
-					aBuffer[j + aBufferSize * 2] += s * pan[2];
-					aBuffer[j + aBufferSize * 3] += s * pan[3];
-					aBuffer[j + aBufferSize * 4] += s * pan[4];
-					aBuffer[j + aBufferSize * 5] += s * pan[5];
-				}
-				break;
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+				aBuffer[j + aBufferSize * 2] += s3 * pan[2];
+				aBuffer[j + aBufferSize * 3] += s4 * pan[3];
 			}
 			break;
-		case 8:
-			switch (aVoice->mChannels)
+		case 2: // 2->4
+			for (j = 0; j < aSamplesToRead; j++)
 			{
-			case 8: // 8->8
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					pan[4] += pani[4];
-					pan[5] += pani[5];
-					pan[6] += pani[6];
-					pan[7] += pani[7];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					float s5 = aScratch[aBufferSize * 4 + j];
-					float s6 = aScratch[aBufferSize * 5 + j];
-					float s7 = aScratch[aBufferSize * 6 + j];
-					float s8 = aScratch[aBufferSize * 7 + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-					aBuffer[j + aBufferSize * 2] += s3 * pan[2];
-					aBuffer[j + aBufferSize * 3] += s4 * pan[3];
-					aBuffer[j + aBufferSize * 4] += s5 * pan[4];
-					aBuffer[j + aBufferSize * 5] += s6 * pan[5];
-					aBuffer[j + aBufferSize * 6] += s7 * pan[6];
-					aBuffer[j + aBufferSize * 7] += s8 * pan[7];
-				}
-				break;
-			case 6: // 6->8
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					pan[4] += pani[4];
-					pan[5] += pani[5];
-					pan[6] += pani[6];
-					pan[7] += pani[7];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					float s5 = aScratch[aBufferSize * 4 + j];
-					float s6 = aScratch[aBufferSize * 5 + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-					aBuffer[j + aBufferSize * 2] += s3 * pan[2];
-					aBuffer[j + aBufferSize * 3] += s4 * pan[3];
-					aBuffer[j + aBufferSize * 4] += 0.5f * (s5 + s1) * pan[4];
-					aBuffer[j + aBufferSize * 5] += 0.5f * (s6 + s2) * pan[5];
-					aBuffer[j + aBufferSize * 6] += s5 * pan[6];
-					aBuffer[j + aBufferSize * 7] += s6 * pan[7];
-				}
-				break;
-			case 4: // 4->8
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					pan[4] += pani[4];
-					pan[5] += pani[5];
-					pan[6] += pani[6];
-					pan[7] += pani[7];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					float s3 = aScratch[aBufferSize * 2 + j];
-					float s4 = aScratch[aBufferSize * 3 + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-					aBuffer[j + aBufferSize * 2] += 0.5f * (s1 + s2) * pan[2];
-					aBuffer[j + aBufferSize * 3] += 0.25f * (s1 + s2 + s3 + s4) * pan[3];
-					aBuffer[j + aBufferSize * 4] += 0.5f * (s1 + s3) * pan[4];
-					aBuffer[j + aBufferSize * 5] += 0.5f * (s2 + s4) * pan[5];
-					aBuffer[j + aBufferSize * 6] += s3 * pan[4];
-					aBuffer[j + aBufferSize * 7] += s4 * pan[5];
-				}
-				break;
-			case 2: // 2->8
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					pan[4] += pani[4];
-					pan[5] += pani[5];
-					pan[6] += pani[6];
-					pan[7] += pani[7];
-					float s1 = aScratch[j];
-					float s2 = aScratch[aBufferSize + j];
-					aBuffer[j + 0] += s1 * pan[0];
-					aBuffer[j + aBufferSize] += s2 * pan[1];
-					aBuffer[j + aBufferSize * 2] += 0.5f * (s1 + s2) * pan[2];
-					aBuffer[j + aBufferSize * 3] += 0.5f * (s1 + s2) * pan[3];
-					aBuffer[j + aBufferSize * 4] += s1 * pan[4];
-					aBuffer[j + aBufferSize * 5] += s2 * pan[5];
-					aBuffer[j + aBufferSize * 6] += s1 * pan[6];
-					aBuffer[j + aBufferSize * 7] += s2 * pan[7];
-				}
-				break;
-			case 1: // 1->8
-				for (j = 0; j < aSamplesToRead; j++)
-				{
-					pan[0] += pani[0];
-					pan[1] += pani[1];
-					pan[2] += pani[2];
-					pan[3] += pani[3];
-					pan[4] += pani[4];
-					pan[5] += pani[5];
-					pan[6] += pani[6];
-					pan[7] += pani[7];
-					float s = aScratch[j];
-					aBuffer[j + 0] += s * pan[0];
-					aBuffer[j + aBufferSize] += s * pan[1];
-					aBuffer[j + aBufferSize * 2] += s * pan[2];
-					aBuffer[j + aBufferSize * 3] += s * pan[3];
-					aBuffer[j + aBufferSize * 4] += s * pan[4];
-					aBuffer[j + aBufferSize * 5] += s * pan[5];
-					aBuffer[j + aBufferSize * 6] += s * pan[6];
-					aBuffer[j + aBufferSize * 7] += s * pan[7];
-				}
-				break;
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+				aBuffer[j + aBufferSize * 2] += s1 * pan[2];
+				aBuffer[j + aBufferSize * 3] += s2 * pan[3];
+			}
+			break;
+		case 1: // 1->4
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				float s = aScratch[j];
+				aBuffer[j + 0] += s * pan[0];
+				aBuffer[j + aBufferSize] += s * pan[1];
+				aBuffer[j + aBufferSize * 2] += s * pan[2];
+				aBuffer[j + aBufferSize * 3] += s * pan[3];
+			}
+			break;
+		}
+		break;
+	case 6:
+		switch (aVoice->mChannels)
+		{
+		case 8: // 8->6
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				pan[4] += pani[4];
+				pan[5] += pani[5];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				float s5 = aScratch[aBufferSize * 4 + j];
+				float s6 = aScratch[aBufferSize * 5 + j];
+				float s7 = aScratch[aBufferSize * 6 + j];
+				float s8 = aScratch[aBufferSize * 7 + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+				aBuffer[j + aBufferSize * 2] += s3 * pan[2];
+				aBuffer[j + aBufferSize * 3] += s4 * pan[3];
+				aBuffer[j + aBufferSize * 4] += 0.5f * (s5 + s7) * pan[4];
+				aBuffer[j + aBufferSize * 5] += 0.5f * (s6 + s8) * pan[5];
+			}
+			break;
+		case 6: // 6->6
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				pan[4] += pani[4];
+				pan[5] += pani[5];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				float s5 = aScratch[aBufferSize * 4 + j];
+				float s6 = aScratch[aBufferSize * 5 + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+				aBuffer[j + aBufferSize * 2] += s3 * pan[2];
+				aBuffer[j + aBufferSize * 3] += s4 * pan[3];
+				aBuffer[j + aBufferSize * 4] += s5 * pan[4];
+				aBuffer[j + aBufferSize * 5] += s6 * pan[5];
+			}
+			break;
+		case 4: // 4->6
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				pan[4] += pani[4];
+				pan[5] += pani[5];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+				aBuffer[j + aBufferSize * 2] += 0.5f * (s1 + s2) * pan[2];
+				aBuffer[j + aBufferSize * 3] += 0.25f * (s1 + s2 + s3 + s4) * pan[3];
+				aBuffer[j + aBufferSize * 4] += s3 * pan[4];
+				aBuffer[j + aBufferSize * 5] += s4 * pan[5];
+			}
+			break;
+		case 2: // 2->6
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				pan[4] += pani[4];
+				pan[5] += pani[5];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+				aBuffer[j + aBufferSize * 2] += 0.5f * (s1 + s2) * pan[2];
+				aBuffer[j + aBufferSize * 3] += 0.5f * (s1 + s2) * pan[3];
+				aBuffer[j + aBufferSize * 4] += s1 * pan[4];
+				aBuffer[j + aBufferSize * 5] += s2 * pan[5];
+			}
+			break;
+		case 1: // 1->6
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				pan[4] += pani[4];
+				pan[5] += pani[5];
+				float s = aScratch[j];
+				aBuffer[j + 0] += s * pan[0];
+				aBuffer[j + aBufferSize] += s * pan[1];
+				aBuffer[j + aBufferSize * 2] += s * pan[2];
+				aBuffer[j + aBufferSize * 3] += s * pan[3];
+				aBuffer[j + aBufferSize * 4] += s * pan[4];
+				aBuffer[j + aBufferSize * 5] += s * pan[5];
+			}
+			break;
+		}
+		break;
+	case 8:
+		switch (aVoice->mChannels)
+		{
+		case 8: // 8->8
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				pan[4] += pani[4];
+				pan[5] += pani[5];
+				pan[6] += pani[6];
+				pan[7] += pani[7];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				float s5 = aScratch[aBufferSize * 4 + j];
+				float s6 = aScratch[aBufferSize * 5 + j];
+				float s7 = aScratch[aBufferSize * 6 + j];
+				float s8 = aScratch[aBufferSize * 7 + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+				aBuffer[j + aBufferSize * 2] += s3 * pan[2];
+				aBuffer[j + aBufferSize * 3] += s4 * pan[3];
+				aBuffer[j + aBufferSize * 4] += s5 * pan[4];
+				aBuffer[j + aBufferSize * 5] += s6 * pan[5];
+				aBuffer[j + aBufferSize * 6] += s7 * pan[6];
+				aBuffer[j + aBufferSize * 7] += s8 * pan[7];
+			}
+			break;
+		case 6: // 6->8
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				pan[4] += pani[4];
+				pan[5] += pani[5];
+				pan[6] += pani[6];
+				pan[7] += pani[7];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				float s5 = aScratch[aBufferSize * 4 + j];
+				float s6 = aScratch[aBufferSize * 5 + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+				aBuffer[j + aBufferSize * 2] += s3 * pan[2];
+				aBuffer[j + aBufferSize * 3] += s4 * pan[3];
+				aBuffer[j + aBufferSize * 4] += 0.5f * (s5 + s1) * pan[4];
+				aBuffer[j + aBufferSize * 5] += 0.5f * (s6 + s2) * pan[5];
+				aBuffer[j + aBufferSize * 6] += s5 * pan[6];
+				aBuffer[j + aBufferSize * 7] += s6 * pan[7];
+			}
+			break;
+		case 4: // 4->8
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				pan[4] += pani[4];
+				pan[5] += pani[5];
+				pan[6] += pani[6];
+				pan[7] += pani[7];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				float s3 = aScratch[aBufferSize * 2 + j];
+				float s4 = aScratch[aBufferSize * 3 + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+				aBuffer[j + aBufferSize * 2] += 0.5f * (s1 + s2) * pan[2];
+				aBuffer[j + aBufferSize * 3] += 0.25f * (s1 + s2 + s3 + s4) * pan[3];
+				aBuffer[j + aBufferSize * 4] += 0.5f * (s1 + s3) * pan[4];
+				aBuffer[j + aBufferSize * 5] += 0.5f * (s2 + s4) * pan[5];
+				aBuffer[j + aBufferSize * 6] += s3 * pan[4];
+				aBuffer[j + aBufferSize * 7] += s4 * pan[5];
+			}
+			break;
+		case 2: // 2->8
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				pan[4] += pani[4];
+				pan[5] += pani[5];
+				pan[6] += pani[6];
+				pan[7] += pani[7];
+				float s1 = aScratch[j];
+				float s2 = aScratch[aBufferSize + j];
+				aBuffer[j + 0] += s1 * pan[0];
+				aBuffer[j + aBufferSize] += s2 * pan[1];
+				aBuffer[j + aBufferSize * 2] += 0.5f * (s1 + s2) * pan[2];
+				aBuffer[j + aBufferSize * 3] += 0.5f * (s1 + s2) * pan[3];
+				aBuffer[j + aBufferSize * 4] += s1 * pan[4];
+				aBuffer[j + aBufferSize * 5] += s2 * pan[5];
+				aBuffer[j + aBufferSize * 6] += s1 * pan[6];
+				aBuffer[j + aBufferSize * 7] += s2 * pan[7];
+			}
+			break;
+		case 1: // 1->8
+			for (j = 0; j < aSamplesToRead; j++)
+			{
+				pan[0] += pani[0];
+				pan[1] += pani[1];
+				pan[2] += pani[2];
+				pan[3] += pani[3];
+				pan[4] += pani[4];
+				pan[5] += pani[5];
+				pan[6] += pani[6];
+				pan[7] += pani[7];
+				float s = aScratch[j];
+				aBuffer[j + 0] += s * pan[0];
+				aBuffer[j + aBufferSize] += s * pan[1];
+				aBuffer[j + aBufferSize * 2] += s * pan[2];
+				aBuffer[j + aBufferSize * 3] += s * pan[3];
+				aBuffer[j + aBufferSize * 4] += s * pan[4];
+				aBuffer[j + aBufferSize * 5] += s * pan[5];
+				aBuffer[j + aBufferSize * 6] += s * pan[6];
+				aBuffer[j + aBufferSize * 7] += s * pan[7];
 			}
 			break;
 		}
-
-		for (k = 0; k < aChannels; k++)
-			aVoice->mCurrentChannelVolume[k] = pand[k];
+		break;
 	}
 
-	void Soloud::mixBus_internal(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize, float *aScratch, unsigned int aBus, float aSamplerate, unsigned int aChannels, unsigned int aResampler)
+	for (k = 0; k < aChannels; k++)
+		aVoice->mCurrentChannelVolume[k] = pand[k];
+}
+
+void Soloud::mixBus_internal(float *aBuffer,
+                             unsigned int aSamplesToRead,
+                             unsigned int aBufferSize,
+                             float *aScratch,
+                             unsigned int aBus,
+                             float aSamplerate,
+                             unsigned int aChannels,
+                             unsigned int aResampler)
+{
+	unsigned int i, j;
+	// Clear accumulation buffer
+	for (i = 0; i < aSamplesToRead; i++)
 	{
-		unsigned int i, j;
-		// Clear accumulation buffer
-		for (i = 0; i < aSamplesToRead; i++)
+		for (j = 0; j < aChannels; j++)
 		{
-			for (j = 0; j < aChannels; j++)
-			{
-				aBuffer[i + j * aBufferSize] = 0;
-			}
+			aBuffer[i + j * aBufferSize] = 0;
 		}
+	}
 
-		// Accumulate sound sources		
-		for (i = 0; i < mActiveVoiceCount; i++)
+	// Accumulate sound sources
+	for (i = 0; i < mActiveVoiceCount; i++)
+	{
+		AudioSourceInstance *voice = mVoice[mActiveVoice[i]];
+		if (voice && voice->mBusHandle == aBus && !(voice->mFlags & AudioSourceInstance::PAUSED) && !(voice->mFlags & AudioSourceInstance::INAUDIBLE))
 		{
-			AudioSourceInstance *voice = mVoice[mActiveVoice[i]];
-			if (voice &&
-				voice->mBusHandle == aBus &&
-				!(voice->mFlags & AudioSourceInstance::PAUSED) &&
-				!(voice->mFlags & AudioSourceInstance::INAUDIBLE))
+			float step = voice->mSamplerate / aSamplerate;
+			// avoid step overflow
+			if (step > (1 << (32 - FIXPOINT_FRAC_BITS)))
+				step = 0;
+			unsigned int step_fixed = (int)floor(step * FIXPOINT_FRAC_MUL);
+			unsigned int outofs = 0;
+
+			if (voice->mDelaySamples)
 			{
-				float step = voice->mSamplerate / aSamplerate;
-				// avoid step overflow
-				if (step > (1 << (32 - FIXPOINT_FRAC_BITS)))
-					step = 0;
-				unsigned int step_fixed = (int)floor(step * FIXPOINT_FRAC_MUL);
-				unsigned int outofs = 0;
-			
-				if (voice->mDelaySamples)
+				if (voice->mDelaySamples > aSamplesToRead)
 				{
-					if (voice->mDelaySamples > aSamplesToRead)
-					{
-						outofs = aSamplesToRead;
-						voice->mDelaySamples -= aSamplesToRead;
-					}
-					else
-					{
-						outofs = voice->mDelaySamples;
-						voice->mDelaySamples = 0;
-					}
-					
-					// Clear scratch where we're skipping
-					unsigned int k;
-					for (k = 0; k < voice->mChannels; k++)
-					{
-						memset(aScratch + k * aBufferSize, 0, sizeof(float) * outofs); 
-					}
-				}												
+					outofs = aSamplesToRead;
+					voice->mDelaySamples -= aSamplesToRead;
+				}
+				else
+				{
+					outofs = voice->mDelaySamples;
+					voice->mDelaySamples = 0;
+				}
 
-				while (step_fixed != 0 && outofs < aSamplesToRead)
+				// Clear scratch where we're skipping
+				unsigned int k;
+				for (k = 0; k < voice->mChannels; k++)
 				{
-					if (voice->mLeftoverSamples == 0)
-					{
-						// Swap resample buffers (ping-pong)
-						float * t = voice->mResampleData[0];
-						voice->mResampleData[0] = voice->mResampleData[1];
-						voice->mResampleData[1] = t;
+					memset(aScratch + k * aBufferSize, 0, sizeof(float) * outofs);
+				}
+			}
 
-						// Get a block of source data
+			while (step_fixed != 0 && outofs < aSamplesToRead)
+			{
+				if (voice->mLeftoverSamples == 0)
+				{
+					// Swap resample buffers (ping-pong)
+					float *t = voice->mResampleData[0];
+					voice->mResampleData[0] = voice->mResampleData[1];
+					voice->mResampleData[1] = t;
 
-						int readcount = 0;
-						if (!voice->hasEnded() || voice->mFlags & AudioSourceInstance::LOOPING)
-						{
-							readcount = voice->getAudio(voice->mResampleData[0], SAMPLE_GRANULARITY, SAMPLE_GRANULARITY);
-							if (readcount < SAMPLE_GRANULARITY)
-							{
-								if (voice->mFlags & AudioSourceInstance::LOOPING)
-								{
-									while (readcount < SAMPLE_GRANULARITY && voice->seek(voice->mLoopPoint, mScratch.mData, mScratchSize) == SO_NO_ERROR)
-									{
-										voice->mLoopCount++;
-										int inc = voice->getAudio(voice->mResampleData[0] + readcount, SAMPLE_GRANULARITY - readcount, SAMPLE_GRANULARITY);
-										readcount += inc;
-										if (inc == 0) break;
-									}
-								}
-							}
-						}
+					// Get a block of source data
 
-                        // Clear remaining of the resample data if the full scratch wasn't used
+					int readcount = 0;
+					if (!voice->hasEnded() || voice->mFlags & AudioSourceInstance::LOOPING)
+					{
+						readcount = voice->getAudio(voice->mResampleData[0], SAMPLE_GRANULARITY, SAMPLE_GRANULARITY);
 						if (readcount < SAMPLE_GRANULARITY)
 						{
-							unsigned int k;
-							for (k = 0; k < voice->mChannels; k++)
-								memset(voice->mResampleData[0] + readcount + SAMPLE_GRANULARITY * k, 0, sizeof(float) * (SAMPLE_GRANULARITY - readcount));
-						}
-
-						// If we go past zero, crop to zero (a bit of a kludge)
-						if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
-						{
-							voice->mSrcOffset = 0;
-						}
-						else
-						{
-							// We have new block of data, move pointer backwards
-							voice->mSrcOffset -= SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL;
-						}
-
-					
-						// Run the per-stream filters to get our source data
-
-						for (j = 0; j < FILTERS_PER_STREAM; j++)
-						{
-							if (voice->mFilter[j])
+							if (voice->mFlags & AudioSourceInstance::LOOPING)
 							{
-								voice->mFilter[j]->filter(
-									voice->mResampleData[0],
-									SAMPLE_GRANULARITY,
-									SAMPLE_GRANULARITY,
-									voice->mChannels,
-									voice->mSamplerate,
-									mStreamTime);
+								while (readcount < SAMPLE_GRANULARITY && voice->seek(voice->mLoopPoint, mScratch.mData, mScratchSize) == SO_NO_ERROR)
+								{
+									voice->mLoopCount++;
+									int inc = voice->getAudio(voice->mResampleData[0] + readcount, SAMPLE_GRANULARITY - readcount, SAMPLE_GRANULARITY);
+									readcount += inc;
+									if (inc == 0)
+										break;
+								}
 							}
 						}
 					}
-					else
+
+					// Clear remaining of the resample data if the full scratch wasn't used
+					if (readcount < SAMPLE_GRANULARITY)
 					{
-						voice->mLeftoverSamples = 0;
+						unsigned int k;
+						for (k = 0; k < voice->mChannels; k++)
+							memset(voice->mResampleData[0] + readcount + SAMPLE_GRANULARITY * k, 0, sizeof(float) * (SAMPLE_GRANULARITY - readcount));
 					}
 
-					// Figure out how many samples we can generate from this source data.
-					// The value may be zero.
-
-					unsigned int writesamples = 0;
-
+					// If we go past zero, crop to zero (a bit of a kludge)
 					if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
 					{
-						writesamples = ((SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL) - voice->mSrcOffset) / step_fixed + 1;
-
-						// avoid reading past the current buffer..
-						if (((writesamples * step_fixed + voice->mSrcOffset) >> FIXPOINT_FRAC_BITS) >= SAMPLE_GRANULARITY)
-							writesamples--;
+						voice->mSrcOffset = 0;
 					}
-
-
-					// If this is too much for our output buffer, don't write that many:
-					if (writesamples + outofs > aSamplesToRead)
+					else
 					{
-						voice->mLeftoverSamples = (writesamples + outofs) - aSamplesToRead;
-						writesamples = aSamplesToRead - outofs;
+						// We have new block of data, move pointer backwards
+						voice->mSrcOffset -= SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL;
 					}
 
-					// Call resampler to generate the samples, once per channel
-					if (writesamples)
+					// Run the per-stream filters to get our source data
+
+					for (j = 0; j < FILTERS_PER_STREAM; j++)
 					{
-						for (j = 0; j < voice->mChannels; j++)
+						if (voice->mFilter[j])
 						{
-							switch (aResampler)
-							{
-							case RESAMPLER_POINT:
-								resample_point(voice->mResampleData[0] + SAMPLE_GRANULARITY * j,
-									voice->mResampleData[1] + SAMPLE_GRANULARITY * j,
-									aScratch + aBufferSize * j + outofs,
-									voice->mSrcOffset,
-									writesamples,
-									/*voice->mSamplerate,
-									aSamplerate,*/
-									step_fixed);
-								break;
-							case RESAMPLER_CATMULLROM:
-								resample_catmullrom(voice->mResampleData[0] + SAMPLE_GRANULARITY * j,
-									voice->mResampleData[1] + SAMPLE_GRANULARITY * j,
-									aScratch + aBufferSize * j + outofs,
-									voice->mSrcOffset,
-									writesamples,
-									/*voice->mSamplerate,
-									aSamplerate,*/
-									step_fixed);
-								break;
-							default:
-							//case RESAMPLER_LINEAR:
-								resample_linear(voice->mResampleData[0] + SAMPLE_GRANULARITY * j,
-									voice->mResampleData[1] + SAMPLE_GRANULARITY * j,
-									aScratch + aBufferSize * j + outofs,
-									voice->mSrcOffset,
-									writesamples,
-									/*voice->mSamplerate,
-									aSamplerate,*/
-									step_fixed);
-								break;
-							}
+							voice->mFilter[j]->filter(
+							    voice->mResampleData[0], SAMPLE_GRANULARITY, SAMPLE_GRANULARITY, voice->mChannels, voice->mSamplerate, mStreamTime);
 						}
 					}
+				}
+				else
+				{
+					voice->mLeftoverSamples = 0;
+				}
+
+				// Figure out how many samples we can generate from this source data.
+				// The value may be zero.
+
+				unsigned int writesamples = 0;
 
-					// Keep track of how many samples we've written so far
-					outofs += writesamples;
+				if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
+				{
+					writesamples = ((SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL) - voice->mSrcOffset) / step_fixed + 1;
 
-					// Move source pointer onwards (writesamples may be zero)
-					voice->mSrcOffset += writesamples * step_fixed;
+					// avoid reading past the current buffer..
+					if (((writesamples * step_fixed + voice->mSrcOffset) >> FIXPOINT_FRAC_BITS) >= SAMPLE_GRANULARITY)
+						writesamples--;
 				}
-				
-				// Handle panning and channel expansion (and/or shrinking)
-				panAndExpand(voice, aBuffer, aSamplesToRead, aBufferSize, aScratch, aChannels);
 
-				// clear voice if the sound is over
-				if (!(voice->mFlags & (AudioSourceInstance::LOOPING | AudioSourceInstance::DISABLE_AUTOSTOP)) && voice->hasEnded())
+				// If this is too much for our output buffer, don't write that many:
+				if (writesamples + outofs > aSamplesToRead)
 				{
-					stopVoice_internal(mActiveVoice[i]);
+					voice->mLeftoverSamples = (writesamples + outofs) - aSamplesToRead;
+					writesamples = aSamplesToRead - outofs;
 				}
-			}
-			else
-				if (voice &&
-					voice->mBusHandle == aBus &&
-					!(voice->mFlags & AudioSourceInstance::PAUSED) &&
-					(voice->mFlags & AudioSourceInstance::INAUDIBLE) &&
-					(voice->mFlags & AudioSourceInstance::INAUDIBLE_TICK))
-			{
-				// Inaudible but needs ticking. Do minimal work (keep counters up to date and ask audiosource for data)
-				float step = voice->mSamplerate / aSamplerate;
-				int step_fixed = (int)floor(step * FIXPOINT_FRAC_MUL);
-				unsigned int outofs = 0;
 
-				if (voice->mDelaySamples)
+				// Call resampler to generate the samples, once per channel
+				if (writesamples)
 				{
-					if (voice->mDelaySamples > aSamplesToRead)
-					{
-						outofs = aSamplesToRead;
-						voice->mDelaySamples -= aSamplesToRead;
-					}
-					else
+					for (j = 0; j < voice->mChannels; j++)
 					{
-						outofs = voice->mDelaySamples;
-						voice->mDelaySamples = 0;
+						switch (aResampler)
+						{
+						case RESAMPLER_POINT:
+							resample_point(voice->mResampleData[0] + SAMPLE_GRANULARITY * j,
+							               voice->mResampleData[1] + SAMPLE_GRANULARITY * j,
+							               aScratch + aBufferSize * j + outofs,
+							               voice->mSrcOffset,
+							               writesamples,
+							               /*voice->mSamplerate,
+							               aSamplerate,*/
+							               step_fixed);
+							break;
+						case RESAMPLER_CATMULLROM:
+							resample_catmullrom(voice->mResampleData[0] + SAMPLE_GRANULARITY * j,
+							                    voice->mResampleData[1] + SAMPLE_GRANULARITY * j,
+							                    aScratch + aBufferSize * j + outofs,
+							                    voice->mSrcOffset,
+							                    writesamples,
+							                    /*voice->mSamplerate,
+							                    aSamplerate,*/
+							                    step_fixed);
+							break;
+						default:
+							// case RESAMPLER_LINEAR:
+							resample_linear(voice->mResampleData[0] + SAMPLE_GRANULARITY * j,
+							                voice->mResampleData[1] + SAMPLE_GRANULARITY * j,
+							                aScratch + aBufferSize * j + outofs,
+							                voice->mSrcOffset,
+							                writesamples,
+							                /*voice->mSamplerate,
+							                aSamplerate,*/
+							                step_fixed);
+							break;
+						}
 					}
 				}
 
-				while (step_fixed != 0 && outofs < aSamplesToRead)
+				// Keep track of how many samples we've written so far
+				outofs += writesamples;
+
+				// Move source pointer onwards (writesamples may be zero)
+				voice->mSrcOffset += writesamples * step_fixed;
+			}
+
+			// Handle panning and channel expansion (and/or shrinking)
+			panAndExpand(voice, aBuffer, aSamplesToRead, aBufferSize, aScratch, aChannels);
+
+			// clear voice if the sound is over
+			if (!(voice->mFlags & (AudioSourceInstance::LOOPING | AudioSourceInstance::DISABLE_AUTOSTOP)) && voice->hasEnded())
+			{
+				stopVoice_internal(mActiveVoice[i]);
+			}
+		}
+		else if (voice && voice->mBusHandle == aBus && !(voice->mFlags & AudioSourceInstance::PAUSED) && (voice->mFlags & AudioSourceInstance::INAUDIBLE) &&
+		         (voice->mFlags & AudioSourceInstance::INAUDIBLE_TICK))
+		{
+			// Inaudible but needs ticking. Do minimal work (keep counters up to date and ask audiosource for data)
+			float step = voice->mSamplerate / aSamplerate;
+			int step_fixed = (int)floor(step * FIXPOINT_FRAC_MUL);
+			unsigned int outofs = 0;
+
+			if (voice->mDelaySamples)
+			{
+				if (voice->mDelaySamples > aSamplesToRead)
 				{
-					if (voice->mLeftoverSamples == 0)
-					{
-						// Swap resample buffers (ping-pong)
-						float * t = voice->mResampleData[0];
-						voice->mResampleData[0] = voice->mResampleData[1];
-						voice->mResampleData[1] = t;
+					outofs = aSamplesToRead;
+					voice->mDelaySamples -= aSamplesToRead;
+				}
+				else
+				{
+					outofs = voice->mDelaySamples;
+					voice->mDelaySamples = 0;
+				}
+			}
+
+			while (step_fixed != 0 && outofs < aSamplesToRead)
+			{
+				if (voice->mLeftoverSamples == 0)
+				{
+					// Swap resample buffers (ping-pong)
+					float *t = voice->mResampleData[0];
+					voice->mResampleData[0] = voice->mResampleData[1];
+					voice->mResampleData[1] = t;
 
-						// Get a block of source data
+					// Get a block of source data
 
-						int readcount = 0;
-						if (!voice->hasEnded() || voice->mFlags & AudioSourceInstance::LOOPING)
+					int readcount = 0;
+					if (!voice->hasEnded() || voice->mFlags & AudioSourceInstance::LOOPING)
+					{
+						readcount = voice->getAudio(voice->mResampleData[0], SAMPLE_GRANULARITY, SAMPLE_GRANULARITY);
+						if (readcount < SAMPLE_GRANULARITY)
 						{
-							readcount = voice->getAudio(voice->mResampleData[0], SAMPLE_GRANULARITY, SAMPLE_GRANULARITY);
-							if (readcount < SAMPLE_GRANULARITY)
+							if (voice->mFlags & AudioSourceInstance::LOOPING)
 							{
-								if (voice->mFlags & AudioSourceInstance::LOOPING)
+								while (readcount < SAMPLE_GRANULARITY && voice->seek(voice->mLoopPoint, mScratch.mData, mScratchSize) == SO_NO_ERROR)
 								{
-									while (readcount < SAMPLE_GRANULARITY && voice->seek(voice->mLoopPoint, mScratch.mData, mScratchSize) == SO_NO_ERROR)
-									{
-										voice->mLoopCount++;
-										readcount += voice->getAudio(voice->mResampleData[0] + readcount, SAMPLE_GRANULARITY - readcount, SAMPLE_GRANULARITY);
-									}
+									voice->mLoopCount++;
+									readcount += voice->getAudio(voice->mResampleData[0] + readcount, SAMPLE_GRANULARITY - readcount, SAMPLE_GRANULARITY);
 								}
 							}
 						}
+					}
 
-						// If we go past zero, crop to zero (a bit of a kludge)
-						if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
-						{
-							voice->mSrcOffset = 0;
-						}
-						else
-						{
-							// We have new block of data, move pointer backwards
-							voice->mSrcOffset -= SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL;
-						}
-
-						// Skip filters
+					// If we go past zero, crop to zero (a bit of a kludge)
+					if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
+					{
+						voice->mSrcOffset = 0;
 					}
 					else
 					{
-						voice->mLeftoverSamples = 0;
+						// We have new block of data, move pointer backwards
+						voice->mSrcOffset -= SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL;
 					}
 
-					// Figure out how many samples we can generate from this source data.
-					// The value may be zero.
+					// Skip filters
+				}
+				else
+				{
+					voice->mLeftoverSamples = 0;
+				}
 
-					unsigned int writesamples = 0;
+				// Figure out how many samples we can generate from this source data.
+				// The value may be zero.
 
-					if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
-					{
-						writesamples = ((SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL) - voice->mSrcOffset) / step_fixed + 1;
+				unsigned int writesamples = 0;
 
-						// avoid reading past the current buffer..
-						if (((writesamples * step_fixed + voice->mSrcOffset) >> FIXPOINT_FRAC_BITS) >= SAMPLE_GRANULARITY)
-							writesamples--;
-					}
+				if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
+				{
+					writesamples = ((SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL) - voice->mSrcOffset) / step_fixed + 1;
 
+					// avoid reading past the current buffer..
+					if (((writesamples * step_fixed + voice->mSrcOffset) >> FIXPOINT_FRAC_BITS) >= SAMPLE_GRANULARITY)
+						writesamples--;
+				}
 
-					// If this is too much for our output buffer, don't write that many:
-					if (writesamples + outofs > aSamplesToRead)
-					{
-						voice->mLeftoverSamples = (writesamples + outofs) - aSamplesToRead;
-						writesamples = aSamplesToRead - outofs;
-					}
+				// If this is too much for our output buffer, don't write that many:
+				if (writesamples + outofs > aSamplesToRead)
+				{
+					voice->mLeftoverSamples = (writesamples + outofs) - aSamplesToRead;
+					writesamples = aSamplesToRead - outofs;
+				}
 
-					// Skip resampler
+				// Skip resampler
 
-					// Keep track of how many samples we've written so far
-					outofs += writesamples;
+				// Keep track of how many samples we've written so far
+				outofs += writesamples;
 
-					// Move source pointer onwards (writesamples may be zero)
-					voice->mSrcOffset += writesamples * step_fixed;
-				}
+				// Move source pointer onwards (writesamples may be zero)
+				voice->mSrcOffset += writesamples * step_fixed;
+			}
 
-				// clear voice if the sound is over
-				if (!(voice->mFlags & (AudioSourceInstance::LOOPING | AudioSourceInstance::DISABLE_AUTOSTOP)) && voice->hasEnded())
-				{
-					stopVoice_internal(mActiveVoice[i]);
-				}
+			// clear voice if the sound is over
+			if (!(voice->mFlags & (AudioSourceInstance::LOOPING | AudioSourceInstance::DISABLE_AUTOSTOP)) && voice->hasEnded())
+			{
+				stopVoice_internal(mActiveVoice[i]);
 			}
 		}
 	}
+}
 
-	void Soloud::mapResampleBuffers_internal()
+void Soloud::mapResampleBuffers_internal()
+{
+	SOLOUD_ASSERT(mMaxActiveVoices < 256);
+	char live[256];
+	memset(live, 0, mMaxActiveVoices);
+	unsigned int i, j;
+	for (i = 0; i < mMaxActiveVoices; i++)
 	{
-		SOLOUD_ASSERT(mMaxActiveVoices < 256);
-		char live[256];
-		memset(live, 0, mMaxActiveVoices);
-		unsigned int i, j;
-		for (i = 0; i < mMaxActiveVoices; i++)
+		for (j = 0; j < mMaxActiveVoices; j++)
 		{
-			for (j = 0; j < mMaxActiveVoices; j++)
+			if (mResampleDataOwner[i] && mResampleDataOwner[i] == mVoice[mActiveVoice[j]])
 			{
-				if (mResampleDataOwner[i] && mResampleDataOwner[i] == mVoice[mActiveVoice[j]])
-				{
-					live[i] |= 1; // Live channel
-					live[j] |= 2; // Live voice
-				}
+				live[i] |= 1; // Live channel
+				live[j] |= 2; // Live voice
 			}
 		}
+	}
 
-		for (i = 0; i < mMaxActiveVoices; i++)
+	for (i = 0; i < mMaxActiveVoices; i++)
+	{
+		if (!(live[i] & 1) && mResampleDataOwner[i]) // For all dead channels with owners..
 		{
-			if (!(live[i] & 1) && mResampleDataOwner[i]) // For all dead channels with owners..
-			{
-				mResampleDataOwner[i]->mResampleData[0] = 0;
-				mResampleDataOwner[i]->mResampleData[1] = 0;
-				mResampleDataOwner[i] = 0;
-			}
+			mResampleDataOwner[i]->mResampleData[0] = 0;
+			mResampleDataOwner[i]->mResampleData[1] = 0;
+			mResampleDataOwner[i] = 0;
 		}
+	}
 
-		int latestfree = 0;
-		for (i = 0; i < mActiveVoiceCount; i++)
+	int latestfree = 0;
+	for (i = 0; i < mActiveVoiceCount; i++)
+	{
+		if (!(live[i] & 2) && mVoice[mActiveVoice[i]]) // For all live voices with no channel..
 		{
-			if (!(live[i] & 2) && mVoice[mActiveVoice[i]]) // For all live voices with no channel..
+			int found = -1;
+			for (j = latestfree; found == -1 && j < mMaxActiveVoices; j++)
 			{
-				int found = -1;
-				for (j = latestfree; found == -1 && j < mMaxActiveVoices; j++)
+				if (mResampleDataOwner[j] == 0)
 				{
-					if (mResampleDataOwner[j] == 0)
-					{
-						found = j;
-					}
+					found = j;
 				}
-				SOLOUD_ASSERT(found != -1);
-				mResampleDataOwner[found] = mVoice[mActiveVoice[i]];
-				mResampleDataOwner[found]->mResampleData[0] = mResampleData[found * 2 + 0];
-				mResampleDataOwner[found]->mResampleData[1] = mResampleData[found * 2 + 1];
-				memset(mResampleDataOwner[found]->mResampleData[0], 0, sizeof(float) * SAMPLE_GRANULARITY * MAX_CHANNELS);
-				memset(mResampleDataOwner[found]->mResampleData[1], 0, sizeof(float) * SAMPLE_GRANULARITY * MAX_CHANNELS);
-				latestfree = found + 1;
 			}
+			SOLOUD_ASSERT(found != -1);
+			mResampleDataOwner[found] = mVoice[mActiveVoice[i]];
+			mResampleDataOwner[found]->mResampleData[0] = mResampleData[found * 2 + 0];
+			mResampleDataOwner[found]->mResampleData[1] = mResampleData[found * 2 + 1];
+			memset(mResampleDataOwner[found]->mResampleData[0], 0, sizeof(float) * SAMPLE_GRANULARITY * MAX_CHANNELS);
+			memset(mResampleDataOwner[found]->mResampleData[1], 0, sizeof(float) * SAMPLE_GRANULARITY * MAX_CHANNELS);
+			latestfree = found + 1;
 		}
 	}
+}
 
-	void Soloud::calcActiveVoices_internal()
-	{
-		// TODO: consider whether we need to re-evaluate the active voices all the time.
-		// It is a must when new voices are started, but otherwise we could get away
-		// with postponing it sometimes..
+void Soloud::calcActiveVoices_internal()
+{
+	// TODO: consider whether we need to re-evaluate the active voices all the time.
+	// It is a must when new voices are started, but otherwise we could get away
+	// with postponing it sometimes..
 
-		mActiveVoiceDirty = false;
+	mActiveVoiceDirty = false;
 
-		// Populate
-		unsigned int i, candidates, mustlive;
-		candidates = 0;
-		mustlive = 0;
-		for (i = 0; i < mHighestVoice; i++)
+	// Populate
+	unsigned int i, candidates, mustlive;
+	candidates = 0;
+	mustlive = 0;
+	for (i = 0; i < mHighestVoice; i++)
+	{
+		if (mVoice[i] &&
+		    (!(mVoice[i]->mFlags & (AudioSourceInstance::INAUDIBLE | AudioSourceInstance::PAUSED)) || (mVoice[i]->mFlags & AudioSourceInstance::INAUDIBLE_TICK)))
 		{
-			if (mVoice[i] && (!(mVoice[i]->mFlags & (AudioSourceInstance::INAUDIBLE | AudioSourceInstance::PAUSED)) || (mVoice[i]->mFlags & AudioSourceInstance::INAUDIBLE_TICK)))
+			mActiveVoice[candidates] = i;
+			candidates++;
+			if (mVoice[i]->mFlags & AudioSourceInstance::INAUDIBLE_TICK)
 			{
-				mActiveVoice[candidates] = i;
-				candidates++;
-				if (mVoice[i]->mFlags & AudioSourceInstance::INAUDIBLE_TICK)
-				{
-					mActiveVoice[candidates - 1] = mActiveVoice[mustlive];
-					mActiveVoice[mustlive] = i;
-					mustlive++;
-				}
+				mActiveVoice[candidates - 1] = mActiveVoice[mustlive];
+				mActiveVoice[mustlive] = i;
+				mustlive++;
 			}
 		}
+	}
 
-		// Check for early out
-		if (candidates <= mMaxActiveVoices)
-		{
-			// everything is audible, early out
-			mActiveVoiceCount = candidates;
-			mapResampleBuffers_internal();
-			return;
-		}
+	// Check for early out
+	if (candidates <= mMaxActiveVoices)
+	{
+		// everything is audible, early out
+		mActiveVoiceCount = candidates;
+		mapResampleBuffers_internal();
+		return;
+	}
 
-		mActiveVoiceCount = mMaxActiveVoices;
+	mActiveVoiceCount = mMaxActiveVoices;
 
-		if (mustlive >= mMaxActiveVoices)
-		{
-			// Oopsie. Well, nothing to sort, since the "must live" voices already
-			// ate all our active voice slots.
-			// This is a potentially an error situation, but we have no way to report
-			// error from here. And asserting could be bad, too.
-			return;
-		}
+	if (mustlive >= mMaxActiveVoices)
+	{
+		// Oopsie. Well, nothing to sort, since the "must live" voices already
+		// ate all our active voice slots.
+		// This is a potentially an error situation, but we have no way to report
+		// error from here. And asserting could be bad, too.
+		return;
+	}
+
+	// If we get this far, there's nothing to it: we'll have to sort the voices to find the most audible.
 
-		// If we get this far, there's nothing to it: we'll have to sort the voices to find the most audible.
-
-		// Iterative partial quicksort:
-		int left = 0, stack[24], pos = 0, right;
-		int len = candidates - mustlive;
-		unsigned int *data = mActiveVoice + mustlive;
-		int k = mActiveVoiceCount;
-		for (;;) 
-		{                                 
-			for (; left + 1 < len; len++) 
-			{                
-				if (pos == 24) len = stack[pos = 0]; 
-				int pivot = data[left];
-				float pivotvol = mVoice[pivot]->mOverallVolume;
-				stack[pos++] = len;      
-				for (right = left - 1;;) 
+	// Iterative partial quicksort:
+	int left = 0, stack[24], pos = 0, right;
+	int len = candidates - mustlive;
+	unsigned int *data = mActiveVoice + mustlive;
+	int k = mActiveVoiceCount;
+	for (;;)
+	{
+		for (; left + 1 < len; len++)
+		{
+			if (pos == 24)
+				len = stack[pos = 0];
+			int pivot = data[left];
+			float pivotvol = mVoice[pivot]->mOverallVolume;
+			stack[pos++] = len;
+			for (right = left - 1;;)
+			{
+				do
 				{
-					do 
-					{
-						right++;
-					} 
-					while (mVoice[data[right]]->mOverallVolume > pivotvol);
-					do
-					{
-						len--;
-					}
-					while (pivotvol > mVoice[data[len]]->mOverallVolume);
-					if (right >= len) break;       
-					int temp = data[right];
-					data[right] = data[len];
-					data[len] = temp;
-				}                        
+					right++;
+				} while (mVoice[data[right]]->mOverallVolume > pivotvol);
+				do
+				{
+					len--;
+				} while (pivotvol > mVoice[data[len]]->mOverallVolume);
+				if (right >= len)
+					break;
+				int temp = data[right];
+				data[right] = data[len];
+				data[len] = temp;
 			}
-			if (pos == 0) break;         
-			if (left >= k) break;
-			left = len;                  
-			len = stack[--pos];          
-		}	
-		// TODO: should the rest of the voices be flagged INAUDIBLE?
-		mapResampleBuffers_internal();
+		}
+		if (pos == 0)
+			break;
+		if (left >= k)
+			break;
+		left = len;
+		len = stack[--pos];
 	}
+	// TODO: should the rest of the voices be flagged INAUDIBLE?
+	mapResampleBuffers_internal();
+}
 
-	void Soloud::mix_internal(unsigned int aSamples, unsigned int aStride)
-	{
+void Soloud::mix_internal(unsigned int aSamples, unsigned int aStride)
+{
 #ifdef FLOATING_POINT_DEBUG
-		// This needs to be done in the audio thread as well..
-		static int done = 0;
-		if (!done)
-		{
-			unsigned int u;
-			u = _controlfp(0, 0);
-			u = u & ~(_EM_INVALID | /*_EM_DENORMAL |*/ _EM_ZERODIVIDE | _EM_OVERFLOW /*| _EM_UNDERFLOW  | _EM_INEXACT*/);
-			_controlfp(u, _MCW_EM);
-			done = 1;
-		}
+	// This needs to be done in the audio thread as well..
+	static int done = 0;
+	if (!done)
+	{
+		unsigned int u;
+		u = _controlfp(0, 0);
+		u = u & ~(_EM_INVALID | /*_EM_DENORMAL |*/ _EM_ZERODIVIDE | _EM_OVERFLOW /*| _EM_UNDERFLOW  | _EM_INEXACT*/);
+		_controlfp(u, _MCW_EM);
+		done = 1;
+	}
 #endif
 
 #ifdef __arm__
-		// flush to zero (FTZ) for ARM
+	// flush to zero (FTZ) for ARM
+	{
+		static bool once = false;
+		if (!once)
 		{
-			static bool once = false;
-			if (!once)
-			{
-				once = true;
-				asm( "vmsr fpscr,%0" :: "r" (1 << 24) );
-			}
+			once = true;
+			asm("vmsr fpscr,%0" ::"r"(1 << 24));
 		}
+	}
 #endif
 
 #ifdef _MCW_DN
+	{
+		static bool once = false;
+		if (!once)
 		{
-			static bool once = false;
-			if (!once)
+			once = true;
+			if (!(mFlags & NO_FPU_REGISTER_CHANGE))
 			{
-				once = true;
-				if (!(mFlags & NO_FPU_REGISTER_CHANGE))
-				{
-					_controlfp(_DN_FLUSH, _MCW_DN);
-				}
+				_controlfp(_DN_FLUSH, _MCW_DN);
 			}
 		}
+	}
 #endif
 
 #ifdef SOLOUD_SSE_INTRINSICS
+	{
+		static bool once = false;
+		if (!once)
 		{
-			static bool once = false;
-			if (!once)
+			once = true;
+			// Set denorm clear to zero (CTZ) and denorms are zero (DAZ) flags on.
+			// This causes all math to consider really tiny values as zero, which
+			// helps performance. I'd rather use constants from the sse headers,
+			// but for some reason the DAZ value is not defined there(!)
+			if (!(mFlags & NO_FPU_REGISTER_CHANGE))
 			{
-				once = true;
-				// Set denorm clear to zero (CTZ) and denorms are zero (DAZ) flags on.
-				// This causes all math to consider really tiny values as zero, which
-				// helps performance. I'd rather use constants from the sse headers,
-				// but for some reason the DAZ value is not defined there(!)
-				if (!(mFlags & NO_FPU_REGISTER_CHANGE))
-				{
-					_mm_setcsr(_mm_getcsr() | 0x8040);
-				}
+				_mm_setcsr(_mm_getcsr() | 0x8040);
 			}
 		}
+	}
 #endif
 
-		float buffertime = aSamples / (float)mSamplerate;
-		float globalVolume[2];
-		mStreamTime += buffertime;
-		mLastClockedTime = 0;
+	float buffertime = aSamples / (float)mSamplerate;
+	float globalVolume[2];
+	mStreamTime += buffertime;
+	mLastClockedTime = 0;
 
-		lockAudioMutex_internal();
+	lockAudioMutex_internal();
 
-		// Read and update global volume inside mutex
-		globalVolume[0] = mGlobalVolume;
-		if (mGlobalVolumeFader.mActive)
-		{
-			mGlobalVolume = mGlobalVolumeFader.get(mStreamTime);
-		}
-		globalVolume[1] = mGlobalVolume;
+	// Read and update global volume inside mutex
+	globalVolume[0] = mGlobalVolume;
+	if (mGlobalVolumeFader.mActive)
+	{
+		mGlobalVolume = mGlobalVolumeFader.get(mStreamTime);
+	}
+	globalVolume[1] = mGlobalVolume;
 
-		// Process faders. May change scratch size.
-		int i;
-		for (i = 0; i < (signed)mHighestVoice; i++)
+	// Process faders. May change scratch size.
+	int i;
+	for (i = 0; i < (signed)mHighestVoice; i++)
+	{
+		if (mVoice[i] && !(mVoice[i]->mFlags & AudioSourceInstance::PAUSED))
 		{
-			if (mVoice[i] && !(mVoice[i]->mFlags & AudioSourceInstance::PAUSED))
-			{
-				float volume[2];
+			float volume[2];
 
-				mVoice[i]->mActiveFader = 0;
+			mVoice[i]->mActiveFader = 0;
 
-				if (mGlobalVolumeFader.mActive > 0)
-				{
-					mVoice[i]->mActiveFader = 1;
-				}
+			if (mGlobalVolumeFader.mActive > 0)
+			{
+				mVoice[i]->mActiveFader = 1;
+			}
 
-				mVoice[i]->mStreamTime += buffertime;
-				mVoice[i]->mStreamPosition += (double)buffertime * (double)mVoice[i]->mOverallRelativePlaySpeed;
+			mVoice[i]->mStreamTime += buffertime;
+			mVoice[i]->mStreamPosition += (double)buffertime * (double)mVoice[i]->mOverallRelativePlaySpeed;
 
-				// TODO: this is actually unstable, because mStreamTime depends on the relative
-				// play speed. 
-				if (mVoice[i]->mRelativePlaySpeedFader.mActive > 0)
-				{
-					float speed = mVoice[i]->mRelativePlaySpeedFader.get(mVoice[i]->mStreamTime);
-					setVoiceRelativePlaySpeed_internal(i, speed);
-				}
+			// TODO: this is actually unstable, because mStreamTime depends on the relative
+			// play speed.
+			if (mVoice[i]->mRelativePlaySpeedFader.mActive > 0)
+			{
+				float speed = mVoice[i]->mRelativePlaySpeedFader.get(mVoice[i]->mStreamTime);
+				setVoiceRelativePlaySpeed_internal(i, speed);
+			}
 
-				volume[0] = mVoice[i]->mOverallVolume;
-				if (mVoice[i]->mVolumeFader.mActive > 0)
-				{
-					mVoice[i]->mSetVolume = mVoice[i]->mVolumeFader.get(mVoice[i]->mStreamTime);
-					mVoice[i]->mActiveFader = 1;
-					updateVoiceVolume_internal(i);
-					mActiveVoiceDirty = true;
-				}
-				volume[1] = mVoice[i]->mOverallVolume;
+			volume[0] = mVoice[i]->mOverallVolume;
+			if (mVoice[i]->mVolumeFader.mActive > 0)
+			{
+				mVoice[i]->mSetVolume = mVoice[i]->mVolumeFader.get(mVoice[i]->mStreamTime);
+				mVoice[i]->mActiveFader = 1;
+				updateVoiceVolume_internal(i);
+				mActiveVoiceDirty = true;
+			}
+			volume[1] = mVoice[i]->mOverallVolume;
 
-				if (mVoice[i]->mPanFader.mActive > 0)
-				{
-					float pan = mVoice[i]->mPanFader.get(mVoice[i]->mStreamTime);
-					setVoicePan_internal(i, pan);
-					mVoice[i]->mActiveFader = 1;
-				}
+			if (mVoice[i]->mPanFader.mActive > 0)
+			{
+				float pan = mVoice[i]->mPanFader.get(mVoice[i]->mStreamTime);
+				setVoicePan_internal(i, pan);
+				mVoice[i]->mActiveFader = 1;
+			}
 
-				if (mVoice[i]->mPauseScheduler.mActive)
+			if (mVoice[i]->mPauseScheduler.mActive)
+			{
+				mVoice[i]->mPauseScheduler.get(mVoice[i]->mStreamTime);
+				if (mVoice[i]->mPauseScheduler.mActive == -1)
 				{
-					mVoice[i]->mPauseScheduler.get(mVoice[i]->mStreamTime);
-					if (mVoice[i]->mPauseScheduler.mActive == -1)
-					{
-						mVoice[i]->mPauseScheduler.mActive = 0;
-						setVoicePause_internal(i, 1);
-					}
+					mVoice[i]->mPauseScheduler.mActive = 0;
+					setVoicePause_internal(i, 1);
 				}
+			}
 
-				if (mVoice[i]->mStopScheduler.mActive)
+			if (mVoice[i]->mStopScheduler.mActive)
+			{
+				mVoice[i]->mStopScheduler.get(mVoice[i]->mStreamTime);
+				if (mVoice[i]->mStopScheduler.mActive == -1)
 				{
-					mVoice[i]->mStopScheduler.get(mVoice[i]->mStreamTime);
-					if (mVoice[i]->mStopScheduler.mActive == -1)
-					{
-						mVoice[i]->mStopScheduler.mActive = 0;
-						stopVoice_internal(i);
-					}
+					mVoice[i]->mStopScheduler.mActive = 0;
+					stopVoice_internal(i);
 				}
 			}
 		}
+	}
 
-		if (mActiveVoiceDirty)
-			calcActiveVoices_internal();
+	if (mActiveVoiceDirty)
+		calcActiveVoices_internal();
 
-		mixBus_internal(mOutputScratch.mData, aSamples, aStride, mScratch.mData, 0, (float)mSamplerate, mChannels, mResampler);
+	mixBus_internal(mOutputScratch.mData, aSamples, aStride, mScratch.mData, 0, (float)mSamplerate, mChannels, mResampler);
 
-		for (i = 0; i < FILTERS_PER_STREAM; i++)
+	for (i = 0; i < FILTERS_PER_STREAM; i++)
+	{
+		if (mFilterInstance[i])
 		{
-			if (mFilterInstance[i])
-			{
-				mFilterInstance[i]->filter(mOutputScratch.mData, aSamples, aStride, mChannels, (float)mSamplerate, mStreamTime);
-			}
+			mFilterInstance[i]->filter(mOutputScratch.mData, aSamples, aStride, mChannels, (float)mSamplerate, mStreamTime);
 		}
+	}
 
-		unlockAudioMutex_internal();
-		
-		// Note: clipping channels*aStride, not channels*aSamples, so we're possibly clipping some unused data.
-		// The buffers should be large enough for it, we just may do a few bytes of unneccessary work.
-		clip_internal(mOutputScratch, mScratch, aStride, globalVolume[0], globalVolume[1]);
+	unlockAudioMutex_internal();
 
-		if (mFlags & ENABLE_VISUALIZATION)
+	// Note: clipping channels*aStride, not channels*aSamples, so we're possibly clipping some unused data.
+	// The buffers should be large enough for it, we just may do a few bytes of unneccessary work.
+	clip_internal(mOutputScratch, mScratch, aStride, globalVolume[0], globalVolume[1]);
+
+	if (mFlags & ENABLE_VISUALIZATION)
+	{
+		for (i = 0; i < MAX_CHANNELS; i++)
 		{
-			for (i = 0; i < MAX_CHANNELS; i++)
-			{
-				mVisualizationChannelVolume[i] = 0;
-			}
-			if (aSamples > 255)
+			mVisualizationChannelVolume[i] = 0;
+		}
+		if (aSamples > 255)
+		{
+			for (i = 0; i < 256; i++)
 			{
-				for (i = 0; i < 256; i++)
+				int j;
+				mVisualizationWaveData[i] = 0;
+				for (j = 0; j < (signed)mChannels; j++)
 				{
-					int j;
-					mVisualizationWaveData[i] = 0;
-					for (j = 0; j < (signed)mChannels; j++)
-					{
-						float sample = mScratch.mData[i + j * aStride];
-						float absvol = (float)fabs(sample);
-						if (mVisualizationChannelVolume[j] < absvol)
-							mVisualizationChannelVolume[j] = absvol;
-						mVisualizationWaveData[i] += sample;
-					}
+					float sample = mScratch.mData[i + j * aStride];
+					float absvol = (float)fabs(sample);
+					if (mVisualizationChannelVolume[j] < absvol)
+						mVisualizationChannelVolume[j] = absvol;
+					mVisualizationWaveData[i] += sample;
 				}
 			}
-			else
+		}
+		else
+		{
+			// Very unlikely failsafe branch
+			for (i = 0; i < 256; i++)
 			{
-				// Very unlikely failsafe branch
-				for (i = 0; i < 256; i++)
+				int j;
+				mVisualizationWaveData[i] = 0;
+				for (j = 0; j < (signed)mChannels; j++)
 				{
-					int j;
-					mVisualizationWaveData[i] = 0;
-					for (j = 0; j < (signed)mChannels; j++)
-					{
-						float sample = mScratch.mData[(i % aSamples) + j * aStride];
-						float absvol = (float)fabs(sample);
-						if (mVisualizationChannelVolume[j] < absvol)
-							mVisualizationChannelVolume[j] = absvol;
-						mVisualizationWaveData[i] += sample;
-					}
+					float sample = mScratch.mData[(i % aSamples) + j * aStride];
+					float absvol = (float)fabs(sample);
+					if (mVisualizationChannelVolume[j] < absvol)
+						mVisualizationChannelVolume[j] = absvol;
+					mVisualizationWaveData[i] += sample;
 				}
 			}
 		}
 	}
+}
 
-	void Soloud::mix(float *aBuffer, unsigned int aSamples)
-	{
-		unsigned int stride = (aSamples + 15) & ~0xf;
-		mix_internal(aSamples, stride);
-		interlace_samples_float(mScratch.mData, aBuffer, aSamples, mChannels, stride);
-	}
+void Soloud::mix(float *aBuffer, unsigned int aSamples)
+{
+	unsigned int stride = (aSamples + 15) & ~0xf;
+	mix_internal(aSamples, stride);
+	interlace_samples_float(mScratch.mData, aBuffer, aSamples, mChannels, stride);
+}
 
-	void Soloud::mixSigned16(short *aBuffer, unsigned int aSamples)
-	{
-		unsigned int stride = (aSamples + 15) & ~0xf;
-		mix_internal(aSamples, stride);
-		interlace_samples_s16(mScratch.mData, aBuffer, aSamples, mChannels, stride);
-	}
+void Soloud::mixSigned16(short *aBuffer, unsigned int aSamples)
+{
+	unsigned int stride = (aSamples + 15) & ~0xf;
+	mix_internal(aSamples, stride);
+	interlace_samples_s16(mScratch.mData, aBuffer, aSamples, mChannels, stride);
+}
 
-	void interlace_samples_float(const float *aSourceBuffer, float *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride)
+void interlace_samples_float(const float *aSourceBuffer, float *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride)
+{
+	// 111222 -> 121212
+	unsigned int i, j, c;
+	c = 0;
+	for (j = 0; j < aChannels; j++)
 	{
-		// 111222 -> 121212
-		unsigned int i, j, c;
-		c = 0;
-		for (j = 0; j < aChannels; j++)
+		c = j * aStride;
+		for (i = j; i < aSamples * aChannels; i += aChannels)
 		{
-			c = j * aStride;
-			for (i = j; i < aSamples * aChannels; i += aChannels)
-			{
-				aDestBuffer[i] = aSourceBuffer[c];
-				c++;
-			}
+			aDestBuffer[i] = aSourceBuffer[c];
+			c++;
 		}
 	}
+}
 
-	void interlace_samples_s16(const float *aSourceBuffer, short *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride)
+void interlace_samples_s16(const float *aSourceBuffer, short *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride)
+{
+	// 111222 -> 121212
+	unsigned int i, j, c;
+	c = 0;
+	for (j = 0; j < aChannels; j++)
 	{
-		// 111222 -> 121212
-		unsigned int i, j, c;
-		c = 0;
-		for (j = 0; j < aChannels; j++)
+		c = j * aStride;
+		for (i = j; i < aSamples * aChannels; i += aChannels)
 		{
-			c = j * aStride;
-			for (i = j; i < aSamples * aChannels; i += aChannels)
-			{
-				aDestBuffer[i] = (short)(aSourceBuffer[c] * 0x7fff);
-				c++;
-			}
+			aDestBuffer[i] = (short)(aSourceBuffer[c] * 0x7fff);
+			c++;
 		}
 	}
+}
 
-	void Soloud::lockAudioMutex_internal()
+void Soloud::lockAudioMutex_internal()
+{
+	if (mAudioThreadMutex)
 	{
-		if (mAudioThreadMutex)
-		{
-			Thread::lockMutex(mAudioThreadMutex);
-		}
-		SOLOUD_ASSERT(!mInsideAudioThreadMutex);
-		mInsideAudioThreadMutex = true;
+		Thread::lockMutex(mAudioThreadMutex);
 	}
+	SOLOUD_ASSERT(!mInsideAudioThreadMutex);
+	mInsideAudioThreadMutex = true;
+}
 
-	void Soloud::unlockAudioMutex_internal()
+void Soloud::unlockAudioMutex_internal()
+{
+	SOLOUD_ASSERT(mInsideAudioThreadMutex);
+	mInsideAudioThreadMutex = false;
+	if (mAudioThreadMutex)
 	{
-		SOLOUD_ASSERT(mInsideAudioThreadMutex);
-		mInsideAudioThreadMutex = false;
-		if (mAudioThreadMutex)
-		{
-			Thread::unlockMutex(mAudioThreadMutex);
-		}
+		Thread::unlockMutex(mAudioThreadMutex);
 	}
+}
 
-};
+}; // namespace SoLoud
diff --git a/src/core/soloud_audiosource.cpp b/src/core/soloud_audiosource.cpp
index 3123f8f..539941e 100644
--- a/src/core/soloud_audiosource.cpp
+++ b/src/core/soloud_audiosource.cpp
@@ -27,327 +27,322 @@ freely, subject to the following restrictions:
 namespace SoLoud
 {
 
-	AudioSourceInstance3dData::AudioSourceInstance3dData()
+AudioSourceInstance3dData::AudioSourceInstance3dData()
+{
+	m3dAttenuationModel = 0;
+	m3dAttenuationRolloff = 1;
+	m3dDopplerFactor = 1.0;
+	m3dMaxDistance = 1000000.0f;
+	m3dMinDistance = 0.0f;
+	m3dPosition[0] = 0;
+	m3dPosition[1] = 0;
+	m3dPosition[2] = 0;
+	m3dVelocity[0] = 0;
+	m3dVelocity[1] = 0;
+	m3dVelocity[2] = 0;
+	m3dVolume = 0;
+	mCollider = 0;
+	mColliderData = 0;
+	mAttenuator = 0;
+	mDopplerValue = 0;
+	mFlags = 0;
+	mHandle = 0;
+	for (int i = 0; i < MAX_CHANNELS; i++)
+		mChannelVolume[i] = 0;
+}
+
+void AudioSourceInstance3dData::init(AudioSource &aSource)
+{
+	m3dAttenuationModel = aSource.m3dAttenuationModel;
+	m3dAttenuationRolloff = aSource.m3dAttenuationRolloff;
+	m3dDopplerFactor = aSource.m3dDopplerFactor;
+	m3dMaxDistance = aSource.m3dMaxDistance;
+	m3dMinDistance = aSource.m3dMinDistance;
+	mCollider = aSource.mCollider;
+	mColliderData = aSource.mColliderData;
+	mAttenuator = aSource.mAttenuator;
+	m3dVolume = 1.0f;
+	mDopplerValue = 1.0f;
+}
+
+AudioSourceInstance::AudioSourceInstance()
+{
+	mPlayIndex = 0;
+	mFlags = 0;
+	mPan = 0;
+	// Default all volumes to 1.0 so sound behind N mix busses isn't super quiet.
+	int i;
+	for (i = 0; i < MAX_CHANNELS; i++)
+		mChannelVolume[i] = 1.0f;
+	mSetVolume = 1.0f;
+	mBaseSamplerate = 44100.0f;
+	mSamplerate = 44100.0f;
+	mSetRelativePlaySpeed = 1.0f;
+	mStreamTime = 0.0f;
+	mStreamPosition = 0.0f;
+	mAudioSourceID = 0;
+	mActiveFader = 0;
+	mChannels = 1;
+	mBusHandle = ~0u;
+	mLoopCount = 0;
+	mLoopPoint = 0;
+	for (i = 0; i < FILTERS_PER_STREAM; i++)
 	{
-		m3dAttenuationModel = 0;
-		m3dAttenuationRolloff = 1;
-		m3dDopplerFactor = 1.0;
-		m3dMaxDistance = 1000000.0f;
-		m3dMinDistance = 0.0f;
-		m3dPosition[0] = 0;
-		m3dPosition[1] = 0;
-		m3dPosition[2] = 0;
-		m3dVelocity[0] = 0;
-		m3dVelocity[1] = 0;
-		m3dVelocity[2] = 0;
-		m3dVolume = 0;
-		mCollider = 0;
-		mColliderData = 0;
-		mAttenuator = 0;
-		mDopplerValue = 0;
-		mFlags = 0;
-		mHandle = 0;
-		for (int i = 0; i < MAX_CHANNELS; i++)
-			mChannelVolume[i] = 0;
+		mFilter[i] = NULL;
 	}
-
-	void AudioSourceInstance3dData::init(AudioSource &aSource)
+	for (i = 0; i < MAX_CHANNELS; i++)
 	{
-		m3dAttenuationModel = aSource.m3dAttenuationModel;
-		m3dAttenuationRolloff = aSource.m3dAttenuationRolloff;
-		m3dDopplerFactor = aSource.m3dDopplerFactor;
-		m3dMaxDistance = aSource.m3dMaxDistance;
-		m3dMinDistance = aSource.m3dMinDistance;
-		mCollider = aSource.mCollider;
-		mColliderData = aSource.mColliderData;
-		mAttenuator = aSource.mAttenuator;
-		m3dVolume = 1.0f;
-		mDopplerValue = 1.0f;
+		mCurrentChannelVolume[i] = 0;
 	}
-
-	AudioSourceInstance::AudioSourceInstance()
+	// behind pointers because we swap between the two buffers
+	mResampleData[0] = 0;
+	mResampleData[1] = 0;
+	mSrcOffset = 0;
+	mLeftoverSamples = 0;
+	mDelaySamples = 0;
+	mOverallVolume = 0;
+	mOverallRelativePlaySpeed = 1;
+}
+
+AudioSourceInstance::~AudioSourceInstance()
+{
+	int i;
+	for (i = 0; i < FILTERS_PER_STREAM; i++)
 	{
-		mPlayIndex = 0;
-		mFlags = 0;
-		mPan = 0;
-		// Default all volumes to 1.0 so sound behind N mix busses isn't super quiet.
-		int i;
-		for (i = 0; i < MAX_CHANNELS; i++)
-			mChannelVolume[i] = 1.0f;		
-		mSetVolume = 1.0f;
-		mBaseSamplerate = 44100.0f;
-		mSamplerate = 44100.0f;
-		mSetRelativePlaySpeed = 1.0f;
-		mStreamTime = 0.0f;
-		mStreamPosition = 0.0f;
-		mAudioSourceID = 0;
-		mActiveFader = 0;
-		mChannels = 1;
-		mBusHandle = ~0u;
-		mLoopCount = 0;
-		mLoopPoint = 0;
-		for (i = 0; i < FILTERS_PER_STREAM; i++)
-		{
-			mFilter[i] = NULL;
-		}
-		for (i = 0; i < MAX_CHANNELS; i++)
-		{
-			mCurrentChannelVolume[i] = 0;
-		}
-		// behind pointers because we swap between the two buffers
-		mResampleData[0] = 0;
-		mResampleData[1] = 0;
-		mSrcOffset = 0;
-		mLeftoverSamples = 0;
-		mDelaySamples = 0;
-		mOverallVolume = 0;
-		mOverallRelativePlaySpeed = 1;
+		delete mFilter[i];
 	}
+}
 
-	AudioSourceInstance::~AudioSourceInstance()
+void AudioSourceInstance::init(AudioSource &aSource, int aPlayIndex)
+{
+	mPlayIndex = aPlayIndex;
+	mBaseSamplerate = aSource.mBaseSamplerate;
+	mSamplerate = mBaseSamplerate;
+	mChannels = aSource.mChannels;
+	mStreamTime = 0.0f;
+	mStreamPosition = 0.0f;
+	mLoopPoint = aSource.mLoopPoint;
+
+	if (aSource.mFlags & AudioSource::SHOULD_LOOP)
 	{
-		int i;
-		for (i = 0; i < FILTERS_PER_STREAM; i++)
-		{
-			delete mFilter[i];
-		}		
+		mFlags |= AudioSourceInstance::LOOPING;
 	}
-
-	void AudioSourceInstance::init(AudioSource &aSource, int aPlayIndex)
+	if (aSource.mFlags & AudioSource::PROCESS_3D)
 	{
-		mPlayIndex = aPlayIndex;
-		mBaseSamplerate = aSource.mBaseSamplerate;
-		mSamplerate = mBaseSamplerate;
-		mChannels = aSource.mChannels;
-		mStreamTime = 0.0f;
-		mStreamPosition = 0.0f;
-		mLoopPoint = aSource.mLoopPoint;
-
-		if (aSource.mFlags & AudioSource::SHOULD_LOOP)
-		{
-			mFlags |= AudioSourceInstance::LOOPING;
-		}
-		if (aSource.mFlags & AudioSource::PROCESS_3D)
-		{
-			mFlags |= AudioSourceInstance::PROCESS_3D;
-		}
-		if (aSource.mFlags & AudioSource::LISTENER_RELATIVE)
-		{
-			mFlags |= AudioSourceInstance::LISTENER_RELATIVE;
-		}
-		if (aSource.mFlags & AudioSource::INAUDIBLE_KILL)
-		{
-			mFlags |= AudioSourceInstance::INAUDIBLE_KILL;
-		}
-		if (aSource.mFlags & AudioSource::INAUDIBLE_TICK)
-		{
-			mFlags |= AudioSourceInstance::INAUDIBLE_TICK;
-		}
-		if (aSource.mFlags & AudioSource::DISABLE_AUTOSTOP)
-		{
-			mFlags |= AudioSourceInstance::DISABLE_AUTOSTOP;
-		}
+		mFlags |= AudioSourceInstance::PROCESS_3D;
 	}
-
-	result AudioSourceInstance::rewind()
+	if (aSource.mFlags & AudioSource::LISTENER_RELATIVE)
 	{
-		return NOT_IMPLEMENTED;
+		mFlags |= AudioSourceInstance::LISTENER_RELATIVE;
 	}
-
-	result AudioSourceInstance::seek(double aSeconds, float *mScratch, unsigned int mScratchSize)
+	if (aSource.mFlags & AudioSource::INAUDIBLE_KILL)
 	{
-		double offset = aSeconds - mStreamPosition;
-		if (offset <= 0)
-		{
-			if (rewind() != SO_NO_ERROR)
-			{
-				// can't do generic seek backwards unless we can rewind.
-				return NOT_IMPLEMENTED;
-			}
-			offset = aSeconds;
-		}
-		int samples_to_discard = (int)floor(mSamplerate * offset);
-
-		while (samples_to_discard)
-		{
-			int samples = mScratchSize / mChannels;
-			if (samples > samples_to_discard)
-				samples = samples_to_discard;
-			getAudio(mScratch, samples, samples);
-			samples_to_discard -= samples;
-		}
-		mStreamPosition = aSeconds;
-		return SO_NO_ERROR;
+		mFlags |= AudioSourceInstance::INAUDIBLE_KILL;
 	}
+	if (aSource.mFlags & AudioSource::INAUDIBLE_TICK)
+	{
+		mFlags |= AudioSourceInstance::INAUDIBLE_TICK;
+	}
+	if (aSource.mFlags & AudioSource::DISABLE_AUTOSTOP)
+	{
+		mFlags |= AudioSourceInstance::DISABLE_AUTOSTOP;
+	}
+}
 
+result AudioSourceInstance::rewind()
+{
+	return NOT_IMPLEMENTED;
+}
 
-	AudioSource::AudioSource() 
-	{ 
-		int i;
-		for (i = 0; i < FILTERS_PER_STREAM; i++)
+result AudioSourceInstance::seek(double aSeconds, float *mScratch, unsigned int mScratchSize)
+{
+	double offset = aSeconds - mStreamPosition;
+	if (offset <= 0)
+	{
+		if (rewind() != SO_NO_ERROR)
 		{
-			mFilter[i] = 0;
+			// can't do generic seek backwards unless we can rewind.
+			return NOT_IMPLEMENTED;
 		}
-		mFlags = 0; 
-		mBaseSamplerate = 44100; 
-		mAudioSourceID = 0;
-		mSoloud = 0;
-		mChannels = 1;
-		m3dMinDistance = 1;
-		m3dMaxDistance = 1000000.0f;
-		m3dAttenuationRolloff = 1.0f;
-		m3dAttenuationModel = NO_ATTENUATION;
-		m3dDopplerFactor = 1.0f;
-		mCollider = 0;
-		mAttenuator = 0;
-		mColliderData = 0;
-		mVolume = 1;
-		mLoopPoint = 0;
+		offset = aSeconds;
 	}
+	int samples_to_discard = (int)floor(mSamplerate * offset);
 
-	AudioSource::~AudioSource() 
+	while (samples_to_discard)
 	{
-		stop();
+		int samples = mScratchSize / mChannels;
+		if (samples > samples_to_discard)
+			samples = samples_to_discard;
+		getAudio(mScratch, samples, samples);
+		samples_to_discard -= samples;
 	}
+	mStreamPosition = aSeconds;
+	return SO_NO_ERROR;
+}
 
-	void AudioSource::setVolume(float aVolume)
+AudioSource::AudioSource()
+{
+	int i;
+	for (i = 0; i < FILTERS_PER_STREAM; i++)
 	{
-		mVolume = aVolume;
+		mFilter[i] = 0;
 	}
+	mFlags = 0;
+	mBaseSamplerate = 44100;
+	mAudioSourceID = 0;
+	mSoloud = 0;
+	mChannels = 1;
+	m3dMinDistance = 1;
+	m3dMaxDistance = 1000000.0f;
+	m3dAttenuationRolloff = 1.0f;
+	m3dAttenuationModel = NO_ATTENUATION;
+	m3dDopplerFactor = 1.0f;
+	mCollider = 0;
+	mAttenuator = 0;
+	mColliderData = 0;
+	mVolume = 1;
+	mLoopPoint = 0;
+}
+
+AudioSource::~AudioSource()
+{
+	stop();
+}
 
-	void AudioSource::setLoopPoint(time aLoopPoint)
-	{
-		mLoopPoint = aLoopPoint;
-	}
+void AudioSource::setVolume(float aVolume)
+{
+	mVolume = aVolume;
+}
 
-	time AudioSource::getLoopPoint()
-	{
-		return mLoopPoint;
-	}
+void AudioSource::setLoopPoint(time aLoopPoint)
+{
+	mLoopPoint = aLoopPoint;
+}
 
-	void AudioSource::setLooping(bool aLoop)
-	{
-		if (aLoop)
-		{
-			mFlags |= SHOULD_LOOP;
-		}
-		else
-		{
-			mFlags &= ~SHOULD_LOOP;
-		}
-	}
+time AudioSource::getLoopPoint()
+{
+	return mLoopPoint;
+}
 
-	void AudioSource::setSingleInstance(bool aSingleInstance)
+void AudioSource::setLooping(bool aLoop)
+{
+	if (aLoop)
 	{
-		if (aSingleInstance)
-		{
-			mFlags |= SINGLE_INSTANCE;
-		}
-		else
-		{
-			mFlags &= ~SINGLE_INSTANCE;
-		}
+		mFlags |= SHOULD_LOOP;
 	}
-
-	void AudioSource::setAutoStop(bool aAutoStop)
+	else
 	{
-		if (aAutoStop)
-		{
-			mFlags &= ~DISABLE_AUTOSTOP;
-		}
-		else
-		{
-			mFlags |= DISABLE_AUTOSTOP;
-		}
+		mFlags &= ~SHOULD_LOOP;
 	}
+}
 
-	void AudioSource::setFilter(unsigned int aFilterId, Filter *aFilter)
+void AudioSource::setSingleInstance(bool aSingleInstance)
+{
+	if (aSingleInstance)
 	{
-		if (aFilterId >= FILTERS_PER_STREAM)
-			return;
-		mFilter[aFilterId] = aFilter;
+		mFlags |= SINGLE_INSTANCE;
 	}
-
-	void AudioSource::stop()
+	else
 	{
-		if (mSoloud)
-		{
-			mSoloud->stopAudioSource(*this);
-		}
+		mFlags &= ~SINGLE_INSTANCE;
 	}
+}
 
-	void AudioSource::set3dMinMaxDistance(float aMinDistance, float aMaxDistance)
+void AudioSource::setAutoStop(bool aAutoStop)
+{
+	if (aAutoStop)
 	{
-		m3dMinDistance = aMinDistance;
-		m3dMaxDistance = aMaxDistance;
+		mFlags &= ~DISABLE_AUTOSTOP;
 	}
-
-	void AudioSource::set3dAttenuation(unsigned int aAttenuationModel, float aAttenuationRolloffFactor)
+	else
 	{
-		m3dAttenuationModel = aAttenuationModel;
-		m3dAttenuationRolloff = aAttenuationRolloffFactor;
+		mFlags |= DISABLE_AUTOSTOP;
 	}
+}
 
-	void AudioSource::set3dDopplerFactor(float aDopplerFactor)
-	{
-		m3dDopplerFactor = aDopplerFactor;
-	}
+void AudioSource::setFilter(unsigned int aFilterId, Filter *aFilter)
+{
+	if (aFilterId >= FILTERS_PER_STREAM)
+		return;
+	mFilter[aFilterId] = aFilter;
+}
 
-	void AudioSource::set3dListenerRelative(bool aListenerRelative)
+void AudioSource::stop()
+{
+	if (mSoloud)
 	{
-		if (aListenerRelative)
-		{
-			mFlags |= LISTENER_RELATIVE;
-		}
-		else
-		{
-			mFlags &= ~LISTENER_RELATIVE;
-		}
+		mSoloud->stopAudioSource(*this);
 	}
+}
 
+void AudioSource::set3dMinMaxDistance(float aMinDistance, float aMaxDistance)
+{
+	m3dMinDistance = aMinDistance;
+	m3dMaxDistance = aMaxDistance;
+}
+
+void AudioSource::set3dAttenuation(unsigned int aAttenuationModel, float aAttenuationRolloffFactor)
+{
+	m3dAttenuationModel = aAttenuationModel;
+	m3dAttenuationRolloff = aAttenuationRolloffFactor;
+}
 
-	void AudioSource::set3dDistanceDelay(bool aDistanceDelay)
+void AudioSource::set3dDopplerFactor(float aDopplerFactor)
+{
+	m3dDopplerFactor = aDopplerFactor;
+}
+
+void AudioSource::set3dListenerRelative(bool aListenerRelative)
+{
+	if (aListenerRelative)
 	{
-		if (aDistanceDelay)
-		{
-			mFlags |= DISTANCE_DELAY;
-		}
-		else
-		{
-			mFlags &= ~DISTANCE_DELAY;
-		}
+		mFlags |= LISTENER_RELATIVE;
 	}
-
-	void AudioSource::set3dCollider(AudioCollider *aCollider, int aUserData)
+	else
 	{
-		mCollider = aCollider;
-		mColliderData = aUserData;
+		mFlags &= ~LISTENER_RELATIVE;
 	}
+}
 
-	void AudioSource::set3dAttenuator(AudioAttenuator *aAttenuator)
+void AudioSource::set3dDistanceDelay(bool aDistanceDelay)
+{
+	if (aDistanceDelay)
 	{
-		mAttenuator = aAttenuator;
+		mFlags |= DISTANCE_DELAY;
 	}
-
-	void AudioSource::setInaudibleBehavior(bool aMustTick, bool aKill)
+	else
 	{
-		mFlags &= ~(AudioSource::INAUDIBLE_KILL | AudioSource::INAUDIBLE_TICK);
-		if (aMustTick)
-		{
-			mFlags |= AudioSource::INAUDIBLE_TICK;
-		}
-		if (aKill)
-		{
-			mFlags |= AudioSource::INAUDIBLE_KILL;
-		}
+		mFlags &= ~DISTANCE_DELAY;
 	}
+}
+
+void AudioSource::set3dCollider(AudioCollider *aCollider, int aUserData)
+{
+	mCollider = aCollider;
+	mColliderData = aUserData;
+}
 
+void AudioSource::set3dAttenuator(AudioAttenuator *aAttenuator)
+{
+	mAttenuator = aAttenuator;
+}
 
-	float AudioSourceInstance::getInfo(unsigned int /*aInfoKey*/)
+void AudioSource::setInaudibleBehavior(bool aMustTick, bool aKill)
+{
+	mFlags &= ~(AudioSource::INAUDIBLE_KILL | AudioSource::INAUDIBLE_TICK);
+	if (aMustTick)
 	{
-	    return 0;
+		mFlags |= AudioSource::INAUDIBLE_TICK;
 	}
+	if (aKill)
+	{
+		mFlags |= AudioSource::INAUDIBLE_KILL;
+	}
+}
 
+float AudioSourceInstance::getInfo(unsigned int /*aInfoKey*/)
+{
+	return 0;
+}
 
-};
-
+}; // namespace SoLoud
diff --git a/src/core/soloud_core_getters.cpp b/src/core/soloud_core_getters.cpp
index 2fca9a6..0cdc6ff 100644
--- a/src/core/soloud_core_getters.cpp
+++ b/src/core/soloud_core_getters.cpp
@@ -28,368 +28,365 @@ freely, subject to the following restrictions:
 
 namespace SoLoud
 {
-	unsigned int Soloud::getVersion() const
-	{
-		return SOLOUD_VERSION;
-	}
+unsigned int Soloud::getVersion() const
+{
+	return SOLOUD_VERSION;
+}
 
-	float Soloud::getPostClipScaler() const
-	{
-		return mPostClipScaler;
-	}
+float Soloud::getPostClipScaler() const
+{
+	return mPostClipScaler;
+}
 
-	unsigned int Soloud::getMainResampler() const
-	{
-		return mResampler;
-	}
+unsigned int Soloud::getMainResampler() const
+{
+	return mResampler;
+}
+
+float Soloud::getGlobalVolume() const
+{
+	return mGlobalVolume;
+}
+
+handle Soloud::getHandleFromVoice_internal(unsigned int aVoice) const
+{
+	if (mVoice[aVoice] == 0)
+		return 0;
+	return (aVoice + 1) | (mVoice[aVoice]->mPlayIndex << 12);
+}
 
-	float Soloud::getGlobalVolume() const
+int Soloud::getVoiceFromHandle_internal(handle aVoiceHandle) const
+{
+	// If this is a voice group handle, pick the first handle from the group
+	handle *h = voiceGroupHandleToArray_internal(aVoiceHandle);
+	if (h != NULL)
+		aVoiceHandle = *h;
+
+	if (aVoiceHandle == 0)
 	{
-		return mGlobalVolume;
+		return -1;
 	}
 
-	handle Soloud::getHandleFromVoice_internal(unsigned int aVoice) const
+	int ch = (aVoiceHandle & 0xfff) - 1;
+	unsigned int idx = aVoiceHandle >> 12;
+	if (mVoice[ch] && (mVoice[ch]->mPlayIndex & 0xfffff) == idx)
 	{
-		if (mVoice[aVoice] == 0)
-			return 0;
-		return (aVoice + 1) | (mVoice[aVoice]->mPlayIndex << 12);
+		return ch;
 	}
+	return -1;
+}
 
-	int Soloud::getVoiceFromHandle_internal(handle aVoiceHandle) const
-	{
-		// If this is a voice group handle, pick the first handle from the group
-		handle *h = voiceGroupHandleToArray_internal(aVoiceHandle);
-		if (h != NULL) aVoiceHandle = *h;
+unsigned int Soloud::getMaxActiveVoiceCount() const
+{
+	return mMaxActiveVoices;
+}
 
-		if (aVoiceHandle == 0) 
-		{
-			return -1;
-		}
+unsigned int Soloud::getActiveVoiceCount()
+{
+	lockAudioMutex_internal();
+	if (mActiveVoiceDirty)
+		calcActiveVoices_internal();
+	unsigned int c = mActiveVoiceCount;
+	unlockAudioMutex_internal();
+	return c;
+}
 
-		int ch = (aVoiceHandle & 0xfff) - 1;
-		unsigned int idx = aVoiceHandle >> 12;
-		if (mVoice[ch] &&
-			(mVoice[ch]->mPlayIndex & 0xfffff) == idx)
+unsigned int Soloud::getVoiceCount()
+{
+	lockAudioMutex_internal();
+	int i;
+	int c = 0;
+	for (i = 0; i < (signed)mHighestVoice; i++)
+	{
+		if (mVoice[i])
 		{
-			return ch;
+			c++;
 		}
-		return -1;		
 	}
+	unlockAudioMutex_internal();
+	return c;
+}
 
-	unsigned int Soloud::getMaxActiveVoiceCount() const
-	{
-		return mMaxActiveVoices;
-	}
+bool Soloud::isValidVoiceHandle(handle aVoiceHandle)
+{
+	// voice groups are not valid voice handles
+	if ((aVoiceHandle & 0xfffff000) == 0xfffff000)
+		return 0;
 
-	unsigned int Soloud::getActiveVoiceCount()
+	lockAudioMutex_internal();
+	if (getVoiceFromHandle_internal(aVoiceHandle) != -1)
 	{
-		lockAudioMutex_internal();
-		if (mActiveVoiceDirty)
-			calcActiveVoices_internal();
-		unsigned int c = mActiveVoiceCount;
 		unlockAudioMutex_internal();
-		return c;
+		return 1;
 	}
+	unlockAudioMutex_internal();
+	return 0;
+}
 
-	unsigned int Soloud::getVoiceCount()
+time Soloud::getLoopPoint(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int i;
-		int c = 0;
-		for (i = 0; i < (signed)mHighestVoice; i++)
-		{
-			if (mVoice[i]) 
-			{
-				c++;
-			}
-		}
 		unlockAudioMutex_internal();
-		return c;
+		return 0;
 	}
+	time v = mVoice[ch]->mLoopPoint;
+	unlockAudioMutex_internal();
+	return v;
+}
 
-	bool Soloud::isValidVoiceHandle(handle aVoiceHandle)
+bool Soloud::getLooping(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		// voice groups are not valid voice handles
-		if ((aVoiceHandle & 0xfffff000) == 0xfffff000)
-			return 0;
-
-		lockAudioMutex_internal();
-		if (getVoiceFromHandle_internal(aVoiceHandle) != -1)
-		{
-			unlockAudioMutex_internal();
-			return 1;
-		}
 		unlockAudioMutex_internal();
 		return 0;
 	}
+	bool v = (mVoice[ch]->mFlags & AudioSourceInstance::LOOPING) != 0;
+	unlockAudioMutex_internal();
+	return v;
+}
 
-
-	time Soloud::getLoopPoint(handle aVoiceHandle)
+bool Soloud::getAutoStop(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1)
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		time v = mVoice[ch]->mLoopPoint;
 		unlockAudioMutex_internal();
-		return v;
+		return 0;
 	}
+	bool v = (mVoice[ch]->mFlags & AudioSourceInstance::DISABLE_AUTOSTOP) != 0;
+	unlockAudioMutex_internal();
+	return !v;
+}
 
-	bool Soloud::getLooping(handle aVoiceHandle)
+float Soloud::getInfo(handle aVoiceHandle, unsigned int mInfoKey)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1)
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		bool v = (mVoice[ch]->mFlags & AudioSourceInstance::LOOPING) != 0;
 		unlockAudioMutex_internal();
-		return v;
+		return 0;
 	}
+	float v = mVoice[ch]->getInfo(mInfoKey);
+	unlockAudioMutex_internal();
+	return v;
+}
 
-	bool Soloud::getAutoStop(handle aVoiceHandle)
+float Soloud::getVolume(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1)
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		bool v = (mVoice[ch]->mFlags & AudioSourceInstance::DISABLE_AUTOSTOP) != 0;
 		unlockAudioMutex_internal();
-		return !v;
+		return 0;
 	}
+	float v = mVoice[ch]->mSetVolume;
+	unlockAudioMutex_internal();
+	return v;
+}
 
-	float Soloud::getInfo(handle aVoiceHandle, unsigned int mInfoKey)
+float Soloud::getOverallVolume(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1)
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		float v = mVoice[ch]->getInfo(mInfoKey);
 		unlockAudioMutex_internal();
-		return v;
+		return 0;
 	}
+	float v = mVoice[ch]->mOverallVolume;
+	unlockAudioMutex_internal();
+	return v;
+}
 
-	float Soloud::getVolume(handle aVoiceHandle)
+float Soloud::getPan(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1) 
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		float v = mVoice[ch]->mSetVolume;
 		unlockAudioMutex_internal();
-		return v;
+		return 0;
 	}
+	float v = mVoice[ch]->mPan;
+	unlockAudioMutex_internal();
+	return v;
+}
 
-	float Soloud::getOverallVolume(handle aVoiceHandle)
+time Soloud::getStreamTime(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1)
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		float v = mVoice[ch]->mOverallVolume;
 		unlockAudioMutex_internal();
-		return v;
+		return 0;
 	}
+	double v = mVoice[ch]->mStreamTime;
+	unlockAudioMutex_internal();
+	return v;
+}
 
-	float Soloud::getPan(handle aVoiceHandle)
+time Soloud::getStreamPosition(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1) 
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		float v = mVoice[ch]->mPan;
 		unlockAudioMutex_internal();
-		return v;
+		return 0;
 	}
+	double v = mVoice[ch]->mStreamPosition;
+	unlockAudioMutex_internal();
+	return v;
+}
 
-	time Soloud::getStreamTime(handle aVoiceHandle)
+float Soloud::getRelativePlaySpeed(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1) 
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		double v = mVoice[ch]->mStreamTime;
 		unlockAudioMutex_internal();
-		return v;
+		return 1;
 	}
+	float v = mVoice[ch]->mSetRelativePlaySpeed;
+	unlockAudioMutex_internal();
+	return v;
+}
 
-	time Soloud::getStreamPosition(handle aVoiceHandle)
+float Soloud::getSamplerate(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1)
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		double v = mVoice[ch]->mStreamPosition;
 		unlockAudioMutex_internal();
-		return v;
+		return 0;
 	}
+	float v = mVoice[ch]->mBaseSamplerate;
+	unlockAudioMutex_internal();
+	return v;
+}
 
-	float Soloud::getRelativePlaySpeed(handle aVoiceHandle)
+bool Soloud::getPause(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1) 
-		{
-			unlockAudioMutex_internal();
-			return 1;
-		}
-		float v = mVoice[ch]->mSetRelativePlaySpeed;
 		unlockAudioMutex_internal();
-		return v;
+		return 0;
 	}
+	int v = !!(mVoice[ch]->mFlags & AudioSourceInstance::PAUSED);
+	unlockAudioMutex_internal();
+	return v != 0;
+}
 
-	float Soloud::getSamplerate(handle aVoiceHandle)
+bool Soloud::getProtectVoice(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1) 
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		float v = mVoice[ch]->mBaseSamplerate;
 		unlockAudioMutex_internal();
-		return v;
+		return 0;
 	}
+	int v = !!(mVoice[ch]->mFlags & AudioSourceInstance::PROTECTED);
+	unlockAudioMutex_internal();
+	return v != 0;
+}
 
-	bool Soloud::getPause(handle aVoiceHandle)
-	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1) 
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		int v = !!(mVoice[ch]->mFlags & AudioSourceInstance::PAUSED);
-		unlockAudioMutex_internal();
-		return v != 0;
-	}
+int Soloud::findFreeVoice_internal()
+{
+	int i;
+	unsigned int lowest_play_index_value = 0xffffffff;
+	int lowest_play_index = -1;
 
-	bool Soloud::getProtectVoice(handle aVoiceHandle)
-	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1) 
-		{
-			unlockAudioMutex_internal();
-			return 0;
-		}
-		int v = !!(mVoice[ch]->mFlags & AudioSourceInstance::PROTECTED);
-		unlockAudioMutex_internal();
-		return v != 0;
-	}
+	// (slowly) drag the highest active voice index down
+	if (mHighestVoice > 0 && mVoice[mHighestVoice - 1] == NULL)
+		mHighestVoice--;
 
-	int Soloud::findFreeVoice_internal()
+	for (i = 0; i < VOICE_COUNT; i++)
 	{
-		int i;
-		unsigned int lowest_play_index_value = 0xffffffff;
-		int lowest_play_index = -1;
-		
-		// (slowly) drag the highest active voice index down
-		if (mHighestVoice > 0 && mVoice[mHighestVoice - 1] == NULL)
-			mHighestVoice--;
-		
-		for (i = 0; i < VOICE_COUNT; i++)
+		if (mVoice[i] == NULL)
 		{
-			if (mVoice[i] == NULL)
-			{
-				if (i+1 > (signed)mHighestVoice)
-				{
-					mHighestVoice = i + 1;
-				}
-				return i;
-			}
-			if (((mVoice[i]->mFlags & AudioSourceInstance::PROTECTED) == 0) && 
-				mVoice[i]->mPlayIndex < lowest_play_index_value)
+			if (i + 1 > (signed)mHighestVoice)
 			{
-				lowest_play_index_value = mVoice[i]->mPlayIndex;
-				lowest_play_index = i;
+				mHighestVoice = i + 1;
 			}
+			return i;
 		}
-		stopVoice_internal(lowest_play_index);
-		return lowest_play_index;
-	}
-
-	unsigned int Soloud::getLoopCount(handle aVoiceHandle)
-	{
-		lockAudioMutex_internal();
-		int ch = getVoiceFromHandle_internal(aVoiceHandle);
-		if (ch == -1) 
+		if (((mVoice[i]->mFlags & AudioSourceInstance::PROTECTED) == 0) && mVoice[i]->mPlayIndex < lowest_play_index_value)
 		{
-			unlockAudioMutex_internal();
-			return 0;
+			lowest_play_index_value = mVoice[i]->mPlayIndex;
+			lowest_play_index = i;
 		}
-		int v = mVoice[ch]->mLoopCount;
-		unlockAudioMutex_internal();
-		return v;
 	}
+	stopVoice_internal(lowest_play_index);
+	return lowest_play_index;
+}
 
-	// Returns current backend ID
-	unsigned int Soloud::getBackendId()
+unsigned int Soloud::getLoopCount(handle aVoiceHandle)
+{
+	lockAudioMutex_internal();
+	int ch = getVoiceFromHandle_internal(aVoiceHandle);
+	if (ch == -1)
 	{
-		return mBackendID;
-
+		unlockAudioMutex_internal();
+		return 0;
 	}
+	int v = mVoice[ch]->mLoopCount;
+	unlockAudioMutex_internal();
+	return v;
+}
 
-	// Returns current backend string
-	const char * Soloud::getBackendString()
-	{
-		return mBackendString;
-	}
+// Returns current backend ID
+unsigned int Soloud::getBackendId()
+{
+	return mBackendID;
+}
 
-	// Returns current backend channel count (1 mono, 2 stereo, etc)
-	unsigned int Soloud::getBackendChannels()
-	{
-		return mChannels;
-	}
+// Returns current backend string
+const char *Soloud::getBackendString()
+{
+	return mBackendString;
+}
 
-	// Returns current backend sample rate
-	unsigned int Soloud::getBackendSamplerate()
-	{
-		return mSamplerate;
-	}
+// Returns current backend channel count (1 mono, 2 stereo, etc)
+unsigned int Soloud::getBackendChannels()
+{
+	return mChannels;
+}
 
-	// Returns current backend buffer size
-	unsigned int Soloud::getBackendBufferSize()
-	{
-		return mBufferSize;
-	}
+// Returns current backend sample rate
+unsigned int Soloud::getBackendSamplerate()
+{
+	return mSamplerate;
+}
 
-	// Get speaker position in 3d space
-	result Soloud::getSpeakerPosition(unsigned int aChannel, float &aX, float &aY, float &aZ)
-	{
-		if (aChannel >= mChannels)
-			return INVALID_PARAMETER;
-		aX = m3dSpeakerPosition[3 * aChannel + 0];
-		aY = m3dSpeakerPosition[3 * aChannel + 1];
-		aZ = m3dSpeakerPosition[3 * aChannel + 2];
-		return SO_NO_ERROR;
-	}
+// Returns current backend buffer size
+unsigned int Soloud::getBackendBufferSize()
+{
+	return mBufferSize;
+}
+
+// Get speaker position in 3d space
+result Soloud::getSpeakerPosition(unsigned int aChannel, float &aX, float &aY, float &aZ)
+{
+	if (aChannel >= mChannels)
+		return INVALID_PARAMETER;
+	aX = m3dSpeakerPosition[3 * aChannel + 0];
+	aY = m3dSpeakerPosition[3 * aChannel + 1];
+	aZ = m3dSpeakerPosition[3 * aChannel + 2];
+	return SO_NO_ERROR;
 }
+} // namespace SoLoud
diff --git a/src/core/soloud_core_setters.cpp b/src/core/soloud_core_setters.cpp
index 9af372f..0a80a9f 100644
--- a/src/core/soloud_core_setters.cpp
+++ b/src/core/soloud_core_setters.cpp
@@ -28,228 +28,228 @@ freely, subject to the following restrictions:
 
 namespace SoLoud
 {
-	void Soloud::setPostClipScaler(float aScaler)
-	{
-		mPostClipScaler = aScaler;
-	}
+void Soloud::setPostClipScaler(float aScaler)
+{
+	mPostClipScaler = aScaler;
+}
 
-	void Soloud::setMainResampler(unsigned int aResampler)
-	{
-		if (aResampler <= RESAMPLER_CATMULLROM)
-			mResampler = aResampler;
-	}
+void Soloud::setMainResampler(unsigned int aResampler)
+{
+	if (aResampler <= RESAMPLER_CATMULLROM)
+		mResampler = aResampler;
+}
 
-	void Soloud::setGlobalVolume(float aVolume)
-	{
-		lockAudioMutex_internal();
-		mGlobalVolumeFader.mActive = 0;
-		mGlobalVolume = aVolume;
-		unlockAudioMutex_internal();
-	}
+void Soloud::setGlobalVolume(float aVolume)
+{
+	lockAudioMutex_internal();
+	mGlobalVolumeFader.mActive = 0;
+	mGlobalVolume = aVolume;
+	unlockAudioMutex_internal();
+}
 
-	result Soloud::setRelativePlaySpeed(handle aVoiceHandle, float aSpeed)
-	{
-		result retVal = 0;
-		FOR_ALL_VOICES_PRE
-			mVoice[ch]->mRelativePlaySpeedFader.mActive = 0;
-			retVal = setVoiceRelativePlaySpeed_internal(ch, aSpeed);
-			FOR_ALL_VOICES_POST
-		return retVal;
-	}
+result Soloud::setRelativePlaySpeed(handle aVoiceHandle, float aSpeed)
+{
+	result retVal = 0;
+	FOR_ALL_VOICES_PRE
+	mVoice[ch]->mRelativePlaySpeedFader.mActive = 0;
+	retVal = setVoiceRelativePlaySpeed_internal(ch, aSpeed);
+	FOR_ALL_VOICES_POST
+	return retVal;
+}
 
-	void Soloud::setSamplerate(handle aVoiceHandle, float aSamplerate)
-	{
-		FOR_ALL_VOICES_PRE
-			mVoice[ch]->mBaseSamplerate = aSamplerate;
-			updateVoiceRelativePlaySpeed_internal(ch);
-		FOR_ALL_VOICES_POST
-	}
+void Soloud::setSamplerate(handle aVoiceHandle, float aSamplerate)
+{
+	FOR_ALL_VOICES_PRE
+	mVoice[ch]->mBaseSamplerate = aSamplerate;
+	updateVoiceRelativePlaySpeed_internal(ch);
+	FOR_ALL_VOICES_POST
+}
+
+void Soloud::setPause(handle aVoiceHandle, bool aPause)
+{
+	FOR_ALL_VOICES_PRE
+	setVoicePause_internal(ch, aPause);
+	FOR_ALL_VOICES_POST
+}
+
+result Soloud::setMaxActiveVoiceCount(unsigned int aVoiceCount)
+{
+	if (aVoiceCount == 0 || aVoiceCount >= VOICE_COUNT)
+		return INVALID_PARAMETER;
+	lockAudioMutex_internal();
+	mMaxActiveVoices = aVoiceCount;
+	delete[] mResampleData;
+	delete[] mResampleDataOwner;
+	mResampleData = new float *[aVoiceCount * 2];
+	mResampleDataOwner = new AudioSourceInstance *[aVoiceCount];
+	mResampleDataBuffer.init(SAMPLE_GRANULARITY * MAX_CHANNELS * aVoiceCount * 2);
+	unsigned int i;
+	for (i = 0; i < aVoiceCount * 2; i++)
+		mResampleData[i] = mResampleDataBuffer.mData + (SAMPLE_GRANULARITY * MAX_CHANNELS * i);
+	for (i = 0; i < aVoiceCount; i++)
+		mResampleDataOwner[i] = NULL;
+	mActiveVoiceDirty = true;
+	unlockAudioMutex_internal();
+	return SO_NO_ERROR;
+}
 
-	void Soloud::setPause(handle aVoiceHandle, bool aPause)
+void Soloud::setPauseAll(bool aPause)
+{
+	lockAudioMutex_internal();
+	int ch;
+	for (ch = 0; ch < (signed)mHighestVoice; ch++)
 	{
-		FOR_ALL_VOICES_PRE
-			setVoicePause_internal(ch, aPause);
-		FOR_ALL_VOICES_POST
+		setVoicePause_internal(ch, aPause);
 	}
+	unlockAudioMutex_internal();
+}
 
-	result Soloud::setMaxActiveVoiceCount(unsigned int aVoiceCount)
+void Soloud::setProtectVoice(handle aVoiceHandle, bool aProtect)
+{
+	FOR_ALL_VOICES_PRE
+	if (aProtect)
 	{
-		if (aVoiceCount == 0 || aVoiceCount >= VOICE_COUNT)
-			return INVALID_PARAMETER;
-		lockAudioMutex_internal();
-		mMaxActiveVoices = aVoiceCount;
-		delete[] mResampleData;
-		delete[] mResampleDataOwner;
-		mResampleData = new float*[aVoiceCount * 2];
-		mResampleDataOwner = new AudioSourceInstance*[aVoiceCount];
-		mResampleDataBuffer.init(SAMPLE_GRANULARITY * MAX_CHANNELS * aVoiceCount * 2);
-		unsigned int i;
-		for (i = 0; i < aVoiceCount * 2; i++)
-			mResampleData[i] = mResampleDataBuffer.mData + (SAMPLE_GRANULARITY * MAX_CHANNELS * i);
-		for (i = 0; i < aVoiceCount; i++)
-			mResampleDataOwner[i] = NULL;
-		mActiveVoiceDirty = true;
-		unlockAudioMutex_internal();
-		return SO_NO_ERROR;
+		mVoice[ch]->mFlags |= AudioSourceInstance::PROTECTED;
 	}
-
-	void Soloud::setPauseAll(bool aPause)
+	else
 	{
-		lockAudioMutex_internal();
-		int ch;
-		for (ch = 0; ch < (signed)mHighestVoice; ch++)
-		{
-			setVoicePause_internal(ch, aPause);
-		}
-		unlockAudioMutex_internal();
+		mVoice[ch]->mFlags &= ~AudioSourceInstance::PROTECTED;
 	}
+	FOR_ALL_VOICES_POST
+}
 
-	void Soloud::setProtectVoice(handle aVoiceHandle, bool aProtect)
+void Soloud::setPan(handle aVoiceHandle, float aPan)
+{
+	FOR_ALL_VOICES_PRE
+	setVoicePan_internal(ch, aPan);
+	FOR_ALL_VOICES_POST
+}
+
+void Soloud::setChannelVolume(handle aVoiceHandle, unsigned int aChannel, float aVolume)
+{
+	FOR_ALL_VOICES_PRE
+	if (mVoice[ch]->mChannels > aChannel)
 	{
-		FOR_ALL_VOICES_PRE
-			if (aProtect)
-			{
-				mVoice[ch]->mFlags |= AudioSourceInstance::PROTECTED;
-			}
-			else
-			{
-				mVoice[ch]->mFlags &= ~AudioSourceInstance::PROTECTED;
-			}
-		FOR_ALL_VOICES_POST
+		mVoice[ch]->mChannelVolume[aChannel] = aVolume;
 	}
+	FOR_ALL_VOICES_POST
+}
 
-	void Soloud::setPan(handle aVoiceHandle, float aPan)
-	{		
-		FOR_ALL_VOICES_PRE
-			setVoicePan_internal(ch, aPan);
-		FOR_ALL_VOICES_POST
+void Soloud::setPanAbsolute(handle aVoiceHandle, float aLVolume, float aRVolume)
+{
+	FOR_ALL_VOICES_PRE
+	mVoice[ch]->mPanFader.mActive = 0;
+	mVoice[ch]->mChannelVolume[0] = aLVolume;
+	mVoice[ch]->mChannelVolume[1] = aRVolume;
+	if (mVoice[ch]->mChannels == 4)
+	{
+		mVoice[ch]->mChannelVolume[2] = aLVolume;
+		mVoice[ch]->mChannelVolume[3] = aRVolume;
 	}
-
-	void Soloud::setChannelVolume(handle aVoiceHandle, unsigned int aChannel, float aVolume)
-	{		
-		FOR_ALL_VOICES_PRE
-			if (mVoice[ch]->mChannels > aChannel)
-			{
-				mVoice[ch]->mChannelVolume[aChannel] = aVolume;
-			}
-		FOR_ALL_VOICES_POST
+	if (mVoice[ch]->mChannels == 6)
+	{
+		mVoice[ch]->mChannelVolume[2] = (aLVolume + aRVolume) * 0.5f;
+		mVoice[ch]->mChannelVolume[3] = (aLVolume + aRVolume) * 0.5f;
+		mVoice[ch]->mChannelVolume[4] = aLVolume;
+		mVoice[ch]->mChannelVolume[5] = aRVolume;
 	}
-
-	void Soloud::setPanAbsolute(handle aVoiceHandle, float aLVolume, float aRVolume)
+	if (mVoice[ch]->mChannels == 8)
 	{
-		FOR_ALL_VOICES_PRE
-			mVoice[ch]->mPanFader.mActive = 0;	
-			mVoice[ch]->mChannelVolume[0] = aLVolume;			
-			mVoice[ch]->mChannelVolume[1] = aRVolume;
-			if (mVoice[ch]->mChannels == 4)
-			{
-				mVoice[ch]->mChannelVolume[2] = aLVolume;
-				mVoice[ch]->mChannelVolume[3] = aRVolume;
-			}
-			if (mVoice[ch]->mChannels == 6)
-			{
-				mVoice[ch]->mChannelVolume[2] = (aLVolume + aRVolume) * 0.5f;
-				mVoice[ch]->mChannelVolume[3] = (aLVolume + aRVolume) * 0.5f;
-				mVoice[ch]->mChannelVolume[4] = aLVolume;
-				mVoice[ch]->mChannelVolume[5] = aRVolume;
-			}
-			if (mVoice[ch]->mChannels == 8)
-			{
-				mVoice[ch]->mChannelVolume[2] = (aLVolume + aRVolume) * 0.5f;
-				mVoice[ch]->mChannelVolume[3] = (aLVolume + aRVolume) * 0.5f;
-				mVoice[ch]->mChannelVolume[4] = aLVolume;
-				mVoice[ch]->mChannelVolume[5] = aRVolume;
-				mVoice[ch]->mChannelVolume[6] = aLVolume;
-				mVoice[ch]->mChannelVolume[7] = aRVolume;
-			}
-		FOR_ALL_VOICES_POST
+		mVoice[ch]->mChannelVolume[2] = (aLVolume + aRVolume) * 0.5f;
+		mVoice[ch]->mChannelVolume[3] = (aLVolume + aRVolume) * 0.5f;
+		mVoice[ch]->mChannelVolume[4] = aLVolume;
+		mVoice[ch]->mChannelVolume[5] = aRVolume;
+		mVoice[ch]->mChannelVolume[6] = aLVolume;
+		mVoice[ch]->mChannelVolume[7] = aRVolume;
 	}
+	FOR_ALL_VOICES_POST
+}
 
-	void Soloud::setInaudibleBehavior(handle aVoiceHandle, bool aMustTick, bool aKill)
+void Soloud::setInaudibleBehavior(handle aVoiceHandle, bool aMustTick, bool aKill)
+{
+	FOR_ALL_VOICES_PRE
+	mVoice[ch]->mFlags &= ~(AudioSourceInstance::INAUDIBLE_KILL | AudioSourceInstance::INAUDIBLE_TICK);
+	if (aMustTick)
 	{
-		FOR_ALL_VOICES_PRE
-			mVoice[ch]->mFlags &= ~(AudioSourceInstance::INAUDIBLE_KILL | AudioSourceInstance::INAUDIBLE_TICK);
-			if (aMustTick)
-			{
-				mVoice[ch]->mFlags |= AudioSourceInstance::INAUDIBLE_TICK;
-			}
-			if (aKill)
-			{
-				mVoice[ch]->mFlags |= AudioSourceInstance::INAUDIBLE_KILL;
-			}
-		FOR_ALL_VOICES_POST
+		mVoice[ch]->mFlags |= AudioSourceInstance::INAUDIBLE_TICK;
 	}
-
-	void Soloud::setLoopPoint(handle aVoiceHandle, time aLoopPoint)
+	if (aKill)
 	{
-		FOR_ALL_VOICES_PRE
-			mVoice[ch]->mLoopPoint = aLoopPoint;
-		FOR_ALL_VOICES_POST
+		mVoice[ch]->mFlags |= AudioSourceInstance::INAUDIBLE_KILL;
 	}
+	FOR_ALL_VOICES_POST
+}
 
-	void Soloud::setLooping(handle aVoiceHandle, bool aLooping)
+void Soloud::setLoopPoint(handle aVoiceHandle, time aLoopPoint)
+{
+	FOR_ALL_VOICES_PRE
+	mVoice[ch]->mLoopPoint = aLoopPoint;
+	FOR_ALL_VOICES_POST
+}
+
+void Soloud::setLooping(handle aVoiceHandle, bool aLooping)
+{
+	FOR_ALL_VOICES_PRE
+	if (aLooping)
 	{
-		FOR_ALL_VOICES_PRE
-			if (aLooping)
-			{
-				mVoice[ch]->mFlags |= AudioSourceInstance::LOOPING;
-			}
-			else
-			{
-				mVoice[ch]->mFlags &= ~AudioSourceInstance::LOOPING;
-			}
-		FOR_ALL_VOICES_POST
+		mVoice[ch]->mFlags |= AudioSourceInstance::LOOPING;
 	}
-
-	void Soloud::setAutoStop(handle aVoiceHandle, bool aAutoStop)
+	else
 	{
-		FOR_ALL_VOICES_PRE
-			if (aAutoStop)
-			{
-				mVoice[ch]->mFlags &= ~AudioSourceInstance::DISABLE_AUTOSTOP;
-			}
-			else
-			{
-				mVoice[ch]->mFlags |= AudioSourceInstance::DISABLE_AUTOSTOP;
-			}
-		FOR_ALL_VOICES_POST
+		mVoice[ch]->mFlags &= ~AudioSourceInstance::LOOPING;
 	}
+	FOR_ALL_VOICES_POST
+}
 
-	void Soloud::setVolume(handle aVoiceHandle, float aVolume)
+void Soloud::setAutoStop(handle aVoiceHandle, bool aAutoStop)
+{
+	FOR_ALL_VOICES_PRE
+	if (aAutoStop)
 	{
-		FOR_ALL_VOICES_PRE
-			mVoice[ch]->mVolumeFader.mActive = 0;
-			setVoiceVolume_internal(ch, aVolume);
-		FOR_ALL_VOICES_POST
+		mVoice[ch]->mFlags &= ~AudioSourceInstance::DISABLE_AUTOSTOP;
 	}
-
-	void Soloud::setDelaySamples(handle aVoiceHandle, unsigned int aSamples)
+	else
 	{
-		FOR_ALL_VOICES_PRE
-			mVoice[ch]->mDelaySamples = aSamples;
-		FOR_ALL_VOICES_POST
+		mVoice[ch]->mFlags |= AudioSourceInstance::DISABLE_AUTOSTOP;
 	}
+	FOR_ALL_VOICES_POST
+}
+
+void Soloud::setVolume(handle aVoiceHandle, float aVolume)
+{
+	FOR_ALL_VOICES_PRE
+	mVoice[ch]->mVolumeFader.mActive = 0;
+	setVoiceVolume_internal(ch, aVolume);
+	FOR_ALL_VOICES_POST
+}
 
-	void Soloud::setVisualizationEnable(bool aEnable)
+void Soloud::setDelaySamples(handle aVoiceHandle, unsigned int aSamples)
+{
+	FOR_ALL_VOICES_PRE
+	mVoice[ch]->mDelaySamples = aSamples;
+	FOR_ALL_VOICES_POST
+}
+
+void Soloud::setVisualizationEnable(bool aEnable)
+{
+	if (aEnable)
 	{
-		if (aEnable)
-		{
-			mFlags |= ENABLE_VISUALIZATION;
-		}
-		else
-		{
-			mFlags &= ~ENABLE_VISUALIZATION;
-		}
+		mFlags |= ENABLE_VISUALIZATION;
 	}
-
-	result Soloud::setSpeakerPosition(unsigned int aChannel, float aX, float aY, float aZ)
+	else
 	{
-		if (aChannel >= mChannels)
-			return INVALID_PARAMETER;
-		m3dSpeakerPosition[3 * aChannel + 0] = aX;
-		m3dSpeakerPosition[3 * aChannel + 1] = aY;
-		m3dSpeakerPosition[3 * aChannel + 2] = aZ;
-		return SO_NO_ERROR;
+		mFlags &= ~ENABLE_VISUALIZATION;
 	}
+}
 
+result Soloud::setSpeakerPosition(unsigned int aChannel, float aX, float aY, float aZ)
+{
+	if (aChannel >= mChannels)
+		return INVALID_PARAMETER;
+	m3dSpeakerPosition[3 * aChannel + 0] = aX;
+	m3dSpeakerPosition[3 * aChannel + 1] = aY;
+	m3dSpeakerPosition[3 * aChannel + 2] = aZ;
+	return SO_NO_ERROR;
 }
+
+} // namespace SoLoud
diff --git a/src/core/soloud_core_voiceops.cpp b/src/core/soloud_core_voiceops.cpp
index bb39fbe..7ad96f0 100644
--- a/src/core/soloud_core_voiceops.cpp
+++ b/src/core/soloud_core_voiceops.cpp
@@ -28,135 +28,135 @@ freely, subject to the following restrictions:
 
 namespace SoLoud
 {
-	result Soloud::setVoiceRelativePlaySpeed_internal(unsigned int aVoice, float aSpeed)
+result Soloud::setVoiceRelativePlaySpeed_internal(unsigned int aVoice, float aSpeed)
+{
+	SOLOUD_ASSERT(aVoice < VOICE_COUNT);
+	SOLOUD_ASSERT(mInsideAudioThreadMutex);
+	if (aSpeed <= 0.0f)
 	{
-		SOLOUD_ASSERT(aVoice < VOICE_COUNT);
-		SOLOUD_ASSERT(mInsideAudioThreadMutex);
-		if (aSpeed <= 0.0f)
-		{
-			return INVALID_PARAMETER;
-		}
-
-		if (mVoice[aVoice])
-		{
-			mVoice[aVoice]->mSetRelativePlaySpeed = aSpeed;
-			updateVoiceRelativePlaySpeed_internal(aVoice);
-		}
+		return INVALID_PARAMETER;
+	}
 
-		return 0;
+	if (mVoice[aVoice])
+	{
+		mVoice[aVoice]->mSetRelativePlaySpeed = aSpeed;
+		updateVoiceRelativePlaySpeed_internal(aVoice);
 	}
 
-	void Soloud::setVoicePause_internal(unsigned int aVoice, int aPause)
+	return 0;
+}
+
+void Soloud::setVoicePause_internal(unsigned int aVoice, int aPause)
+{
+	SOLOUD_ASSERT(aVoice < VOICE_COUNT);
+	SOLOUD_ASSERT(mInsideAudioThreadMutex);
+	mActiveVoiceDirty = true;
+	if (mVoice[aVoice])
 	{
-		SOLOUD_ASSERT(aVoice < VOICE_COUNT);
-		SOLOUD_ASSERT(mInsideAudioThreadMutex);
-		mActiveVoiceDirty = true;
-		if (mVoice[aVoice])
-		{
-			mVoice[aVoice]->mPauseScheduler.mActive = 0;
+		mVoice[aVoice]->mPauseScheduler.mActive = 0;
 
-			if (aPause)
-			{
-				mVoice[aVoice]->mFlags |= AudioSourceInstance::PAUSED;
-			}
-			else
-			{
-				mVoice[aVoice]->mFlags &= ~AudioSourceInstance::PAUSED;
-			}
+		if (aPause)
+		{
+			mVoice[aVoice]->mFlags |= AudioSourceInstance::PAUSED;
+		}
+		else
+		{
+			mVoice[aVoice]->mFlags &= ~AudioSourceInstance::PAUSED;
 		}
 	}
+}
 
-	void Soloud::setVoicePan_internal(unsigned int aVoice, float aPan)
+void Soloud::setVoicePan_internal(unsigned int aVoice, float aPan)
+{
+	SOLOUD_ASSERT(aVoice < VOICE_COUNT);
+	SOLOUD_ASSERT(mInsideAudioThreadMutex);
+	if (mVoice[aVoice])
 	{
-		SOLOUD_ASSERT(aVoice < VOICE_COUNT);
-		SOLOUD_ASSERT(mInsideAudioThreadMutex);
-		if (mVoice[aVoice])
+		mVoice[aVoice]->mPan = aPan;
+		float l = (float)cos((aPan + 1) * M_PI / 4);
+		float r = (float)sin((aPan + 1) * M_PI / 4);
+		mVoice[aVoice]->mChannelVolume[0] = l;
+		mVoice[aVoice]->mChannelVolume[1] = r;
+		if (mVoice[aVoice]->mChannels == 4)
 		{
-			mVoice[aVoice]->mPan = aPan;
-			float l = (float)cos((aPan + 1) * M_PI / 4);
-			float r = (float)sin((aPan + 1) * M_PI / 4);
-			mVoice[aVoice]->mChannelVolume[0] = l;
-			mVoice[aVoice]->mChannelVolume[1] = r;
-			if (mVoice[aVoice]->mChannels == 4)
-			{
-				mVoice[aVoice]->mChannelVolume[2] = l;
-				mVoice[aVoice]->mChannelVolume[3] = r;
-			}
-			if (mVoice[aVoice]->mChannels == 6)
-			{
-				mVoice[aVoice]->mChannelVolume[2] = 1.0f / (float)sqrt(2.0f);
-				mVoice[aVoice]->mChannelVolume[3] = 1;
-				mVoice[aVoice]->mChannelVolume[4] = l;
-				mVoice[aVoice]->mChannelVolume[5] = r;
-			}
-			if (mVoice[aVoice]->mChannels == 8)
-			{
-				mVoice[aVoice]->mChannelVolume[2] = 1.0f / (float)sqrt(2.0f);
-				mVoice[aVoice]->mChannelVolume[3] = 1;
-				mVoice[aVoice]->mChannelVolume[4] = l;
-				mVoice[aVoice]->mChannelVolume[5] = r;
-				mVoice[aVoice]->mChannelVolume[6] = l;
-				mVoice[aVoice]->mChannelVolume[7] = r;
-			}
+			mVoice[aVoice]->mChannelVolume[2] = l;
+			mVoice[aVoice]->mChannelVolume[3] = r;
+		}
+		if (mVoice[aVoice]->mChannels == 6)
+		{
+			mVoice[aVoice]->mChannelVolume[2] = 1.0f / (float)sqrt(2.0f);
+			mVoice[aVoice]->mChannelVolume[3] = 1;
+			mVoice[aVoice]->mChannelVolume[4] = l;
+			mVoice[aVoice]->mChannelVolume[5] = r;
+		}
+		if (mVoice[aVoice]->mChannels == 8)
+		{
+			mVoice[aVoice]->mChannelVolume[2] = 1.0f / (float)sqrt(2.0f);
+			mVoice[aVoice]->mChannelVolume[3] = 1;
+			mVoice[aVoice]->mChannelVolume[4] = l;
+			mVoice[aVoice]->mChannelVolume[5] = r;
+			mVoice[aVoice]->mChannelVolume[6] = l;
+			mVoice[aVoice]->mChannelVolume[7] = r;
 		}
 	}
+}
 
-	void Soloud::setVoiceVolume_internal(unsigned int aVoice, float aVolume)
+void Soloud::setVoiceVolume_internal(unsigned int aVoice, float aVolume)
+{
+	SOLOUD_ASSERT(aVoice < VOICE_COUNT);
+	SOLOUD_ASSERT(mInsideAudioThreadMutex);
+	mActiveVoiceDirty = true;
+	if (mVoice[aVoice])
 	{
-		SOLOUD_ASSERT(aVoice < VOICE_COUNT);
-		SOLOUD_ASSERT(mInsideAudioThreadMutex);
-		mActiveVoiceDirty = true;
-		if (mVoice[aVoice])
-		{
-			mVoice[aVoice]->mSetVolume = aVolume;
-			updateVoiceVolume_internal(aVoice);
-		}
+		mVoice[aVoice]->mSetVolume = aVolume;
+		updateVoiceVolume_internal(aVoice);
 	}
+}
 
-	void Soloud::stopVoice_internal(unsigned int aVoice)
+void Soloud::stopVoice_internal(unsigned int aVoice)
+{
+	SOLOUD_ASSERT(aVoice < VOICE_COUNT);
+	SOLOUD_ASSERT(mInsideAudioThreadMutex);
+	mActiveVoiceDirty = true;
+	if (mVoice[aVoice])
 	{
-		SOLOUD_ASSERT(aVoice < VOICE_COUNT);
-		SOLOUD_ASSERT(mInsideAudioThreadMutex);
-		mActiveVoiceDirty = true;
-		if (mVoice[aVoice])
-		{
-			// Delete via temporary variable to avoid recursion
-			AudioSourceInstance * v = mVoice[aVoice];
-			mVoice[aVoice] = 0;
+		// Delete via temporary variable to avoid recursion
+		AudioSourceInstance *v = mVoice[aVoice];
+		mVoice[aVoice] = 0;
 
-			unsigned int i;
-			for (i = 0; i < mMaxActiveVoices; i++)
+		unsigned int i;
+		for (i = 0; i < mMaxActiveVoices; i++)
+		{
+			if (mResampleDataOwner[i] == v)
 			{
-				if (mResampleDataOwner[i] == v)
-				{
-					mResampleDataOwner[i] = NULL;
-				}
+				mResampleDataOwner[i] = NULL;
 			}
-
-			delete v;
 		}
-	}
 
-	void Soloud::updateVoiceRelativePlaySpeed_internal(unsigned int aVoice)
-	{
-		SOLOUD_ASSERT(aVoice < VOICE_COUNT);
-		SOLOUD_ASSERT(mInsideAudioThreadMutex);
-		mVoice[aVoice]->mOverallRelativePlaySpeed = m3dData[aVoice].mDopplerValue * mVoice[aVoice]->mSetRelativePlaySpeed;
-		mVoice[aVoice]->mSamplerate = mVoice[aVoice]->mBaseSamplerate * mVoice[aVoice]->mOverallRelativePlaySpeed;
+		delete v;
 	}
+}
 
-	void Soloud::updateVoiceVolume_internal(unsigned int aVoice)
+void Soloud::updateVoiceRelativePlaySpeed_internal(unsigned int aVoice)
+{
+	SOLOUD_ASSERT(aVoice < VOICE_COUNT);
+	SOLOUD_ASSERT(mInsideAudioThreadMutex);
+	mVoice[aVoice]->mOverallRelativePlaySpeed = m3dData[aVoice].mDopplerValue * mVoice[aVoice]->mSetRelativePlaySpeed;
+	mVoice[aVoice]->mSamplerate = mVoice[aVoice]->mBaseSamplerate * mVoice[aVoice]->mOverallRelativePlaySpeed;
+}
+
+void Soloud::updateVoiceVolume_internal(unsigned int aVoice)
+{
+	SOLOUD_ASSERT(aVoice < VOICE_COUNT);
+	SOLOUD_ASSERT(mInsideAudioThreadMutex);
+	mVoice[aVoice]->mOverallVolume = mVoice[aVoice]->mSetVolume * m3dData[aVoice].m3dVolume;
+	if (mVoice[aVoice]->mFlags & AudioSourceInstance::PAUSED)
 	{
-		SOLOUD_ASSERT(aVoice < VOICE_COUNT);
-		SOLOUD_ASSERT(mInsideAudioThreadMutex);
-		mVoice[aVoice]->mOverallVolume = mVoice[aVoice]->mSetVolume * m3dData[aVoice].m3dVolume;
-		if (mVoice[aVoice]->mFlags & AudioSourceInstance::PAUSED)
+		int i;
+		for (i = 0; i < MAX_CHANNELS; i++)
 		{
-			int i;
-			for (i = 0; i < MAX_CHANNELS; i++)
-			{
-				mVoice[aVoice]->mCurrentChannelVolume[i] = mVoice[aVoice]->mChannelVolume[i] * mVoice[aVoice]->mOverallVolume;
-			}
+			mVoice[aVoice]->mCurrentChannelVolume[i] = mVoice[aVoice]->mChannelVolume[i] * mVoice[aVoice]->mOverallVolume;
 		}
 	}
 }
+} // namespace SoLoud
-- 
2.49.0

From 600532b53005e70638564ed9982cd2a0d657da05 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Fri, 6 Jun 2025 00:08:05 -0700
Subject: [PATCH 2/2] rework resampler

fixes offset drift issues when source/dest frequency doesn't match (e.g. 44100/48000)
https://github.com/jarikomppa/soloud/issues/314

---
 include/soloud.h                  |  75 +++-
 include/soloud_audiosource.h      |  15 +-
 src/core/soloud.cpp               | 679 +++++++++++++++++-------------
 src/core/soloud_audiosource.cpp   |  27 +-
 src/core/soloud_core_setters.cpp  |  10 -
 src/core/soloud_core_voiceops.cpp |   9 -
 6 files changed, 461 insertions(+), 354 deletions(-)

diff --git a/include/soloud.h b/include/soloud.h
index cf03ad6..ed042a2 100644
--- a/include/soloud.h
+++ b/include/soloud.h
@@ -235,8 +235,11 @@ public:
 	};
 
 	// Initialize SoLoud. Must be called before SoLoud can be used.
-	result init(unsigned int aFlags = Soloud::CLIP_ROUNDOFF, unsigned int aBackend = Soloud::AUTO, unsigned int aSamplerate = Soloud::AUTO,
-	            unsigned int aBufferSize = Soloud::AUTO, unsigned int aChannels = 2);
+	result init(unsigned int aFlags = Soloud::CLIP_ROUNDOFF,
+	            unsigned int aBackend = Soloud::AUTO,
+	            unsigned int aSamplerate = Soloud::AUTO,
+	            unsigned int aBufferSize = Soloud::AUTO,
+	            unsigned int aChannels = 2);
 
 	result pause();
 	result resume();
@@ -271,11 +274,27 @@ public:
 	// Start playing a sound delayed in relation to other sounds called via this function. Negative volume means to use default.
 	handle playClocked(time aSoundTime, AudioSource &aSound, float aVolume = -1.0f, float aPan = 0.0f, unsigned int aBus = 0);
 	// Start playing a 3d audio source
-	handle play3d(AudioSource &aSound, float aPosX, float aPosY, float aPosZ, float aVelX = 0.0f, float aVelY = 0.0f, float aVelZ = 0.0f, float aVolume = 1.0f,
-	              bool aPaused = 0, unsigned int aBus = 0);
+	handle play3d(AudioSource &aSound,
+	              float aPosX,
+	              float aPosY,
+	              float aPosZ,
+	              float aVelX = 0.0f,
+	              float aVelY = 0.0f,
+	              float aVelZ = 0.0f,
+	              float aVolume = 1.0f,
+	              bool aPaused = 0,
+	              unsigned int aBus = 0);
 	// Start playing a 3d audio source, delayed in relation to other sounds called via this function.
-	handle play3dClocked(time aSoundTime, AudioSource &aSound, float aPosX, float aPosY, float aPosZ, float aVelX = 0.0f, float aVelY = 0.0f, float aVelZ = 0.0f,
-	                     float aVolume = 1.0f, unsigned int aBus = 0);
+	handle play3dClocked(time aSoundTime,
+	                     AudioSource &aSound,
+	                     float aPosX,
+	                     float aPosY,
+	                     float aPosZ,
+	                     float aVelX = 0.0f,
+	                     float aVelY = 0.0f,
+	                     float aVelZ = 0.0f,
+	                     float aVolume = 1.0f,
+	                     unsigned int aBus = 0);
 	// Start playing a sound without any panning. It will be played at full volume.
 	handle playBackground(AudioSource &aSound, float aVolume = -1.0f, bool aPaused = 0, unsigned int aBus = 0);
 
@@ -437,8 +456,18 @@ public:
 	// Get the current speed of sound constant for doppler
 	float get3dSoundSpeed();
 	// Set 3d listener parameters
-	void set3dListenerParameters(float aPosX, float aPosY, float aPosZ, float aAtX, float aAtY, float aAtZ, float aUpX, float aUpY, float aUpZ,
-	                             float aVelocityX = 0.0f, float aVelocityY = 0.0f, float aVelocityZ = 0.0f);
+	void set3dListenerParameters(float aPosX,
+	                             float aPosY,
+	                             float aPosZ,
+	                             float aAtX,
+	                             float aAtY,
+	                             float aAtZ,
+	                             float aUpX,
+	                             float aUpY,
+	                             float aUpZ,
+	                             float aVelocityX = 0.0f,
+	                             float aVelocityY = 0.0f,
+	                             float aVelocityZ = 0.0f);
 	// Set 3d listener position
 	void set3dListenerPosition(float aPosX, float aPosY, float aPosZ);
 	// Set 3d listener "at" vector
@@ -449,8 +478,8 @@ public:
 	void set3dListenerVelocity(float aVelocityX, float aVelocityY, float aVelocityZ);
 
 	// Set 3d audio source parameters
-	void set3dSourceParameters(handle aVoiceHandle, float aPosX, float aPosY, float aPosZ, float aVelocityX = 0.0f, float aVelocityY = 0.0f,
-	                           float aVelocityZ = 0.0f);
+	void set3dSourceParameters(
+	    handle aVoiceHandle, float aPosX, float aPosY, float aPosZ, float aVelocityX = 0.0f, float aVelocityY = 0.0f, float aVelocityZ = 0.0f);
 	// Set 3d audio source position
 	void set3dSourcePosition(handle aVoiceHandle, float aPosX, float aPosY, float aPosZ);
 	// Set 3d audio source velocity
@@ -478,11 +507,23 @@ public:
 
 	// Update list of active voices
 	void calcActiveVoices_internal();
-	// Map resample buffers to active voices
-	void mapResampleBuffers_internal();
+	unsigned int resampleVoicePrecise_internal(AudioSourceInstance *voice,
+	                                           float *outputBuffer,
+	                                           unsigned int outputSamples,
+	                                           unsigned int outputStride,
+	                                           double outputSampleRate,
+	                                           unsigned int resampler,
+	                                           float *scratchBuffer,
+	                                           unsigned int scratchSize);
 	// Perform mixing for a specific bus
-	void mixBus_internal(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize, float *aScratch, unsigned int aBus, float aSamplerate,
-	                     unsigned int aChannels, unsigned int aResampler);
+	void mixBus_internal(float *aBuffer,
+	                     unsigned int aSamplesToRead,
+	                     unsigned int aBufferSize,
+	                     float *aScratch,
+	                     unsigned int aBus,
+	                     float aSamplerate,
+	                     unsigned int aChannels,
+	                     unsigned int aResampler);
 	// Find a free voice, stopping the oldest if no free voice is found.
 	int findFreeVoice_internal();
 	// Converts handle to voice, if the handle is valid. Returns -1 if not.
@@ -527,12 +568,6 @@ public:
 	unsigned int mScratchSize;
 	// Output scratch buffer, used in mix_().
 	AlignedFloatBuffer mOutputScratch;
-	// Pointers to resampler buffers, two per active voice.
-	float **mResampleData;
-	// Actual allocated memory for resampler buffers
-	AlignedFloatBuffer mResampleDataBuffer;
-	// Owners of the resample data
-	AudioSourceInstance **mResampleDataOwner;
 	// Audio voices.
 	AudioSourceInstance *mVoice[VOICE_COUNT];
 	// Resampler for the main bus
diff --git a/include/soloud_audiosource.h b/include/soloud_audiosource.h
index b91a1ce..f8611ba 100644
--- a/include/soloud_audiosource.h
+++ b/include/soloud_audiosource.h
@@ -177,17 +177,20 @@ public:
 	FilterInstance *mFilter[FILTERS_PER_STREAM];
 	// Initialize instance. Mostly internal use.
 	void init(AudioSource &aSource, int aPlayIndex);
-	// Pointers to buffers for the resampler
-	float *mResampleData[2];
-	// Sub-sample playhead; 16.16 fixed point
-	unsigned int mSrcOffset;
-	// Samples left over from earlier pass
-	unsigned int mLeftoverSamples;
 	// Number of samples to delay streaming
 	unsigned int mDelaySamples;
 	// When looping, start playing from this time
 	time mLoopPoint;
 
+	static const unsigned int CHUNK_SIZE = 512; // a la SAMPLE_GRANULARITY
+	static const unsigned int CHUNK_COUNT = 3;  // 3 chunks = 1536 samples buffer
+	static const unsigned int RESAMPLE_BUFFER_SIZE = CHUNK_SIZE * CHUNK_COUNT;
+
+	float mResampleBuffer[MAX_CHANNELS][RESAMPLE_BUFFER_SIZE];
+	unsigned int mResampleBufferFill; // How many samples currently in buffer
+	unsigned int mResampleBufferPos;  // Current read position in buffer
+	double mPreciseSrcPosition;       // Exact fractional position in source stream
+
 	// Get N samples from the stream to the buffer. Report samples written.
 	virtual unsigned int getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize) = 0;
 	// Has the stream ended?
diff --git a/src/core/soloud.cpp b/src/core/soloud.cpp
index 4e58d72..6ba4d24 100644
--- a/src/core/soloud.cpp
+++ b/src/core/soloud.cpp
@@ -22,17 +22,18 @@ freely, subject to the following restrictions:
    distribution.
 */
 
+#include "soloud_fft.h"
+#include "soloud_internal.h"
+#include "soloud_thread.h"
 #include <float.h> // _controlfp
 #include <math.h>  // sin
 #include <stdlib.h>
 #include <string.h>
 
-#include "soloud_fft.h"
-#include "soloud_internal.h"
-#include "soloud_thread.h"
-
 #ifdef SOLOUD_SSE_INTRINSICS
 #include <xmmintrin.h>
+
+#include <cstddef>
 #ifdef _M_IX86
 #include <emmintrin.h>
 #endif
@@ -162,8 +163,6 @@ Soloud::Soloud()
 	m3dSoundSpeed = 343.3f;
 	mMaxActiveVoices = 16;
 	mHighestVoice = 0;
-	mResampleData = NULL;
-	mResampleDataOwner = NULL;
 	for (i = 0; i < 3 * MAX_CHANNELS; i++)
 		m3dSpeakerPosition[i] = 0;
 }
@@ -196,11 +195,6 @@ void Soloud::deinit()
 	if (mAudioThreadMutex)
 		Thread::destroyMutex(mAudioThreadMutex);
 	mAudioThreadMutex = NULL;
-
-	delete[] mResampleData;
-	mResampleData = NULL;
-	delete[] mResampleDataOwner;
-	mResampleDataOwner = NULL;
 }
 
 result Soloud::init(unsigned int aFlags, unsigned int aBackend, unsigned int aSamplerate, unsigned int aBufferSize, unsigned int aChannels)
@@ -601,14 +595,7 @@ void Soloud::postinit_internal(unsigned int aSamplerate, unsigned int aBufferSiz
 		mScratchSize = 4096;
 	mScratch.init(mScratchSize * MAX_CHANNELS);
 	mOutputScratch.init(mScratchSize * MAX_CHANNELS);
-	mResampleData = new float *[mMaxActiveVoices * 2];
-	mResampleDataOwner = new AudioSourceInstance *[mMaxActiveVoices];
-	mResampleDataBuffer.init(mMaxActiveVoices * 2 * SAMPLE_GRANULARITY * MAX_CHANNELS);
-	unsigned int i;
-	for (i = 0; i < mMaxActiveVoices * 2; i++)
-		mResampleData[i] = mResampleDataBuffer.mData + (SAMPLE_GRANULARITY * MAX_CHANNELS * i);
-	for (i = 0; i < mMaxActiveVoices; i++)
-		mResampleDataOwner[i] = NULL;
+
 	mFlags = aFlags;
 	mPostClipScaler = 0.95f;
 	switch (mChannels)
@@ -1616,359 +1603,445 @@ void panAndExpand(AudioSourceInstance *aVoice, float *aBuffer, unsigned int aSam
 		aVoice->mCurrentChannelVolume[k] = pand[k];
 }
 
-void Soloud::mixBus_internal(float *aBuffer,
-                             unsigned int aSamplesToRead,
-                             unsigned int aBufferSize,
-                             float *aScratch,
-                             unsigned int aBus,
-                             float aSamplerate,
-                             unsigned int aChannels,
-                             unsigned int aResampler)
+// Helper function to ensure we have enough source data in the resample buffer
+unsigned int ensureSourceData_internal(AudioSourceInstance *voice, unsigned int samplesNeeded, float *scratchBuffer, unsigned int scratchSize)
 {
-	unsigned int i, j;
-	// Clear accumulation buffer
-	for (i = 0; i < aSamplesToRead; i++)
+	const unsigned int CHUNK_SIZE = AudioSourceInstance::CHUNK_SIZE;
+	const unsigned int RESAMPLE_BUFFER_SIZE = AudioSourceInstance::RESAMPLE_BUFFER_SIZE;
+
+	// Calculate how many samples we currently have available
+	unsigned int availableSamples = voice->mResampleBufferFill - voice->mResampleBufferPos;
+
+	// If we have enough samples, return early
+	if (availableSamples >= samplesNeeded)
 	{
-		for (j = 0; j < aChannels; j++)
+		return availableSamples;
+	}
+
+	// Compact buffer when read position advances significantly
+	if (voice->mResampleBufferPos >= CHUNK_SIZE && availableSamples > 0)
+	{
+		for (unsigned int ch = 0; ch < voice->mChannels; ch++)
 		{
-			aBuffer[i + j * aBufferSize] = 0;
+			memmove(voice->mResampleBuffer[ch], voice->mResampleBuffer[ch] + voice->mResampleBufferPos, availableSamples * sizeof(float));
 		}
+		voice->mResampleBufferFill = availableSamples;
+		voice->mResampleBufferPos = 0;
+	}
+	else if (availableSamples == 0)
+	{
+		// Buffer is empty, reset positions
+		voice->mResampleBufferFill = 0;
+		voice->mResampleBufferPos = 0;
 	}
 
-	// Accumulate sound sources
-	for (i = 0; i < mActiveVoiceCount; i++)
+	// Determine how much space we have for new data
+	unsigned int spaceAvailable = RESAMPLE_BUFFER_SIZE - voice->mResampleBufferFill;
+	if (spaceAvailable == 0)
 	{
-		AudioSourceInstance *voice = mVoice[mActiveVoice[i]];
-		if (voice && voice->mBusHandle == aBus && !(voice->mFlags & AudioSourceInstance::PAUSED) && !(voice->mFlags & AudioSourceInstance::INAUDIBLE))
+		return availableSamples; // Buffer is full
+	}
+
+	// Read one chunk at a time to maintain low latency
+	unsigned int samplesToRead = CHUNK_SIZE;
+	if (samplesToRead > spaceAvailable)
+		samplesToRead = spaceAvailable;
+	if (samplesToRead > scratchSize / voice->mChannels)
+		samplesToRead = scratchSize / voice->mChannels;
+
+	if (samplesToRead == 0)
+	{
+		return availableSamples;
+	}
+
+	unsigned int samplesRead = 0;
+	bool shouldTryToRead = !voice->hasEnded() || (voice->mFlags & AudioSourceInstance::LOOPING) || availableSamples < samplesNeeded;
+
+	if (shouldTryToRead)
+	{
+		// Use scratch buffer for reading
+		float *channelBuffer = scratchBuffer;
+		unsigned int channelBufferSize = samplesToRead * voice->mChannels;
+
+		if (channelBufferSize <= scratchSize)
 		{
-			float step = voice->mSamplerate / aSamplerate;
-			// avoid step overflow
-			if (step > (1 << (32 - FIXPOINT_FRAC_BITS)))
-				step = 0;
-			unsigned int step_fixed = (int)floor(step * FIXPOINT_FRAC_MUL);
-			unsigned int outofs = 0;
-
-			if (voice->mDelaySamples)
+			samplesRead = voice->getAudio(channelBuffer, samplesToRead, samplesToRead);
+
+			// Handle looping
+			if (samplesRead < samplesToRead && (voice->mFlags & AudioSourceInstance::LOOPING))
 			{
-				if (voice->mDelaySamples > aSamplesToRead)
+				while (samplesRead < samplesToRead && voice->seek(voice->mLoopPoint, channelBuffer + samplesRead * voice->mChannels,
+				                                                  (samplesToRead - samplesRead) * voice->mChannels) == SO_NO_ERROR)
 				{
-					outofs = aSamplesToRead;
-					voice->mDelaySamples -= aSamplesToRead;
-				}
-				else
-				{
-					outofs = voice->mDelaySamples;
-					voice->mDelaySamples = 0;
+					voice->mLoopCount++;
+					unsigned int loopSamples =
+					    voice->getAudio(channelBuffer + samplesRead * voice->mChannels, samplesToRead - samplesRead, samplesToRead - samplesRead);
+					samplesRead += loopSamples;
+					if (loopSamples == 0)
+						break;
 				}
+			}
 
-				// Clear scratch where we're skipping
-				unsigned int k;
-				for (k = 0; k < voice->mChannels; k++)
+			// Apply filters to source data
+			if (samplesRead > 0)
+			{
+				for (unsigned int j = 0; j < FILTERS_PER_STREAM; j++)
 				{
-					memset(aScratch + k * aBufferSize, 0, sizeof(float) * outofs);
+					if (voice->mFilter[j])
+					{
+						voice->mFilter[j]->filter(channelBuffer, samplesRead, samplesToRead, voice->mChannels, voice->mSamplerate, voice->mStreamTime);
+					}
 				}
 			}
 
-			while (step_fixed != 0 && outofs < aSamplesToRead)
+			// Copy from channel-separated scratch buffer to resample buffers
+			for (unsigned int ch = 0; ch < voice->mChannels; ch++)
 			{
-				if (voice->mLeftoverSamples == 0)
+				float *srcChannel = channelBuffer + ch * samplesToRead;
+				float *dstChannel = voice->mResampleBuffer[ch] + voice->mResampleBufferFill;
+				memcpy(dstChannel, srcChannel, samplesRead * sizeof(float));
+
+				// Clear remaining space if we read fewer samples than requested
+				if (samplesRead < samplesToRead)
 				{
-					// Swap resample buffers (ping-pong)
-					float *t = voice->mResampleData[0];
-					voice->mResampleData[0] = voice->mResampleData[1];
-					voice->mResampleData[1] = t;
+					memset(dstChannel + samplesRead, 0, (samplesToRead - samplesRead) * sizeof(float));
+				}
+			}
+		}
+	}
 
-					// Get a block of source data
+	voice->mResampleBufferFill += samplesRead;
+	return voice->mResampleBufferFill - voice->mResampleBufferPos;
+}
 
-					int readcount = 0;
-					if (!voice->hasEnded() || voice->mFlags & AudioSourceInstance::LOOPING)
-					{
-						readcount = voice->getAudio(voice->mResampleData[0], SAMPLE_GRANULARITY, SAMPLE_GRANULARITY);
-						if (readcount < SAMPLE_GRANULARITY)
-						{
-							if (voice->mFlags & AudioSourceInstance::LOOPING)
-							{
-								while (readcount < SAMPLE_GRANULARITY && voice->seek(voice->mLoopPoint, mScratch.mData, mScratchSize) == SO_NO_ERROR)
-								{
-									voice->mLoopCount++;
-									int inc = voice->getAudio(voice->mResampleData[0] + readcount, SAMPLE_GRANULARITY - readcount, SAMPLE_GRANULARITY);
-									readcount += inc;
-									if (inc == 0)
-										break;
-								}
-							}
-						}
-					}
+// Improved resampling function that handles arbitrary ratios precisely
+unsigned int Soloud::resampleVoicePrecise_internal(AudioSourceInstance *voice,
+                                                   float *outputBuffer,
+                                                   unsigned int outputSamples,
+                                                   unsigned int outputStride,
+                                                   double outputSampleRate,
+                                                   unsigned int resampler,
+                                                   float *scratchBuffer,
+                                                   unsigned int scratchSize)
+{
+	if (outputSamples == 0 || !voice)
+		return 0;
 
-					// Clear remaining of the resample data if the full scratch wasn't used
-					if (readcount < SAMPLE_GRANULARITY)
-					{
-						unsigned int k;
-						for (k = 0; k < voice->mChannels; k++)
-							memset(voice->mResampleData[0] + readcount + SAMPLE_GRANULARITY * k, 0, sizeof(float) * (SAMPLE_GRANULARITY - readcount));
-					}
+	// Calculate step size (how much we advance in source per output sample)
+	double stepSize = voice->mSamplerate / outputSampleRate;
 
-					// If we go past zero, crop to zero (a bit of a kludge)
-					if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
-					{
-						voice->mSrcOffset = 0;
-					}
-					else
-					{
-						// We have new block of data, move pointer backwards
-						voice->mSrcOffset -= SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL;
-					}
+	// Determine lookahead requirements
+	unsigned int lookaheadSamples = 0;
+	switch (resampler)
+	{
+	case RESAMPLER_POINT:
+		lookaheadSamples = 1;
+		break;
+	case RESAMPLER_LINEAR:
+		lookaheadSamples = 2;
+		break;
+	case RESAMPLER_CATMULLROM:
+		lookaheadSamples = 4;
+		break;
+	default:
+		lookaheadSamples = 2;
+		break;
+	}
 
-					// Run the per-stream filters to get our source data
+	// For chunked processing, we may not be able to produce all requested samples
+	// if we run out of source data. That's okay - we'll get more on the next call.
+	unsigned int samplesProduced = 0;
+	unsigned int samplesToProcess = outputSamples;
 
-					for (j = 0; j < FILTERS_PER_STREAM; j++)
-					{
-						if (voice->mFilter[j])
-						{
-							voice->mFilter[j]->filter(
-							    voice->mResampleData[0], SAMPLE_GRANULARITY, SAMPLE_GRANULARITY, voice->mChannels, voice->mSamplerate, mStreamTime);
-						}
-					}
-				}
-				else
-				{
-					voice->mLeftoverSamples = 0;
-				}
+	// Limit processing to one chunk worth of output to maintain low latency
+	// This prevents excessive buffering for high sample rate ratios
+	const unsigned int MAX_OUTPUT_CHUNK = AudioSourceInstance::CHUNK_SIZE;
+	if (samplesToProcess > MAX_OUTPUT_CHUNK)
+	{
+		samplesToProcess = MAX_OUTPUT_CHUNK;
+	}
 
-				// Figure out how many samples we can generate from this source data.
-				// The value may be zero.
+	// Calculate how much input we need for this chunk of output
+	unsigned int inputNeeded = (unsigned int)ceil(samplesToProcess * stepSize) + lookaheadSamples + 8;
+	unsigned int availableInput = ensureSourceData_internal(voice, inputNeeded, scratchBuffer, scratchSize);
 
-				unsigned int writesamples = 0;
+	if (availableInput < lookaheadSamples)
+	{
+		return 0; // Not enough input data available
+	}
 
-				if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
-				{
-					writesamples = ((SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL) - voice->mSrcOffset) / step_fixed + 1;
+	// If no output buffer provided (tick-only mode), just advance position
+	if (!outputBuffer)
+	{
+		// Calculate how many samples we can actually advance through
+		double maxAdvance = (availableInput - lookaheadSamples) / stepSize;
+		unsigned int actualSamples = (unsigned int)maxAdvance;
+		if (actualSamples > samplesToProcess)
+			actualSamples = samplesToProcess;
 
-					// avoid reading past the current buffer..
-					if (((writesamples * step_fixed + voice->mSrcOffset) >> FIXPOINT_FRAC_BITS) >= SAMPLE_GRANULARITY)
-						writesamples--;
-				}
+		voice->mPreciseSrcPosition += actualSamples * stepSize;
 
-				// If this is too much for our output buffer, don't write that many:
-				if (writesamples + outofs > aSamplesToRead)
-				{
-					voice->mLeftoverSamples = (writesamples + outofs) - aSamplesToRead;
-					writesamples = aSamplesToRead - outofs;
-				}
+		// Update buffer position for consumed integer samples
+		unsigned int integralConsumed = (unsigned int)floor(voice->mPreciseSrcPosition);
+		if (integralConsumed > 0 && integralConsumed <= availableInput)
+		{
+			voice->mResampleBufferPos += integralConsumed;
+			voice->mPreciseSrcPosition -= integralConsumed;
+		}
+		return actualSamples;
+	}
 
-				// Call resampler to generate the samples, once per channel
-				if (writesamples)
-				{
-					for (j = 0; j < voice->mChannels; j++)
-					{
-						switch (aResampler)
-						{
-						case RESAMPLER_POINT:
-							resample_point(voice->mResampleData[0] + SAMPLE_GRANULARITY * j,
-							               voice->mResampleData[1] + SAMPLE_GRANULARITY * j,
-							               aScratch + aBufferSize * j + outofs,
-							               voice->mSrcOffset,
-							               writesamples,
-							               /*voice->mSamplerate,
-							               aSamplerate,*/
-							               step_fixed);
-							break;
-						case RESAMPLER_CATMULLROM:
-							resample_catmullrom(voice->mResampleData[0] + SAMPLE_GRANULARITY * j,
-							                    voice->mResampleData[1] + SAMPLE_GRANULARITY * j,
-							                    aScratch + aBufferSize * j + outofs,
-							                    voice->mSrcOffset,
-							                    writesamples,
-							                    /*voice->mSamplerate,
-							                    aSamplerate,*/
-							                    step_fixed);
-							break;
-						default:
-							// case RESAMPLER_LINEAR:
-							resample_linear(voice->mResampleData[0] + SAMPLE_GRANULARITY * j,
-							                voice->mResampleData[1] + SAMPLE_GRANULARITY * j,
-							                aScratch + aBufferSize * j + outofs,
-							                voice->mSrcOffset,
-							                writesamples,
-							                /*voice->mSamplerate,
-							                aSamplerate,*/
-							                step_fixed);
-							break;
-						}
-					}
-				}
+	// Resample each channel
+	for (unsigned int ch = 0; ch < voice->mChannels; ch++)
+	{
+		double srcPos = voice->mPreciseSrcPosition;
+		float *src = voice->mResampleBuffer[ch] + voice->mResampleBufferPos;
+		float *dst = outputBuffer + ch * outputStride;
 
-				// Keep track of how many samples we've written so far
-				outofs += writesamples;
+		for (unsigned int i = 0; i < samplesToProcess; i++)
+		{
+			unsigned int intPos = (unsigned int)floor(srcPos);
 
-				// Move source pointer onwards (writesamples may be zero)
-				voice->mSrcOffset += writesamples * step_fixed;
+			// Check bounds, stop if we don't have enough input data
+			if (intPos + lookaheadSamples > availableInput)
+			{
+				samplesProduced = i;
+				break;
 			}
 
-			// Handle panning and channel expansion (and/or shrinking)
-			panAndExpand(voice, aBuffer, aSamplesToRead, aBufferSize, aScratch, aChannels);
+			double frac = srcPos - intPos;
 
-			// clear voice if the sound is over
-			if (!(voice->mFlags & (AudioSourceInstance::LOOPING | AudioSourceInstance::DISABLE_AUTOSTOP)) && voice->hasEnded())
+			// Perform resampling with boundary protection
+			switch (resampler)
 			{
-				stopVoice_internal(mActiveVoice[i]);
+			case RESAMPLER_POINT:
+				dst[i] = src[intPos];
+				break;
+
+			case RESAMPLER_LINEAR: {
+				float s0 = src[intPos];
+				float s1 = (intPos + 1 < availableInput) ? src[intPos + 1] : src[intPos];
+				dst[i] = s0 + (s1 - s0) * (float)frac;
+				break;
 			}
-		}
-		else if (voice && voice->mBusHandle == aBus && !(voice->mFlags & AudioSourceInstance::PAUSED) && (voice->mFlags & AudioSourceInstance::INAUDIBLE) &&
-		         (voice->mFlags & AudioSourceInstance::INAUDIBLE_TICK))
-		{
-			// Inaudible but needs ticking. Do minimal work (keep counters up to date and ask audiosource for data)
-			float step = voice->mSamplerate / aSamplerate;
-			int step_fixed = (int)floor(step * FIXPOINT_FRAC_MUL);
-			unsigned int outofs = 0;
 
-			if (voice->mDelaySamples)
-			{
-				if (voice->mDelaySamples > aSamplesToRead)
-				{
-					outofs = aSamplesToRead;
-					voice->mDelaySamples -= aSamplesToRead;
-				}
-				else
-				{
-					outofs = voice->mDelaySamples;
-					voice->mDelaySamples = 0;
-				}
+			default:
+			case RESAMPLER_CATMULLROM: {
+				float p0 = (intPos >= 1) ? src[intPos - 1] : src[intPos];
+				float p1 = src[intPos];
+				float p2 = (intPos + 1 < availableInput) ? src[intPos + 1] : src[intPos];
+				float p3 = (intPos + 2 < availableInput) ? src[intPos + 2] : src[intPos];
+
+				float t = (float)frac;
+				dst[i] = 0.5f * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t + (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t);
+				break;
+			}
 			}
 
-			while (step_fixed != 0 && outofs < aSamplesToRead)
-			{
-				if (voice->mLeftoverSamples == 0)
-				{
-					// Swap resample buffers (ping-pong)
-					float *t = voice->mResampleData[0];
-					voice->mResampleData[0] = voice->mResampleData[1];
-					voice->mResampleData[1] = t;
+			srcPos += stepSize;
+		}
 
-					// Get a block of source data
+		// All channels should produce the same number of samples
+		if (ch == 0)
+		{
+			samplesProduced = (samplesProduced == 0) ? samplesToProcess : samplesProduced;
+		}
+	}
 
-					int readcount = 0;
-					if (!voice->hasEnded() || voice->mFlags & AudioSourceInstance::LOOPING)
-					{
-						readcount = voice->getAudio(voice->mResampleData[0], SAMPLE_GRANULARITY, SAMPLE_GRANULARITY);
-						if (readcount < SAMPLE_GRANULARITY)
-						{
-							if (voice->mFlags & AudioSourceInstance::LOOPING)
-							{
-								while (readcount < SAMPLE_GRANULARITY && voice->seek(voice->mLoopPoint, mScratch.mData, mScratchSize) == SO_NO_ERROR)
-								{
-									voice->mLoopCount++;
-									readcount += voice->getAudio(voice->mResampleData[0] + readcount, SAMPLE_GRANULARITY - readcount, SAMPLE_GRANULARITY);
-								}
-							}
-						}
-					}
+	// Update position tracking with precise accumulation
+	double totalAdvance = samplesProduced * stepSize;
+	voice->mPreciseSrcPosition += totalAdvance;
 
-					// If we go past zero, crop to zero (a bit of a kludge)
-					if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
-					{
-						voice->mSrcOffset = 0;
-					}
-					else
-					{
-						// We have new block of data, move pointer backwards
-						voice->mSrcOffset -= SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL;
-					}
+	// Update buffer position for consumed integer samples
+	unsigned int integralConsumed = (unsigned int)floor(voice->mPreciseSrcPosition);
+	if (integralConsumed > 0 && integralConsumed <= availableInput)
+	{
+		voice->mResampleBufferPos += integralConsumed;
+		voice->mPreciseSrcPosition -= integralConsumed; // Keep fractional part
+	}
 
-					// Skip filters
-				}
-				else
-				{
-					voice->mLeftoverSamples = 0;
-				}
+	return samplesProduced;
+}
 
-				// Figure out how many samples we can generate from this source data.
-				// The value may be zero.
+// dynamic resampling + chunked processing
+void Soloud::mixBus_internal(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize, float *aScratch, unsigned int aBus, float aSamplerate,
+                             unsigned int aChannels, unsigned int aResampler)
+{
+	unsigned int i, j;
 
-				unsigned int writesamples = 0;
+	// Clear accumulation buffer
+	for (i = 0; i < aSamplesToRead; i++)
+	{
+		for (j = 0; j < aChannels; j++)
+		{
+			aBuffer[i + j * aBufferSize] = 0;
+		}
+	}
 
-				if (voice->mSrcOffset < SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL)
-				{
-					writesamples = ((SAMPLE_GRANULARITY * FIXPOINT_FRAC_MUL) - voice->mSrcOffset) / step_fixed + 1;
+	// scratch space for chunked processing
+	unsigned int voiceScratchSize = MAX_CHANNELS * aBufferSize;
+	unsigned int tempScratchSize = 2048; // temp buffer for chunk-based reading
+	unsigned int delayScratchSize = aChannels * aBufferSize;
+	unsigned int totalPerVoice = voiceScratchSize + tempScratchSize + delayScratchSize;
+	unsigned int maxVoicesInParallel = (mScratchSize * MAX_CHANNELS) / totalPerVoice;
+	if (maxVoicesInParallel == 0)
+		maxVoicesInParallel = 1;
 
-					// avoid reading past the current buffer..
-					if (((writesamples * step_fixed + voice->mSrcOffset) >> FIXPOINT_FRAC_BITS) >= SAMPLE_GRANULARITY)
-						writesamples--;
-				}
+	// Process each active voice using chunks
+	for (i = 0; i < mActiveVoiceCount; i++)
+	{
+		AudioSourceInstance *voice = mVoice[mActiveVoice[i]];
+		if (!voice || voice->mBusHandle != aBus)
+			continue;
 
-				// If this is too much for our output buffer, don't write that many:
-				if (writesamples + outofs > aSamplesToRead)
-				{
-					voice->mLeftoverSamples = (writesamples + outofs) - aSamplesToRead;
-					writesamples = aSamplesToRead - outofs;
-				}
+		bool isPaused = (voice->mFlags & AudioSourceInstance::PAUSED) != 0;
+		bool isInaudible = (voice->mFlags & AudioSourceInstance::INAUDIBLE) != 0;
+		bool mustTick = (voice->mFlags & AudioSourceInstance::INAUDIBLE_TICK) != 0;
 
-				// Skip resampler
+		bool isAudible = !isPaused && !isInaudible;
+		bool shouldProcess = isAudible || (!isPaused && mustTick);
 
-				// Keep track of how many samples we've written so far
-				outofs += writesamples;
+		if (!shouldProcess)
+			continue;
 
-				// Move source pointer onwards (writesamples may be zero)
-				voice->mSrcOffset += writesamples * step_fixed;
-			}
+		unsigned int outputSamples = aSamplesToRead;
+		unsigned int outputOffset = 0;
 
-			// clear voice if the sound is over
-			if (!(voice->mFlags & (AudioSourceInstance::LOOPING | AudioSourceInstance::DISABLE_AUTOSTOP)) && voice->hasEnded())
+		// Handle delay samples
+		if (voice->mDelaySamples > 0)
+		{
+			if (voice->mDelaySamples >= aSamplesToRead)
 			{
-				stopVoice_internal(mActiveVoice[i]);
+				voice->mDelaySamples -= aSamplesToRead;
+				continue;
+			}
+			else
+			{
+				outputOffset = voice->mDelaySamples;
+				outputSamples = aSamplesToRead - voice->mDelaySamples;
+				voice->mDelaySamples = 0;
 			}
 		}
-	}
-}
 
-void Soloud::mapResampleBuffers_internal()
-{
-	SOLOUD_ASSERT(mMaxActiveVoices < 256);
-	char live[256];
-	memset(live, 0, mMaxActiveVoices);
-	unsigned int i, j;
-	for (i = 0; i < mMaxActiveVoices; i++)
-	{
-		for (j = 0; j < mMaxActiveVoices; j++)
+		if (outputSamples == 0)
+			continue;
+
+		// Allocate scratch space for this voice
+		unsigned int voiceSlot = i % maxVoicesInParallel;
+		float *voiceScratch = aScratch + (voiceSlot * totalPerVoice);
+		float *tempScratch = voiceScratch + voiceScratchSize;
+		float *delayScratch = tempScratch + tempScratchSize;
+
+		// Adjust temp scratch size if needed
+		unsigned int actualTempScratchSize = tempScratchSize;
+		if (voiceSlot == maxVoicesInParallel - 1)
 		{
-			if (mResampleDataOwner[i] && mResampleDataOwner[i] == mVoice[mActiveVoice[j]])
+			unsigned int remainingSpace = (mScratchSize * MAX_CHANNELS) - (voiceSlot * totalPerVoice + voiceScratchSize + delayScratchSize);
+			if (remainingSpace < tempScratchSize)
 			{
-				live[i] |= 1; // Live channel
-				live[j] |= 2; // Live voice
+				actualTempScratchSize = remainingSpace;
 			}
 		}
-	}
 
-	for (i = 0; i < mMaxActiveVoices; i++)
-	{
-		if (!(live[i] & 1) && mResampleDataOwner[i]) // For all dead channels with owners..
+		// Process in chunks - may require multiple iterations to fill output buffer
+		unsigned int totalProduced = 0;
+		while (totalProduced < outputSamples)
 		{
-			mResampleDataOwner[i]->mResampleData[0] = 0;
-			mResampleDataOwner[i]->mResampleData[1] = 0;
-			mResampleDataOwner[i] = 0;
+			unsigned int remainingSamples = outputSamples - totalProduced;
+			unsigned int chunkOutput = remainingSamples;
+
+			// Limit chunk size to maintain low latency
+			const unsigned int MAX_CHUNK = AudioSourceInstance::CHUNK_SIZE;
+			if (chunkOutput > MAX_CHUNK)
+				chunkOutput = MAX_CHUNK;
+
+			if (isAudible)
+			{
+				// Point to the right offset in the voice scratch buffer
+				float *chunkScratch = voiceScratch;
+				for (unsigned int ch = 0; ch < voice->mChannels; ch++)
+				{
+					// Offset each channel's scratch by totalProduced
+					memset(chunkScratch + ch * aBufferSize + totalProduced, 0, chunkOutput * sizeof(float));
+				}
+
+				// Resample this chunk
+				unsigned int samplesProduced = resampleVoicePrecise_internal(voice,
+				                                                             chunkScratch + totalProduced, // Offset scratch buffer
+				                                                             chunkOutput,
+				                                                             aBufferSize,
+				                                                             aSamplerate,
+				                                                             aResampler,
+				                                                             tempScratch,
+				                                                             actualTempScratchSize);
+
+				if (samplesProduced == 0)
+				{
+					// No more samples available, break out
+					break;
+				}
+
+				totalProduced += samplesProduced;
+
+				// If we got fewer samples than requested, we're done
+				if (samplesProduced < chunkOutput)
+				{
+					break;
+				}
+			}
+			else if (mustTick && !isPaused)
+			{
+				// Just advance the voice without producing audio
+				unsigned int samplesAdvanced =
+				    resampleVoicePrecise_internal(voice, NULL, chunkOutput, 0, aSamplerate, aResampler, tempScratch, actualTempScratchSize);
+
+				if (samplesAdvanced == 0)
+					break;
+
+				totalProduced += samplesAdvanced;
+			}
+			else
+			{
+				break;
+			}
 		}
-	}
 
-	int latestfree = 0;
-	for (i = 0; i < mActiveVoiceCount; i++)
-	{
-		if (!(live[i] & 2) && mVoice[mActiveVoice[i]]) // For all live voices with no channel..
+		// Mix the accumulated samples into the output buffer
+		if (isAudible && totalProduced > 0)
 		{
-			int found = -1;
-			for (j = latestfree; found == -1 && j < mMaxActiveVoices; j++)
+			if (outputOffset == 0)
 			{
-				if (mResampleDataOwner[j] == 0)
+				// No delay, mix directly
+				panAndExpand(voice, aBuffer, totalProduced, aBufferSize, voiceScratch, aChannels);
+			}
+			else
+			{
+				// Apply delay using delay scratch buffer
+				memset(delayScratch, 0, aChannels * aBufferSize * sizeof(float));
+				panAndExpand(voice, delayScratch, totalProduced, aBufferSize, voiceScratch, aChannels);
+
+				// Mix with offset
+				for (unsigned int ch = 0; ch < aChannels; ch++)
 				{
-					found = j;
+					for (unsigned int s = 0; s < totalProduced; s++)
+					{
+						if (s + outputOffset < aSamplesToRead)
+						{
+							aBuffer[(s + outputOffset) + ch * aBufferSize] += delayScratch[s + ch * aBufferSize];
+						}
+					}
 				}
 			}
-			SOLOUD_ASSERT(found != -1);
-			mResampleDataOwner[found] = mVoice[mActiveVoice[i]];
-			mResampleDataOwner[found]->mResampleData[0] = mResampleData[found * 2 + 0];
-			mResampleDataOwner[found]->mResampleData[1] = mResampleData[found * 2 + 1];
-			memset(mResampleDataOwner[found]->mResampleData[0], 0, sizeof(float) * SAMPLE_GRANULARITY * MAX_CHANNELS);
-			memset(mResampleDataOwner[found]->mResampleData[1], 0, sizeof(float) * SAMPLE_GRANULARITY * MAX_CHANNELS);
-			latestfree = found + 1;
+		}
+
+		// Check if voice should be stopped - use small lookahead for chunked approach
+		unsigned int remainingSamples = voice->mResampleBufferFill - voice->mResampleBufferPos;
+		unsigned int lookaheadSamples = (aResampler == RESAMPLER_CATMULLROM) ? 4 : 2;
+		bool bufferNearEmpty = remainingSamples <= lookaheadSamples;
+
+		if (!(voice->mFlags & (AudioSourceInstance::LOOPING | AudioSourceInstance::DISABLE_AUTOSTOP)) && voice->hasEnded() && bufferNearEmpty)
+		{
+			stopVoice_internal(mActiveVoice[i]);
 		}
 	}
 }
@@ -2006,7 +2079,6 @@ void Soloud::calcActiveVoices_internal()
 	{
 		// everything is audible, early out
 		mActiveVoiceCount = candidates;
-		mapResampleBuffers_internal();
 		return;
 	}
 
@@ -2062,7 +2134,6 @@ void Soloud::calcActiveVoices_internal()
 		len = stack[--pos];
 	}
 	// TODO: should the rest of the voices be flagged INAUDIBLE?
-	mapResampleBuffers_internal();
 }
 
 void Soloud::mix_internal(unsigned int aSamples, unsigned int aStride)
diff --git a/src/core/soloud_audiosource.cpp b/src/core/soloud_audiosource.cpp
index 539941e..713eea7 100644
--- a/src/core/soloud_audiosource.cpp
+++ b/src/core/soloud_audiosource.cpp
@@ -23,6 +23,7 @@ freely, subject to the following restrictions:
 */
 
 #include "soloud.h"
+#include <cstring>
 
 namespace SoLoud
 {
@@ -94,14 +95,20 @@ AudioSourceInstance::AudioSourceInstance()
 	{
 		mCurrentChannelVolume[i] = 0;
 	}
-	// behind pointers because we swap between the two buffers
-	mResampleData[0] = 0;
-	mResampleData[1] = 0;
-	mSrcOffset = 0;
-	mLeftoverSamples = 0;
+
 	mDelaySamples = 0;
 	mOverallVolume = 0;
 	mOverallRelativePlaySpeed = 1;
+
+	mResampleBufferFill = 0;
+	mResampleBufferPos = 0;
+	mPreciseSrcPosition = 0.0;
+
+	// Clear resample buffers
+	for (i = 0; i < MAX_CHANNELS; i++)
+	{
+		memset(mResampleBuffer[i], 0, sizeof(mResampleBuffer[i]));
+	}
 }
 
 AudioSourceInstance::~AudioSourceInstance()
@@ -123,6 +130,16 @@ void AudioSourceInstance::init(AudioSource &aSource, int aPlayIndex)
 	mStreamPosition = 0.0f;
 	mLoopPoint = aSource.mLoopPoint;
 
+	mResampleBufferFill = 0;
+	mResampleBufferPos = 0;
+	mPreciseSrcPosition = 0.0;
+
+	// Clear resample buffers
+	for (unsigned int ch = 0; ch < MAX_CHANNELS; ch++)
+	{
+		memset(mResampleBuffer[ch], 0, sizeof(mResampleBuffer[ch]));
+	}
+
 	if (aSource.mFlags & AudioSource::SHOULD_LOOP)
 	{
 		mFlags |= AudioSourceInstance::LOOPING;
diff --git a/src/core/soloud_core_setters.cpp b/src/core/soloud_core_setters.cpp
index 0a80a9f..cdb5fbb 100644
--- a/src/core/soloud_core_setters.cpp
+++ b/src/core/soloud_core_setters.cpp
@@ -78,16 +78,6 @@ result Soloud::setMaxActiveVoiceCount(unsigned int aVoiceCount)
 		return INVALID_PARAMETER;
 	lockAudioMutex_internal();
 	mMaxActiveVoices = aVoiceCount;
-	delete[] mResampleData;
-	delete[] mResampleDataOwner;
-	mResampleData = new float *[aVoiceCount * 2];
-	mResampleDataOwner = new AudioSourceInstance *[aVoiceCount];
-	mResampleDataBuffer.init(SAMPLE_GRANULARITY * MAX_CHANNELS * aVoiceCount * 2);
-	unsigned int i;
-	for (i = 0; i < aVoiceCount * 2; i++)
-		mResampleData[i] = mResampleDataBuffer.mData + (SAMPLE_GRANULARITY * MAX_CHANNELS * i);
-	for (i = 0; i < aVoiceCount; i++)
-		mResampleDataOwner[i] = NULL;
 	mActiveVoiceDirty = true;
 	unlockAudioMutex_internal();
 	return SO_NO_ERROR;
diff --git a/src/core/soloud_core_voiceops.cpp b/src/core/soloud_core_voiceops.cpp
index 7ad96f0..6a5d4af 100644
--- a/src/core/soloud_core_voiceops.cpp
+++ b/src/core/soloud_core_voiceops.cpp
@@ -124,15 +124,6 @@ void Soloud::stopVoice_internal(unsigned int aVoice)
 		AudioSourceInstance *v = mVoice[aVoice];
 		mVoice[aVoice] = 0;
 
-		unsigned int i;
-		for (i = 0; i < mMaxActiveVoices; i++)
-		{
-			if (mResampleDataOwner[i] == v)
-			{
-				mResampleDataOwner[i] = NULL;
-			}
-		}
-
 		delete v;
 	}
 }
-- 
2.49.0


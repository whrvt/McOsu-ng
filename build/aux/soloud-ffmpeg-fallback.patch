From 324fb0a6d6fa3feef324eb1b5d3d783cd65e7fbc Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Sun, 8 Jun 2025 01:51:53 -0700
Subject: [PATCH] WIP: ffmpeg fallback for wav/wavstreams

---
 include/soloud_wav.h                       |   79 +-
 include/soloud_wavstream.h                 |  141 +--
 src/audiosource/wav/soloud_ffmpeg.cpp      |  760 ++++++++++++
 src/audiosource/wav/soloud_ffmpeg.h        |  110 ++
 src/audiosource/wav/soloud_ffmpeg_load.cpp |  355 ++++++
 src/audiosource/wav/soloud_ffmpeg_load.h   |  170 +++
 src/audiosource/wav/soloud_wav.cpp         |  628 +++++-----
 src/audiosource/wav/soloud_wavstream.cpp   | 1227 +++++++++++---------
 8 files changed, 2498 insertions(+), 972 deletions(-)
 create mode 100644 src/audiosource/wav/soloud_ffmpeg.cpp
 create mode 100644 src/audiosource/wav/soloud_ffmpeg.h
 create mode 100644 src/audiosource/wav/soloud_ffmpeg_load.cpp
 create mode 100644 src/audiosource/wav/soloud_ffmpeg_load.h

diff --git a/include/soloud_wav.h b/include/soloud_wav.h
index ab3be0b..7d7735d 100755
--- a/include/soloud_wav.h
+++ b/include/soloud_wav.h
@@ -31,44 +31,47 @@ struct stb_vorbis;
 
 namespace SoLoud
 {
-	class Wav;
-	class File;
-	class MemoryFile;
-
-	class WavInstance : public AudioSourceInstance
-	{
-		Wav *mParent;
-		unsigned int mOffset;
-	public:
-		WavInstance(Wav *aParent);
-		virtual unsigned int getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize);
-		virtual result rewind();
-		virtual bool hasEnded();
-	};
-
-	class Wav : public AudioSource
-	{
-		result loadwav(MemoryFile *aReader);
-		result loadogg(MemoryFile *aReader);
-		result loadmp3(MemoryFile *aReader);
-		result loadflac(MemoryFile *aReader);
-		result testAndLoadFile(MemoryFile *aReader);
-	public:
-		float *mData;
-		unsigned int mSampleCount;
-
-		Wav();
-		virtual ~Wav();
-		result load(const char *aFilename);
-		result loadMem(const unsigned char *aMem, unsigned int aLength, bool aCopy = false, bool aTakeOwnership = true);
-		result loadFile(File *aFile);
-		result loadRawWave8(unsigned char *aMem, unsigned int aLength, float aSamplerate = 44100.0f, unsigned int aChannels = 1);
-		result loadRawWave16(short *aMem, unsigned int aLength, float aSamplerate = 44100.0f, unsigned int aChannels = 1);
-		result loadRawWave(float *aMem, unsigned int aLength, float aSamplerate = 44100.0f, unsigned int aChannels = 1, bool aCopy = false, bool aTakeOwnership = true);
-
-		virtual AudioSourceInstance *createInstance();
-		time getLength();
-	};
+class Wav;
+class File;
+class MemoryFile;
+
+class WavInstance : public AudioSourceInstance
+{
+	Wav *mParent;
+	unsigned int mOffset;
+
+public:
+	WavInstance(Wav *aParent);
+	virtual unsigned int getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize);
+	virtual result rewind();
+	virtual bool hasEnded();
+};
+
+class Wav : public AudioSource
+{
+	result loadwav(MemoryFile *aReader);
+	result loadogg(MemoryFile *aReader);
+	result loadmp3(MemoryFile *aReader);
+	result loadflac(MemoryFile *aReader);
+	result loadffmpeg(MemoryFile *aReader);
+	result testAndLoadFile(MemoryFile *aReader);
+
+public:
+	float *mData;
+	unsigned int mSampleCount;
+
+	Wav();
+	virtual ~Wav();
+	result load(const char *aFilename);
+	result loadMem(const unsigned char *aMem, unsigned int aLength, bool aCopy = false, bool aTakeOwnership = true);
+	result loadFile(File *aFile);
+	result loadRawWave8(unsigned char *aMem, unsigned int aLength, float aSamplerate = 44100.0f, unsigned int aChannels = 1);
+	result loadRawWave16(short *aMem, unsigned int aLength, float aSamplerate = 44100.0f, unsigned int aChannels = 1);
+	result loadRawWave(float *aMem, unsigned int aLength, float aSamplerate = 44100.0f, unsigned int aChannels = 1, bool aCopy = false, bool aTakeOwnership = true);
+
+	virtual AudioSourceInstance *createInstance();
+	time getLength();
 };
+}; // namespace SoLoud
 
 #endif
diff --git a/include/soloud_wavstream.h b/include/soloud_wavstream.h
index 1f8e86a..ea815b1 100644
--- a/include/soloud_wavstream.h
+++ b/include/soloud_wavstream.h
@@ -41,73 +41,82 @@ typedef unsigned int drmp3_uint32;
 struct drwav;
 #endif
 
+
 namespace SoLoud
 {
-	class WavStream;
-	class File;
-
-	class WavStreamInstance : public AudioSourceInstance
-	{
-		WavStream *mParent;
-		unsigned int mOffset;
-		File *mFile;
-		union codec
-		{
-			stb_vorbis *mOgg;
-			drflac *mFlac;
-			drmp3 *mMp3;
-			drwav *mWav;
-		} mCodec;
-		unsigned int mOggFrameSize;
-		unsigned int mOggFrameOffset;
-		float **mOggOutputs;
-	public:
-		WavStreamInstance(WavStream *aParent);
-		virtual unsigned int getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize);
-		virtual result seek(double aSeconds, float* mScratch, unsigned int mScratchSize);
-		virtual result rewind();
-		virtual bool hasEnded();
-		virtual ~WavStreamInstance();
-	};
-
-	enum WAVSTREAM_FILETYPE
-	{
-		WAVSTREAM_WAV = 0,
-		WAVSTREAM_OGG = 1,
-		WAVSTREAM_FLAC = 2,
-		WAVSTREAM_MP3 = 3
-	};
-
-	class WavStream : public AudioSource
-	{
-		result loadwav(File *fp);
-		result loadogg(File *fp);
-		result loadflac(File *fp);
-		result loadmp3(File *fp);
-	public:
-		int mFiletype;
-		char *mFilename;
-		File *mMemFile;
-		File *mStreamFile;
-		unsigned int mSampleCount;
-
-		// mp3 seek tables
-		drmp3_seek_point* mMp3SeekPoints;
-		drmp3_uint32 mMp3SeekPointCount;
-
-		WavStream();
-		virtual ~WavStream();
-		result load(const char *aFilename);
-		result loadMem(const unsigned char *aData, unsigned int aDataLen, bool aCopy = false, bool aTakeOwnership = true);
-		result loadToMem(const char *aFilename);
-		result loadFile(File *aFile);
-		result loadFileToMem(File *aFile);
-		virtual AudioSourceInstance *createInstance();
-		time getLength();
-
-	public:
-		result parse(File *aFile);
-	};
+namespace FFmpeg
+{
+	struct FFmpegDecoder;
+}
+class WavStream;
+class File;
+
+class WavStreamInstance : public AudioSourceInstance
+{
+	WavStream *mParent;
+	unsigned int mOffset;
+	File *mFile;
+	union codec {
+		stb_vorbis *mOgg;
+		drflac *mFlac;
+		drmp3 *mMp3;
+		drwav *mWav;
+		FFmpeg::FFmpegDecoder *mFfmpeg;
+	} mCodec;
+	unsigned int mOggFrameSize;
+	unsigned int mOggFrameOffset;
+	float **mOggOutputs;
+
+public:
+	WavStreamInstance(WavStream *aParent);
+	virtual unsigned int getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize);
+	virtual result seek(double aSeconds, float *mScratch, unsigned int mScratchSize);
+	virtual result rewind();
+	virtual bool hasEnded();
+	virtual ~WavStreamInstance();
 };
 
-#endif
\ No newline at end of file
+enum WAVSTREAM_FILETYPE
+{
+	WAVSTREAM_WAV = 0,
+	WAVSTREAM_OGG = 1,
+	WAVSTREAM_FLAC = 2,
+	WAVSTREAM_MP3 = 3,
+	WAVSTREAM_FFMPEG = 4
+};
+
+class WavStream : public AudioSource
+{
+	result loadwav(File *fp);
+	result loadogg(File *fp);
+	result loadflac(File *fp);
+	result loadmp3(File *fp);
+	result loadffmpeg(File *fp);
+
+public:
+	int mFiletype;
+	char *mFilename;
+	File *mMemFile;
+	File *mStreamFile;
+	unsigned int mSampleCount;
+
+	// mp3 seek tables
+	drmp3_seek_point *mMp3SeekPoints;
+	drmp3_uint32 mMp3SeekPointCount;
+
+	WavStream();
+	virtual ~WavStream();
+	result load(const char *aFilename);
+	result loadMem(const unsigned char *aData, unsigned int aDataLen, bool aCopy = false, bool aTakeOwnership = true);
+	result loadToMem(const char *aFilename);
+	result loadFile(File *aFile);
+	result loadFileToMem(File *aFile);
+	virtual AudioSourceInstance *createInstance();
+	time getLength();
+
+public:
+	result parse(File *aFile);
+};
+}; // namespace SoLoud
+
+#endif
diff --git a/src/audiosource/wav/soloud_ffmpeg.cpp b/src/audiosource/wav/soloud_ffmpeg.cpp
new file mode 100644
index 0000000..95c5edf
--- /dev/null
+++ b/src/audiosource/wav/soloud_ffmpeg.cpp
@@ -0,0 +1,760 @@
+/*
+SoLoud audio engine - ffmpeg interface
+Copyright (c) 2013-2020 Jari Komppa
+Copyright (c) 2025 William Horvath (ffmpeg interface)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+   1. The origin of this software must not be misrepresented; you must not
+   claim that you wrote the original software. If you use this software
+   in a product, an acknowledgment in the product documentation would be
+   appreciated but is not required.
+
+   2. Altered source versions must be plainly marked as such, and must not be
+   misrepresented as being the original software.
+
+   3. This notice may not be removed or altered from any source
+   distribution.
+*/
+
+#if __has_include(<libavcodec/avcodec.h>) && ((defined(_WIN32) || defined(_WIN64)) || defined(__linux__))
+
+#include <algorithm>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "soloud_ffmpeg.h"
+#include "soloud_ffmpeg_load.h"
+#include "soloud_file.h"
+
+using namespace SoLoud::FFmpeg::FFmpegLoader::FFmpegFuncs;
+
+namespace SoLoud::FFmpeg
+{
+
+static const unsigned int IO_BUFFER_SIZE = 65536;
+
+struct FFmpegIOContext
+{
+	File *file;
+	int pos;
+};
+
+struct FFmpegDecoder
+{
+	AVFormatContext *formatContext;
+	AVCodecContext *codecContext;
+	SwrContext *swrContext;
+	AVFrame *frame;
+	AVPacket *packet;
+	FFmpegIOContext *ioContext;
+	AVIOContext *avioContext;
+	unsigned char *ioBuffer;
+
+	int audioStreamIndex;
+	unsigned int channels;
+	unsigned int sampleRate;
+	unsigned long long totalFrames;
+	unsigned long long currentFrame;
+	unsigned int encoderDelaySamples;
+	AVChannelLayout channelLayout;
+
+	// frame buffering for partial reads
+	float *frameBuffer;
+	unsigned int frameBufferSize;
+	unsigned int frameBufferOffset;
+	unsigned int frameBufferValidSamples;
+
+	// pts-based position tracking
+	int64_t lastFramePts;
+	bool validPts;
+	unsigned long long bufferedFramePosition;
+	bool bufferedFramePositionValid;
+
+	bool endOfStream;
+	bool seekable;
+};
+
+static int ffmpeg_read_func(void *opaque, unsigned char *buf, int buf_size)
+{
+	FFmpegIOContext *ctx = (FFmpegIOContext *)opaque;
+	if (!ctx || !ctx->file || !buf || buf_size <= 0)
+		return AVERROR_EOF;
+
+	int remaining = ctx->file->length() - ctx->pos;
+	if (remaining <= 0)
+		return AVERROR_EOF;
+
+	int toRead = (buf_size < remaining) ? buf_size : remaining;
+	ctx->file->seek(ctx->pos);
+	int read = ctx->file->read(buf, toRead);
+	if (read > 0)
+		ctx->pos += read;
+
+	return read > 0 ? read : AVERROR_EOF;
+}
+
+static int64_t ffmpeg_seek_func(void *opaque, int64_t offset, int whence)
+{
+	FFmpegIOContext *ctx = (FFmpegIOContext *)opaque;
+	if (!ctx || !ctx->file)
+		return -1;
+
+	switch (whence)
+	{
+	case SEEK_SET:
+		ctx->pos = (int)offset;
+		break;
+	case SEEK_CUR:
+		ctx->pos += (int)offset;
+		break;
+	case SEEK_END:
+		ctx->pos = ctx->file->length() + (int)offset;
+		break;
+	case AVSEEK_SIZE:
+		return ctx->file->length();
+	}
+
+	ctx->pos = std::max(0, std::min<int>(ctx->pos, ctx->file->length()));
+	return ctx->pos;
+}
+
+static unsigned long long ptsToFrames(FFmpegDecoder *decoder, int64_t pts)
+{
+	if (pts == AV_NOPTS_VALUE)
+		return decoder->currentFrame;
+
+	AVStream *stream = decoder->formatContext->streams[decoder->audioStreamIndex];
+
+	// convert pts from stream time_base to seconds, then to sample frames
+	double timeSeconds = (double)pts * stream->time_base.num / stream->time_base.den;
+	unsigned long long framePosition = (unsigned long long)(timeSeconds * decoder->sampleRate);
+
+	// subtract encoder delay to match our adjusted frame counting
+	if (framePosition >= decoder->encoderDelaySamples)
+		framePosition -= decoder->encoderDelaySamples;
+
+	return framePosition;
+}
+
+static bool decodeNextFrame(FFmpegDecoder *decoder)
+{
+	if (decoder->endOfStream)
+		return false;
+
+	while (true)
+	{
+		int ret = av_read_frame(decoder->formatContext, decoder->packet);
+		if (ret < 0)
+		{
+			// flush decoder at end of stream
+			avcodec_send_packet(decoder->codecContext, nullptr);
+			if (avcodec_receive_frame(decoder->codecContext, decoder->frame) >= 0)
+			{
+				// store frame pts if available
+				if (decoder->frame->pts != AV_NOPTS_VALUE)
+				{
+					decoder->lastFramePts = decoder->frame->pts;
+					decoder->validPts = true;
+				}
+
+				return decoder->frame->nb_samples > 0;
+			}
+			decoder->endOfStream = true;
+			return false;
+		}
+
+		if (decoder->packet->stream_index != decoder->audioStreamIndex)
+		{
+			av_packet_unref(decoder->packet);
+			continue;
+		}
+
+		if (avcodec_send_packet(decoder->codecContext, decoder->packet) >= 0)
+		{
+			av_packet_unref(decoder->packet);
+
+			if (avcodec_receive_frame(decoder->codecContext, decoder->frame) >= 0)
+			{
+				// store frame pts if available
+				if (decoder->frame->pts != AV_NOPTS_VALUE)
+				{
+					decoder->lastFramePts = decoder->frame->pts;
+					decoder->validPts = true;
+				}
+
+				return decoder->frame->nb_samples > 0;
+			}
+		}
+		else
+		{
+			av_packet_unref(decoder->packet);
+		}
+	}
+}
+
+static void convertFrameToBuffer(FFmpegDecoder *decoder)
+{
+	if (!decoder->frame || decoder->frame->nb_samples <= 0)
+		return;
+
+	unsigned int samples = decoder->frame->nb_samples;
+	unsigned int channels = decoder->channels;
+
+	// ensure frame buffer is large enough
+	unsigned int requiredSize = samples * channels;
+	if (decoder->frameBufferSize < requiredSize)
+	{
+		delete[] decoder->frameBuffer;
+		decoder->frameBuffer = new float[requiredSize];
+		decoder->frameBufferSize = requiredSize;
+	}
+
+	// update position tracking when we start consuming a new frame
+	if (decoder->validPts && decoder->lastFramePts != AV_NOPTS_VALUE)
+	{
+		decoder->bufferedFramePosition = ptsToFrames(decoder, decoder->lastFramePts);
+		decoder->bufferedFramePositionValid = true;
+
+		// sync manual tracking if it's invalid (after seek)
+		if (decoder->currentFrame == 0 && decoder->bufferedFramePosition > 0)
+			decoder->currentFrame = decoder->bufferedFramePosition;
+	}
+
+	if (decoder->codecContext->sample_fmt == AV_SAMPLE_FMT_FLTP)
+	{
+		// direct copy from planar float data
+		for (unsigned int ch = 0; ch < channels; ch++)
+		{
+			float *src = (float *)decoder->frame->data[ch];
+			float *dst = decoder->frameBuffer + ch * samples;
+			memcpy(dst, src, samples * sizeof(float));
+		}
+	}
+	else
+	{
+		// convert via resampler
+		const uint8_t *inputData[MAX_CHANNELS];
+		if (av_sample_fmt_is_planar(decoder->codecContext->sample_fmt))
+		{
+			for (unsigned int ch = 0; ch < channels; ch++)
+			{
+				inputData[ch] = decoder->frame->data[ch];
+			}
+		}
+		else
+		{
+			inputData[0] = decoder->frame->data[0];
+		}
+
+		uint8_t *outputPtrs[MAX_CHANNELS];
+		for (unsigned int ch = 0; ch < channels; ch++)
+		{
+			outputPtrs[ch] = (uint8_t *)(decoder->frameBuffer + ch * samples);
+		}
+
+		int converted = swr_convert(decoder->swrContext, outputPtrs, samples, inputData, samples);
+		if (converted > 0)
+			samples = converted;
+		else
+			samples = 0;
+	}
+
+	decoder->frameBufferValidSamples = samples;
+	decoder->frameBufferOffset = 0;
+}
+
+FFmpegDecoder *open(File *aFile, bool oneshot)
+{
+	if (!FFmpegLoader::isAvailable() || !aFile)
+		return nullptr;
+
+	auto *decoder = new FFmpegDecoder();
+	memset((void *)decoder, 0, sizeof(FFmpegDecoder));
+
+	AVStream *stream = nullptr;
+	AVCodecParameters *codecpar = nullptr;
+	const AVCodec *codec = nullptr;
+	AVDictionary *format_opts = nullptr;
+	double duration = 0.0;
+	unsigned long long totalFrames = 0;
+	unsigned int encoderDelaySamples = 0;
+
+	// setup io context
+	decoder->ioContext = new FFmpegIOContext();
+	decoder->ioContext->file = aFile;
+	decoder->ioContext->pos = 0;
+
+	decoder->ioBuffer = (unsigned char *)av_malloc(IO_BUFFER_SIZE);
+	if (!decoder->ioBuffer)
+		goto cleanup;
+
+	decoder->avioContext = avio_alloc_context(decoder->ioBuffer, IO_BUFFER_SIZE, 0, decoder->ioContext, ffmpeg_read_func, nullptr, ffmpeg_seek_func);
+	if (!decoder->avioContext)
+		goto cleanup;
+
+	decoder->formatContext = avformat_alloc_context();
+	if (!decoder->formatContext)
+		goto cleanup;
+
+	decoder->formatContext->pb = decoder->avioContext;
+
+	if (!oneshot)
+	{
+		av_dict_set(&format_opts, "flags", "low_delay", 0);
+		av_dict_set(&format_opts, "seek2any", "1", 0);
+		av_dict_set(&format_opts, "accurate_seek", "1", 0);
+	}
+
+	if (avformat_open_input(&decoder->formatContext, nullptr, nullptr, &format_opts) < 0)
+	{
+		av_dict_free(&format_opts);
+		goto cleanup;
+	}
+	av_dict_free(&format_opts);
+
+	if (avformat_find_stream_info(decoder->formatContext, nullptr) < 0)
+		goto cleanup;
+
+	// find audio stream
+	decoder->audioStreamIndex = -1;
+	for (unsigned int i = 0; i < decoder->formatContext->nb_streams; i++)
+	{
+		if (decoder->formatContext->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
+		{
+			decoder->audioStreamIndex = i;
+			break;
+		}
+	}
+
+	if (decoder->audioStreamIndex == -1)
+		goto cleanup;
+
+	// setup decoder
+	stream = decoder->formatContext->streams[decoder->audioStreamIndex];
+	codecpar = stream->codecpar;
+	codec = avcodec_find_decoder(codecpar->codec_id);
+	if (!codec)
+		goto cleanup;
+
+	decoder->codecContext = avcodec_alloc_context3(codec);
+	if (!decoder->codecContext)
+		goto cleanup;
+
+	if (avcodec_parameters_to_context(decoder->codecContext, codecpar) < 0)
+		goto cleanup;
+
+	decoder->codecContext->pkt_timebase = stream->time_base;
+	decoder->codecContext->thread_count = 1; // we're already a thread, it's not worth spawning yet more threads and keeping track of that synchronization as well
+	decoder->codecContext->thread_type = 0;
+
+	if (codec->capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE)
+		decoder->codecContext->flags2 |= AV_CODEC_FLAG2_CHUNKS;
+
+	if (avcodec_open2(decoder->codecContext, codec, nullptr) < 0)
+		goto cleanup;
+
+	// setup resampler if needed
+	if (codecpar->format != AV_SAMPLE_FMT_FLTP)
+	{
+		decoder->swrContext = swr_alloc();
+		if (!decoder->swrContext)
+			goto cleanup;
+
+		if (av_channel_layout_copy(&decoder->channelLayout, &codecpar->ch_layout) < 0)
+			goto cleanup;
+
+		if (decoder->channelLayout.nb_channels == 0)
+		{
+			av_channel_layout_uninit(&decoder->channelLayout);
+			av_channel_layout_default(&decoder->channelLayout, codecpar->ch_layout.nb_channels);
+		}
+
+		av_opt_set_chlayout(decoder->swrContext, "in_chlayout", &decoder->channelLayout, 0);
+		av_opt_set_chlayout(decoder->swrContext, "out_chlayout", &decoder->channelLayout, 0);
+		av_opt_set_int(decoder->swrContext, "in_sample_rate", codecpar->sample_rate, 0);
+		av_opt_set_int(decoder->swrContext, "out_sample_rate", codecpar->sample_rate, 0);
+		av_opt_set_sample_fmt(decoder->swrContext, "in_sample_fmt", decoder->codecContext->sample_fmt, 0);
+		av_opt_set_sample_fmt(decoder->swrContext, "out_sample_fmt", AV_SAMPLE_FMT_FLTP, 0);
+
+		if (swr_init(decoder->swrContext) < 0)
+			goto cleanup;
+	}
+	else
+	{
+		if (av_channel_layout_copy(&decoder->channelLayout, &codecpar->ch_layout) < 0)
+			goto cleanup;
+
+		if (decoder->channelLayout.nb_channels == 0)
+		{
+			av_channel_layout_uninit(&decoder->channelLayout);
+			av_channel_layout_default(&decoder->channelLayout, codecpar->ch_layout.nb_channels);
+		}
+	}
+
+	decoder->frame = av_frame_alloc();
+	decoder->packet = av_packet_alloc();
+	if (!decoder->frame || !decoder->packet)
+		goto cleanup;
+
+	decoder->channels = decoder->channelLayout.nb_channels;
+	decoder->sampleRate = codecpar->sample_rate;
+	decoder->currentFrame = 0;
+	decoder->endOfStream = false;
+	decoder->seekable = (decoder->formatContext->pb && decoder->formatContext->pb->seekable);
+
+	// get encoder delay from the stream we just opened
+	if (stream->start_time != AV_NOPTS_VALUE && stream->start_time > 0)
+	{
+		double startTimeSeconds = (double)stream->start_time * stream->time_base.num / stream->time_base.den;
+		encoderDelaySamples = (unsigned int)floor(startTimeSeconds * decoder->sampleRate);
+	}
+	decoder->encoderDelaySamples = encoderDelaySamples;
+
+	// calculate total frames - subtract encoder delay for BASS-like behavior
+	if (stream->duration > 0 && stream->time_base.den > 0)
+		duration = (double)stream->duration * stream->time_base.num / stream->time_base.den;
+	else if (decoder->formatContext->duration > 0)
+		duration = (double)decoder->formatContext->duration / AV_TIME_BASE;
+	else
+		duration = 300.0; // fallback
+
+	totalFrames = (unsigned int)floor(duration * decoder->sampleRate);
+	decoder->totalFrames = totalFrames > encoderDelaySamples ? totalFrames - encoderDelaySamples : totalFrames;
+
+	decoder->frameBuffer = nullptr;
+	decoder->frameBufferSize = 0;
+	decoder->frameBufferOffset = 0;
+	decoder->frameBufferValidSamples = 0;
+
+	// initialize pts tracking
+	decoder->lastFramePts = AV_NOPTS_VALUE;
+	decoder->validPts = false;
+	decoder->bufferedFramePosition = 0;
+	decoder->bufferedFramePositionValid = false;
+
+	// establish proper starting position accounting for encoder delay
+	if (!seekToFrame(decoder, 0))
+	{
+#ifdef _DEBUG
+		printf("ffmpeg: failed to establish initial position\n");
+#endif
+		goto cleanup;
+	}
+
+	return decoder;
+
+cleanup:
+	close(decoder);
+	return nullptr;
+}
+
+void close(FFmpegDecoder *decoder)
+{
+	if (!decoder)
+		return;
+
+	// cleanup format context
+	if (decoder->formatContext)
+	{
+		avformat_close_input(&decoder->formatContext);
+		decoder->formatContext = nullptr;
+	}
+
+	// cleanup codec context
+	if (decoder->codecContext)
+	{
+		avcodec_free_context(&decoder->codecContext);
+		decoder->codecContext = nullptr;
+	}
+
+	// cleanup resampler
+	if (decoder->swrContext)
+	{
+		swr_free(&decoder->swrContext);
+		decoder->swrContext = nullptr;
+	}
+
+	if (decoder->frame)
+	{
+		av_frame_free(&decoder->frame);
+		decoder->frame = nullptr;
+	}
+
+	if (decoder->packet)
+	{
+		av_packet_free(&decoder->packet);
+		decoder->packet = nullptr;
+	}
+
+	// cleanup channel layout
+	av_channel_layout_uninit(&decoder->channelLayout);
+
+	// cleanup io context
+	unsigned char *bufferToFree = nullptr;
+	if (decoder->avioContext)
+	{
+		bufferToFree = decoder->avioContext->buffer;
+		avio_context_free(&decoder->avioContext);
+		if (bufferToFree)
+			av_free(bufferToFree);
+	}
+	else if (decoder->ioBuffer)
+	{
+		av_free(decoder->ioBuffer);
+	}
+
+	delete decoder->ioContext;
+	delete[] decoder->frameBuffer;
+	delete decoder;
+}
+
+bool seekToFrame(FFmpegDecoder *decoder, unsigned long long frameIndex)
+{
+	if (!decoder || !decoder->seekable)
+	{
+#ifdef _DEBUG
+		printf("ffmpeg: seek rejected - decoder %s, seekable: %s\n", decoder ? "valid" : "null", decoder && decoder->seekable ? "yes" : "no");
+#endif
+		return false;
+	}
+
+	unsigned long long currentPos = getCurrentFrame(decoder);
+	if (frameIndex == currentPos)
+	{
+#ifdef _DEBUG
+		printf("ffmpeg: seek skipped - already at frame %llu\n", frameIndex);
+#endif
+		return true;
+	}
+
+	AVStream *stream = decoder->formatContext->streams[decoder->audioStreamIndex];
+	unsigned long long adjustedFrameIndex = frameIndex + decoder->encoderDelaySamples;
+	int64_t targetTimestamp = av_rescale_q(adjustedFrameIndex, {1, (int)decoder->sampleRate}, stream->time_base);
+
+#ifdef _DEBUG
+	printf("ffmpeg: seeking from frame=%llu (%.3fs) to frame %llu (%.3fs), adjusted=%llu, timestamp=%lld\n", currentPos, (double)currentPos / decoder->sampleRate,
+	       frameIndex, (double)frameIndex / decoder->sampleRate, adjustedFrameIndex, targetTimestamp);
+#endif
+
+	// seek to keyframe at or before target
+	int ret = avformat_seek_file(decoder->formatContext, decoder->audioStreamIndex, INT64_MIN, targetTimestamp, targetTimestamp, AVSEEK_FLAG_BACKWARD);
+	if (ret < 0)
+	{
+#ifdef _DEBUG
+		printf("ffmpeg: seek failed with error %d\n", ret);
+#endif
+		return false;
+	}
+
+	// reset decoder state
+	avcodec_flush_buffers(decoder->codecContext);
+
+	// flush resampler buffers
+	if (decoder->swrContext)
+	{
+		int64_t delay = swr_get_delay(decoder->swrContext, decoder->sampleRate);
+		if (delay > 0)
+		{
+#ifdef _DEBUG
+			printf("ffmpeg: flushing %lld samples from resampler\n", delay);
+#endif
+			swr_drop_output(decoder->swrContext, (int)delay);
+		}
+	}
+
+	// invalidate frame buffer
+	decoder->frameBufferOffset = 0;
+	decoder->frameBufferValidSamples = 0;
+	decoder->endOfStream = false;
+
+	// reset position tracking
+	decoder->currentFrame = 0;
+	decoder->lastFramePts = AV_NOPTS_VALUE;
+	decoder->validPts = false;
+	decoder->bufferedFramePosition = 0;
+	decoder->bufferedFramePositionValid = false;
+
+	// decode first frame to establish where we actually landed
+	if (!decodeNextFrame(decoder))
+	{
+#ifdef _DEBUG
+		printf("ffmpeg: failed to decode frame after seek\n");
+#endif
+		return false;
+	}
+	convertFrameToBuffer(decoder); // frame is now in buffer, ready to be consumed
+	av_frame_unref(decoder->frame);
+
+	unsigned long long keyframePos = getCurrentFrame(decoder);
+
+#ifdef _DEBUG
+	printf("ffmpeg: landed at keyframe %llu (%.3fs), target is frame %llu (%.3fs)\n", keyframePos, (double)keyframePos / decoder->sampleRate, frameIndex,
+	       (double)frameIndex / decoder->sampleRate);
+#endif
+
+	// if we need to advance further, read forward (discarding audio)
+	if (keyframePos < frameIndex)
+	{
+		unsigned long long framesToSkip = frameIndex - keyframePos;
+
+#ifdef _DEBUG
+		printf("ffmpeg: skipping forward %llu frames to reach target\n", framesToSkip);
+#endif
+
+		// temporary buffer for discarded audio
+		float *tempBuffer = new float[framesToSkip * decoder->channels];
+		unsigned long long framesRead = readFrames(decoder, framesToSkip, tempBuffer);
+		delete[] tempBuffer;
+
+		if (framesRead != framesToSkip)
+		{
+#ifdef _DEBUG
+			printf("ffmpeg: skip-forward incomplete - skipped %llu/%llu frames\n", framesRead, framesToSkip);
+#endif
+		}
+	}
+	else if (keyframePos == frameIndex)
+	{
+		// exactly where we want to be, frame is ready in buffer
+#ifdef _DEBUG
+		printf("ffmpeg: landed exactly on target frame\n");
+#endif
+	}
+	else
+	{
+		// this shouldn't happen with AVSEEK_FLAG_BACKWARD
+#ifdef _DEBUG
+		printf("ffmpeg: warning - landed past target by %llu frames\n", keyframePos - frameIndex);
+#endif
+	}
+
+#ifdef _DEBUG
+	printf("ffmpeg: seek completed - target frame %llu (%.3fs), actual frame %llu (%.3fs)\n", frameIndex, (double)frameIndex / decoder->sampleRate,
+	       getCurrentFrame(decoder), (double)getCurrentFrame(decoder) / decoder->sampleRate);
+#endif
+
+	return true;
+}
+
+unsigned long long readFrames(FFmpegDecoder *decoder, unsigned long long framesToRead, float *buffer)
+{
+	if (!decoder || !buffer || framesToRead == 0)
+		return 0;
+
+	unsigned long long framesRead = 0;
+	unsigned int channels = decoder->channels;
+
+	while (framesRead < framesToRead && !decoder->endOfStream)
+	{
+		// use buffered frame data if available
+		if (decoder->frameBufferValidSamples > decoder->frameBufferOffset)
+		{
+			unsigned long long available = decoder->frameBufferValidSamples - decoder->frameBufferOffset;
+			unsigned long long toCopy = std::min(available, framesToRead - framesRead);
+
+			if (toCopy > 0)
+			{
+				// copy frame data in planar format
+				for (unsigned int ch = 0; ch < channels; ch++)
+				{
+					float *src = decoder->frameBuffer + ch * decoder->frameBufferValidSamples + decoder->frameBufferOffset;
+					float *dst = buffer + ch * framesToRead + framesRead;
+					memcpy(dst, src, toCopy * sizeof(float));
+				}
+
+				decoder->frameBufferOffset += (unsigned int)toCopy;
+				framesRead += toCopy;
+				decoder->currentFrame += toCopy;
+			}
+		}
+		else
+		{
+			// need to decode next frame
+			if (!decodeNextFrame(decoder))
+				break;
+
+			convertFrameToBuffer(decoder);
+			av_frame_unref(decoder->frame);
+		}
+	}
+
+	return framesRead;
+}
+
+result loadToMemory(File *aFile, float **aData, unsigned int *aSampleCount, unsigned int *aChannels, float *aSampleRate)
+{
+	if (!aFile || !aData || !aSampleCount || !aChannels || !aSampleRate)
+		return FILE_LOAD_FAILED;
+
+	constexpr bool oneshot = true;
+	FFmpegDecoder *decoder = open(aFile, oneshot);
+	if (!decoder)
+		return FILE_LOAD_FAILED;
+
+	*aChannels = getChannels(decoder);
+	*aSampleRate = (float)getSampleRate(decoder);
+	unsigned long long totalFrames = getTotalFrameCount(decoder);
+
+	if (totalFrames == 0)
+	{
+		close(decoder);
+		return FILE_LOAD_FAILED;
+	}
+
+	*aSampleCount = (unsigned int)totalFrames;
+	*aData = new float[totalFrames * (*aChannels)];
+
+	unsigned long long framesRead = readFrames(decoder, totalFrames, *aData);
+	close(decoder);
+
+	if (framesRead != totalFrames)
+	{
+		delete[] *aData;
+		*aData = nullptr;
+		return FILE_LOAD_FAILED;
+	}
+
+	return SO_NO_ERROR;
+}
+
+unsigned int getChannels(FFmpegDecoder *decoder)
+{
+	return decoder ? decoder->channels : 0;
+}
+
+unsigned int getSampleRate(FFmpegDecoder *decoder)
+{
+	return decoder ? decoder->sampleRate : 0;
+}
+
+unsigned long long getTotalFrameCount(FFmpegDecoder *decoder)
+{
+	return decoder ? decoder->totalFrames : 0;
+}
+
+unsigned long long getCurrentFrame(FFmpegDecoder *decoder)
+{
+	if (!decoder)
+		return 0;
+
+	// prefer buffered frame position if we have valid timestamps
+	if (decoder->bufferedFramePositionValid)
+	{
+		// return position of buffered frame + how much we've consumed from it
+		return decoder->bufferedFramePosition + decoder->frameBufferOffset;
+	}
+
+	// fallback to manual tracking
+	return decoder->currentFrame;
+}
+
+} // namespace SoLoud::FFmpeg
+#endif
diff --git a/src/audiosource/wav/soloud_ffmpeg.h b/src/audiosource/wav/soloud_ffmpeg.h
new file mode 100644
index 0000000..0ed00e2
--- /dev/null
+++ b/src/audiosource/wav/soloud_ffmpeg.h
@@ -0,0 +1,110 @@
+/*
+SoLoud audio engine - ffmpeg interface
+Copyright (c) 2013-2020 Jari Komppa
+Copyright (c) 2025 William Horvath (ffmpeg interface)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+   1. The origin of this software must not be misrepresented; you must not
+   claim that you wrote the original software. If you use this software
+   in a product, an acknowledgment in the product documentation would be
+   appreciated but is not required.
+
+   2. Altered source versions must be plainly marked as such, and must not be
+   misrepresented as being the original software.
+
+   3. This notice may not be removed or altered from any source
+   distribution.
+*/
+
+#ifndef SOLOUD_FFMPEG_H
+#define SOLOUD_FFMPEG_H
+
+#if __has_include(<libavcodec/avcodec.h>) && ((defined(_WIN32) || defined(_WIN64)) || defined(__linux__))
+
+#include "soloud.h"
+
+namespace SoLoud
+{
+class File;
+
+namespace FFmpeg
+{
+
+// ffmpeg decoder handle (opaque)
+struct FFmpegDecoder;
+
+// load audio data to memory using ffmpeg
+result loadToMemory(File *aFile, float **aData, unsigned int *aSampleCount, unsigned int *aChannels, float *aSampleRate);
+
+// direct decoder interface (similar to dr_* decoders)
+FFmpegDecoder *open(File *aFile, bool oneshot = false);
+void close(FFmpegDecoder *decoder);
+unsigned int getChannels(FFmpegDecoder *decoder);
+unsigned int getSampleRate(FFmpegDecoder *decoder);
+unsigned long long getTotalFrameCount(FFmpegDecoder *decoder);
+unsigned long long getCurrentFrame(FFmpegDecoder *decoder);
+bool seekToFrame(FFmpegDecoder *decoder, unsigned long long frameIndex);
+unsigned long long readFrames(FFmpegDecoder *decoder, unsigned long long framesToRead, float *buffer);
+
+} // namespace FFmpeg
+
+} // namespace SoLoud
+
+#else
+
+namespace SoLoud
+{
+class File;
+typedef unsigned int result;
+
+namespace FFmpeg
+{
+struct FFmpegDecoder
+{};
+
+inline result loadToMemory(File *, float **, unsigned int *, unsigned int *, float *)
+{
+	return 7;
+}
+
+inline FFmpegDecoder *open(File *, bool = false)
+{
+	return nullptr;
+}
+inline void close(FFmpegDecoder *) {}
+inline unsigned int getChannels(FFmpegDecoder *)
+{
+	return 0;
+}
+inline unsigned int getSampleRate(FFmpegDecoder *)
+{
+	return 0;
+}
+inline unsigned long long getTotalFrameCount(FFmpegDecoder *)
+{
+	return 0;
+}
+inline unsigned long long getCurrentFrame(FFmpegDecoder *)
+{
+	return 0;
+}
+inline bool seekToFrame(FFmpegDecoder *, unsigned long long)
+{
+	return false;
+}
+inline unsigned long long readFrames(FFmpegDecoder *, unsigned long long, float *)
+{
+	return 0;
+}
+} // namespace FFmpeg
+} // namespace SoLoud
+
+#endif
+#endif // SOLOUD_FFMPEG_H
diff --git a/src/audiosource/wav/soloud_ffmpeg_load.cpp b/src/audiosource/wav/soloud_ffmpeg_load.cpp
new file mode 100644
index 0000000..988a12c
--- /dev/null
+++ b/src/audiosource/wav/soloud_ffmpeg_load.cpp
@@ -0,0 +1,355 @@
+/*
+SoLoud audio engine - ffmpeg library loader/unloader
+Copyright (c) 2013-2020 Jari Komppa
+Copyright (c) 2025 William Horvath (ffmpeg interface)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+   1. The origin of this software must not be misrepresented; you must not
+   claim that you wrote the original software. If you use this software
+   in a product, an acknowledgment in the product documentation would be
+   appreciated but is not required.
+
+   2. Altered source versions must be plainly marked as such, and must not be
+   misrepresented as being the original software.
+
+   3. This notice may not be removed or altered from any source
+   distribution.
+*/
+
+#if __has_include(<libavcodec/avcodec.h>) && ((defined(_WIN32) || defined(_WIN64)) || defined(__linux__))
+#pragma message("building with ffmpeg support")
+
+#include <mutex>
+#include <string>
+
+#if defined(_WIN32) || defined(_WIN64)
+#define LNAME(x, ver) #x "-" #ver ".dll"
+#else
+#define LNAME(x, ver) "lib" #x ".so." #ver
+#endif
+
+#ifdef WITH_SDL3_STATIC
+#include <SDL3/SDL_loadso.h>
+typedef SDL_SharedObject(*OBJHANDLE);
+#define LIBLOAD(x) SDL_LoadObject(x)
+#define LIBFUNC(x, y) SDL_LoadFunction(x, y)
+#define LIBFREE(x) SDL_UnloadObject(x)
+#define LIBGETERROR() std::string(SDL_GetError())
+#elif defined(_WIN32) || defined(_WIN64)
+#include <windows.h>
+typedef HMODULE OBJHANDLE;
+#define LIBLOAD(x) LoadLibraryA(x)
+#define LIBFUNC(x, y) (void *)GetProcAddress(x, y)
+#define LIBFREE(x) FreeLibrary(x)
+#define LIBGETERROR() \
+	([]() -> std::string { \
+		DWORD errorCode = GetLastError(); \
+		if (errorCode == 0) \
+			return std::string("No error"); \
+		LPSTR messageBuffer = nullptr; \
+		DWORD size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorCode, \
+		                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) & messageBuffer, 0, NULL); \
+		if (size == 0) \
+			return std::string("Unknown error (code: ") + std::to_string(errorCode) + ")"; \
+		std::string result(messageBuffer, size); \
+		LocalFree(messageBuffer); \
+		while (!result.empty() && (result.back() == '\n' || result.back() == '\r')) \
+			result.pop_back(); \
+		return result; \
+	}())
+#else
+#include <dlfcn.h>
+typedef void(*OBJHANDLE);
+#define LIBLOAD(x) dlopen(x, RTLD_NOW)
+#define LIBFUNC(x, y) dlsym(x, y)
+#define LIBFREE(x) dlclose(x)
+#define LIBGETERROR() std::string(dlerror())
+#endif
+
+#include "soloud_ffmpeg_load.h"
+
+using namespace SoLoud::FFmpeg::FFmpegLoader::FFmpegFuncs;
+
+namespace SoLoud::FFmpeg::FFmpegLoader
+{
+
+// library handles
+static OBJHANDLE s_libAvutil = nullptr;
+static OBJHANDLE s_libSwresample = nullptr;
+static OBJHANDLE s_libAvcodec = nullptr;
+static OBJHANDLE s_libAvformat = nullptr;
+
+static std::once_flag s_init_flag;
+static bool s_init_success{false};
+static bool s_available{false};
+
+// initialization state
+static std::string s_errorDetails = "";
+
+namespace FFmpegFuncs
+{
+// generate function pointer definitions
+#define DEFINE_FFMPEG_FUNCTION(name) name##_t name = nullptr;
+ALL_FFMPEG_FUNCTIONS(DEFINE_FFMPEG_FUNCTION)
+} // namespace FFmpegFuncs
+
+template <typename T>
+static T loadFunction(OBJHANDLE lib, const char *funcName)
+{
+	if (!lib)
+		return nullptr;
+	return reinterpret_cast<T>(LIBFUNC(lib, funcName));
+}
+
+static bool loadAvutilFunctions()
+{
+	if (!s_libAvutil)
+	{
+		s_errorDetails += "avutil library not loaded\n";
+		return false;
+	}
+
+	bool success = true;
+	int failed_count = 0;
+
+#define LOAD_AVUTIL_FUNCTION(name) \
+	name = loadFunction<name##_t>(s_libAvutil, #name); \
+	if (!(name)) \
+	{ \
+		s_errorDetails += std::string("Missing avutil function: ") + #name + "\n"; \
+		failed_count++; \
+		success = false; \
+	}
+
+	AVUTIL_FUNCTIONS(LOAD_AVUTIL_FUNCTION)
+
+	if (!success)
+		s_errorDetails += "Failed to load " + std::to_string(failed_count) + " avutil functions\n";
+
+	return success;
+}
+
+static bool loadAvcodecFunctions()
+{
+	if (!s_libAvcodec)
+	{
+		s_errorDetails += "avcodec library not loaded\n";
+		return false;
+	}
+
+	bool success = true;
+	int failed_count = 0;
+
+#define LOAD_AVCODEC_FUNCTION(name) \
+	name = loadFunction<name##_t>(s_libAvcodec, #name); \
+	if (!(name)) \
+	{ \
+		s_errorDetails += std::string("Missing avcodec function: ") + #name + "\n"; \
+		failed_count++; \
+		success = false; \
+	}
+
+	AVCODEC_FUNCTIONS(LOAD_AVCODEC_FUNCTION)
+
+	if (!success)
+		s_errorDetails += "Failed to load " + std::to_string(failed_count) + " avcodec functions\n";
+
+	return success;
+}
+
+static bool loadAvformatFunctions()
+{
+	if (!s_libAvformat)
+	{
+		s_errorDetails += "avformat library not loaded\n";
+		return false;
+	}
+
+	bool success = true;
+	int failed_count = 0;
+
+#define LOAD_AVFORMAT_FUNCTION(name) \
+	name = loadFunction<name##_t>(s_libAvformat, #name); \
+	if (!(name)) \
+	{ \
+		s_errorDetails += std::string("Missing avformat function: ") + #name + "\n"; \
+		failed_count++; \
+		success = false; \
+	}
+
+	AVFORMAT_FUNCTIONS(LOAD_AVFORMAT_FUNCTION)
+
+	if (!success)
+		s_errorDetails += "Failed to load " + std::to_string(failed_count) + " avformat functions\n";
+
+	return success;
+}
+
+static bool loadSwresampleFunctions()
+{
+	if (!s_libSwresample)
+	{
+		s_errorDetails += "swresample library not loaded\n";
+		return false;
+	}
+
+	bool success = true;
+	int failed_count = 0;
+
+#define LOAD_SWRESAMPLE_FUNCTION(name) \
+	name = loadFunction<name##_t>(s_libSwresample, #name); \
+	if (!(name)) \
+	{ \
+		s_errorDetails += std::string("Missing swresample function: ") + #name + "\n"; \
+		failed_count++; \
+		success = false; \
+	}
+
+	SWRESAMPLE_FUNCTIONS(LOAD_SWRESAMPLE_FUNCTION)
+
+	if (!success)
+		s_errorDetails += "Failed to load " + std::to_string(failed_count) + " swresample functions\n";
+
+	return success;
+}
+
+// silence, you fool
+static void empty_log_callback(void */**/, int/**/, const char */**/, va_list/**/)
+{
+	;
+}
+
+static bool init_locked()
+{
+	s_available = false;
+	s_errorDetails = "";
+
+	cleanup();
+
+	s_libAvutil = LIBLOAD(LNAME(avutil, 59));
+	if (!s_libAvutil)
+	{
+		s_errorDetails = "Failed to load libavutil-59 (error: " + LIBGETERROR() + ")";
+		return false;
+	}
+
+	s_libSwresample = LIBLOAD(LNAME(swresample, 5));
+	if (!s_libSwresample)
+	{
+		s_errorDetails = "Failed to load libswresample-5 (error: " + LIBGETERROR() + ")";
+		cleanup();
+		return false;
+	}
+
+	s_libAvcodec = LIBLOAD(LNAME(avcodec, 61));
+	if (!s_libAvcodec)
+	{
+		s_errorDetails = "Failed to load libavcodec-61 (error: " + LIBGETERROR() + ")";
+		cleanup();
+		return false;
+	}
+
+	s_libAvformat = LIBLOAD(LNAME(avformat, 61));
+	if (!s_libAvformat)
+	{
+		s_errorDetails = "Failed to load libavformat-61 (error: " + LIBGETERROR() + ")";
+		cleanup();
+		return false;
+	}
+
+	bool functionsLoaded = true;
+	functionsLoaded &= loadAvutilFunctions();
+	functionsLoaded &= loadSwresampleFunctions();
+	functionsLoaded &= loadAvcodecFunctions();
+	functionsLoaded &= loadAvformatFunctions();
+
+	if (!functionsLoaded)
+	{
+		cleanup();
+		return false;
+	}
+
+#ifndef _DEBUG
+	if (av_log_set_callback)
+		av_log_set_callback(empty_log_callback);
+#endif
+
+	// verify basic functionality
+	if (av_malloc && av_free)
+	{
+		void *test_ptr = av_malloc(64);
+		if (test_ptr)
+		{
+			av_free(test_ptr);
+		}
+	}
+	else
+	{
+		s_errorDetails += "Critical functions av_malloc/av_free not loaded\n";
+		cleanup();
+		return false;
+	}
+
+	s_available = true;
+	s_errorDetails = "";
+	return true;
+}
+
+bool init()
+{
+	std::call_once(s_init_flag, []() { s_init_success = init_locked(); });
+
+	return s_init_success;
+}
+
+void cleanup()
+{
+	s_available = false;
+
+#define RESET_FUNCTION(name) name = nullptr;
+	ALL_FFMPEG_FUNCTIONS(RESET_FUNCTION)
+
+	if (s_libAvformat)
+	{
+		LIBFREE(s_libAvformat);
+		s_libAvformat = nullptr;
+	}
+	if (s_libAvcodec)
+	{
+		LIBFREE(s_libAvcodec);
+		s_libAvcodec = nullptr;
+	}
+	if (s_libSwresample)
+	{
+		LIBFREE(s_libSwresample);
+		s_libSwresample = nullptr;
+	}
+	if (s_libAvutil)
+	{
+		LIBFREE(s_libAvutil);
+		s_libAvutil = nullptr;
+	}
+}
+
+bool isAvailable()
+{
+	return s_available;
+}
+
+std::string getErrorDetails()
+{
+	return s_errorDetails;
+}
+
+} // namespace SoLoud::FFmpeg::FFmpegLoader
+
+#else
+#pragma message("building without ffmpeg support")
+#endif
diff --git a/src/audiosource/wav/soloud_ffmpeg_load.h b/src/audiosource/wav/soloud_ffmpeg_load.h
new file mode 100644
index 0000000..3f7aa2f
--- /dev/null
+++ b/src/audiosource/wav/soloud_ffmpeg_load.h
@@ -0,0 +1,170 @@
+/*
+SoLoud audio engine - ffmpeg library loader/unloader
+Copyright (c) 2013-2020 Jari Komppa
+Copyright (c) 2025 William Horvath (ffmpeg interface)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+   1. The origin of this software must not be misrepresented; you must not
+   claim that you wrote the original software. If you use this software
+   in a product, an acknowledgment in the product documentation would be
+   appreciated but is not required.
+
+   2. Altered source versions must be plainly marked as such, and must not be
+   misrepresented as being the original software.
+
+   3. This notice may not be removed or altered from any source
+   distribution.
+*/
+
+#ifndef SOLOUD_FFMPEG_LOAD_H
+#define SOLOUD_FFMPEG_LOAD_H
+
+#include <string>
+
+#if __has_include(<libavcodec/avcodec.h>) && ((defined(_WIN32) || defined(_WIN64)) || defined(__linux__))
+
+#include <math.h>
+#include <stdlib.h>
+
+// include ffmpeg headers in their own namespace for type derivation
+namespace ffmpeg_EXTERN
+{
+extern "C"
+{
+#include <libavcodec/avcodec.h>
+#include <libavformat/avformat.h>
+#include <libavutil/avutil.h>
+#include <libavutil/channel_layout.h>
+#include <libavutil/intreadwrite.h>
+#include <libavutil/opt.h>
+#include <libavutil/samplefmt.h>
+#include <libswresample/swresample.h>
+}
+} // namespace ffmpeg_EXTERN
+
+namespace SoLoud::FFmpeg::FFmpegLoader
+{
+
+// define core function groups by library
+#define AVFORMAT_FUNCTIONS(X) \
+	X(av_read_frame) \
+	X(avformat_alloc_context) \
+	X(avformat_close_input) \
+	X(avformat_find_stream_info) \
+	X(avformat_open_input) \
+	X(avformat_seek_file) \
+	X(avio_alloc_context) \
+	X(avio_context_free)
+
+#define AVCODEC_FUNCTIONS(X) \
+	X(av_packet_alloc) \
+	X(av_packet_free) \
+	X(av_packet_unref) \
+	X(avcodec_alloc_context3) \
+	X(avcodec_find_decoder) \
+	X(avcodec_flush_buffers) \
+	X(avcodec_free_context) \
+	X(avcodec_open2) \
+	X(avcodec_parameters_to_context) \
+	X(avcodec_receive_frame) \
+	X(avcodec_send_packet)
+
+#define AVUTIL_FUNCTIONS(X) \
+	X(av_channel_layout_copy) \
+	X(av_channel_layout_default) \
+	X(av_channel_layout_uninit) \
+	X(av_dict_free) \
+	X(av_dict_set) \
+	X(av_frame_alloc) \
+	X(av_frame_free) \
+	X(av_frame_unref) \
+	X(av_free) \
+	X(av_log_set_callback) \
+	X(av_malloc) \
+	X(av_opt_set_chlayout) \
+	X(av_opt_set_int) \
+	X(av_opt_set_sample_fmt) \
+	X(av_rescale_q) \
+	X(av_sample_fmt_is_planar)
+
+#define SWRESAMPLE_FUNCTIONS(X) \
+	X(swr_alloc) \
+	X(swr_convert) \
+	X(swr_drop_output) \
+	X(swr_free) \
+	X(swr_get_delay) \
+	X(swr_init)
+
+#define ALL_FFMPEG_FUNCTIONS(X) \
+	AVFORMAT_FUNCTIONS(X) \
+	AVCODEC_FUNCTIONS(X) \
+	AVUTIL_FUNCTIONS(X) \
+	SWRESAMPLE_FUNCTIONS(X)
+
+namespace FFmpegFuncs
+{
+// import commonly used types first
+using AVChannelLayout = ffmpeg_EXTERN::AVChannelLayout;
+using AVCodec = ffmpeg_EXTERN::AVCodec;
+using AVCodecContext = ffmpeg_EXTERN::AVCodecContext;
+using AVCodecParameters = ffmpeg_EXTERN::AVCodecParameters;
+using AVDictionary = ffmpeg_EXTERN::AVDictionary;
+using AVFormatContext = ffmpeg_EXTERN::AVFormatContext;
+using AVFrame = ffmpeg_EXTERN::AVFrame;
+using AVIOContext = ffmpeg_EXTERN::AVIOContext;
+using AVPacket = ffmpeg_EXTERN::AVPacket;
+using AVStream = ffmpeg_EXTERN::AVStream;
+using SwrContext = ffmpeg_EXTERN::SwrContext;
+
+// import constants that we need
+using ffmpeg_EXTERN::AV_SAMPLE_FMT_FLTP;
+using ffmpeg_EXTERN::AVMEDIA_TYPE_AUDIO;
+
+// generate function pointer types and declarations
+#define DECLARE_FFMPEG_FUNCTION(name) \
+	using name##_t = decltype(&ffmpeg_EXTERN::name); \
+	extern name##_t name;
+
+ALL_FFMPEG_FUNCTIONS(DECLARE_FFMPEG_FUNCTION)
+
+} // namespace FFmpegFuncs
+
+// main interface
+bool init();
+void cleanup();
+bool isAvailable();
+std::string getErrorDetails();
+
+} // namespace SoLoud::FFmpeg::FFmpegLoader
+
+#else
+namespace SoLoud::FFmpeg::FFmpegLoader
+{
+// main interface
+inline bool init()
+{
+	return false;
+}
+inline void cleanup()
+{
+	;
+}
+inline bool isAvailable()
+{
+	return false;
+}
+inline std::string getErrorDetails()
+{
+	return "FFmpeg support was not compiled in.";
+}
+} // namespace SoLoud::FFmpeg::FFmpegLoader
+
+#endif
+#endif // SOLOUD_FFMPEG_H
diff --git a/src/audiosource/wav/soloud_wav.cpp b/src/audiosource/wav/soloud_wav.cpp
index 1eb39e0..964d0b8 100755
--- a/src/audiosource/wav/soloud_wav.cpp
+++ b/src/audiosource/wav/soloud_wav.cpp
@@ -22,376 +22,418 @@ freely, subject to the following restrictions:
    distribution.
 */
 
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "soloud.h"
-#include "soloud_wav.h"
-#include "soloud_file.h"
-#include "stb_vorbis.h"
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+
+#include "dr_flac.h"
 #include "dr_mp3.h"
 #include "dr_wav.h"
-#include "dr_flac.h"
+#include "stb_vorbis.h"
 
-namespace SoLoud
-{
-	WavInstance::WavInstance(Wav *aParent)
-	{
-		mParent = aParent;
-		mOffset = 0;
-	}
+#include "soloud_ffmpeg.h"
+#include "soloud_ffmpeg_load.h"
 
-	unsigned int WavInstance::getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize)
-	{		
-		if (aBuffer == NULL || mParent->mData == NULL)
-			return 0;
+#include "soloud.h"
+#include "soloud_file.h"
+#include "soloud_wav.h"
 
-		unsigned int dataleft = mParent->mSampleCount - mOffset;
-		unsigned int copylen = dataleft;
-		if (copylen > aSamplesToRead)
-			copylen = aSamplesToRead;
+namespace SoLoud
+{
+WavInstance::WavInstance(Wav *aParent)
+{
+	mParent = aParent;
+	mOffset = 0;
+}
 
-		unsigned int i;
-		for (i = 0; i < mChannels; i++)
-		{
-			memcpy(aBuffer + i * aBufferSize, mParent->mData + mOffset + i * mParent->mSampleCount, sizeof(float) * copylen);
-		}
+unsigned int WavInstance::getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize)
+{
+	if (aBuffer == NULL || mParent->mData == NULL)
+		return 0;
 
-		mOffset += copylen;
-		return copylen;
-	}
+	unsigned int dataleft = mParent->mSampleCount - mOffset;
+	unsigned int copylen = dataleft;
+	if (copylen > aSamplesToRead)
+		copylen = aSamplesToRead;
 
-	result WavInstance::rewind()
+	unsigned int i;
+	for (i = 0; i < mChannels; i++)
 	{
-		mOffset = 0;
-		mStreamPosition = 0.0f;
-		return 0;
+		memcpy(aBuffer + i * aBufferSize, mParent->mData + mOffset + i * mParent->mSampleCount, sizeof(float) * copylen);
 	}
 
-	bool WavInstance::hasEnded()
-	{
-		if (!(mFlags & AudioSourceInstance::LOOPING) && mOffset >= mParent->mSampleCount)
-		{
-			return 1;
-		}
-		return 0;
-	}
+	mOffset += copylen;
+	return copylen;
+}
 
-	Wav::Wav()
-	{
-		mData = NULL;
-		mSampleCount = 0;
-	}
-	
-	Wav::~Wav()
+result WavInstance::rewind()
+{
+	mOffset = 0;
+	mStreamPosition = 0.0f;
+	return 0;
+}
+
+bool WavInstance::hasEnded()
+{
+	if (!(mFlags & AudioSourceInstance::LOOPING) && mOffset >= mParent->mSampleCount)
 	{
-		stop();
-		delete[] mData;
+		return 1;
 	}
+	return 0;
+}
 
-#define MAKEDWORD(a,b,c,d) (((d) << 24) | ((c) << 16) | ((b) << 8) | (a))
+Wav::Wav()
+{
+	mData = NULL;
+	mSampleCount = 0;
+}
 
-	result Wav::loadwav(MemoryFile *aReader)
-	{
-		drwav decoder;
+Wav::~Wav()
+{
+	stop();
+	delete[] mData;
+}
 
-		if (!drwav_init_memory(&decoder, aReader->getMemPtr(), aReader->length(),NULL))
-		{
-			return FILE_LOAD_FAILED;
-		}
+#define MAKEDWORD(a, b, c, d) (((d) << 24) | ((c) << 16) | ((b) << 8) | (a))
 
-		drwav_uint64 samples = decoder.totalPCMFrameCount;
+result Wav::loadwav(MemoryFile *aReader)
+{
+	drwav decoder;
 
-		if (!samples)
-		{
-			drwav_uninit(&decoder);
-			return FILE_LOAD_FAILED;
-		}
+	if (!drwav_init_memory(&decoder, aReader->getMemPtr(), aReader->length(), NULL))
+	{
+		return FILE_LOAD_FAILED;
+	}
+
+	drwav_uint64 samples = decoder.totalPCMFrameCount;
+
+	if (!samples)
+	{
+		drwav_uninit(&decoder);
+		return FILE_LOAD_FAILED;
+	}
 
-		mData = new float[(unsigned int)(samples * decoder.channels)];
-		mBaseSamplerate = (float)decoder.sampleRate;
-		mSampleCount = (unsigned int)samples;
-		mChannels = decoder.channels;
+	mData = new float[(unsigned int)(samples * decoder.channels)];
+	mBaseSamplerate = (float)decoder.sampleRate;
+	mSampleCount = (unsigned int)samples;
+	mChannels = decoder.channels;
 
-		unsigned int i, j, k;
-		for (i = 0; i < mSampleCount; i += 512)
+	unsigned int i, j, k;
+	for (i = 0; i < mSampleCount; i += 512)
+	{
+		float tmp[512 * MAX_CHANNELS];
+		unsigned int blockSize = (mSampleCount - i) > 512 ? 512 : mSampleCount - i;
+		drwav_read_pcm_frames_f32(&decoder, blockSize, tmp);
+		for (j = 0; j < blockSize; j++)
 		{
-			float tmp[512 * MAX_CHANNELS];
-			unsigned int blockSize = (mSampleCount - i) > 512 ? 512 : mSampleCount - i;
-			drwav_read_pcm_frames_f32(&decoder, blockSize, tmp);
-			for (j = 0; j < blockSize; j++)
+			for (k = 0; k < decoder.channels; k++)
 			{
-				for (k = 0; k < decoder.channels; k++)
-				{
-					mData[k * mSampleCount + i + j] = tmp[j * decoder.channels + k];
-				}
+				mData[k * mSampleCount + i + j] = tmp[j * decoder.channels + k];
 			}
 		}
-		drwav_uninit(&decoder);
-
-		return SO_NO_ERROR;
 	}
+	drwav_uninit(&decoder);
 
-	result Wav::loadogg(MemoryFile *aReader)
-	{	
-		int e = 0;
-		stb_vorbis *vorbis = 0;
-		vorbis = stb_vorbis_open_memory(aReader->getMemPtr(), aReader->length(), &e, 0);
+	return SO_NO_ERROR;
+}
 
-		if (0 == vorbis)
-		{
-			return FILE_LOAD_FAILED;
-		}
+result Wav::loadogg(MemoryFile *aReader)
+{
+	int e = 0;
+	stb_vorbis *vorbis = 0;
+	vorbis = stb_vorbis_open_memory(aReader->getMemPtr(), aReader->length(), &e, 0);
 
-        stb_vorbis_info info = stb_vorbis_get_info(vorbis);
-		mBaseSamplerate = (float)info.sample_rate;
-        int samples = stb_vorbis_stream_length_in_samples(vorbis);
+	if (0 == vorbis)
+	{
+		return FILE_LOAD_FAILED;
+	}
 
-		if (info.channels > MAX_CHANNELS)
-		{
-			mChannels = MAX_CHANNELS;
-		}
-		else
-		{
-			mChannels = info.channels;
-		}
-		mData = new float[samples * mChannels];
-		memset(mData, 0, samples * mChannels * sizeof(float));
-		mSampleCount = samples;
-		samples = 0;
-		while(1)
+	stb_vorbis_info info = stb_vorbis_get_info(vorbis);
+	mBaseSamplerate = (float)info.sample_rate;
+	int samples = stb_vorbis_stream_length_in_samples(vorbis);
+
+	if (info.channels > MAX_CHANNELS)
+	{
+		mChannels = MAX_CHANNELS;
+	}
+	else
+	{
+		mChannels = info.channels;
+	}
+	mData = new float[samples * mChannels];
+	memset(mData, 0, samples * mChannels * sizeof(float));
+	mSampleCount = samples;
+	samples = 0;
+	while (1)
+	{
+		float **outputs;
+		int n = stb_vorbis_get_frame_float(vorbis, NULL, &outputs);
+		if (n == 0)
 		{
-			float **outputs;
-            int n = stb_vorbis_get_frame_float(vorbis, NULL, &outputs);
-			if (n == 0)
-            {
-				break;
-            }
-
-			unsigned int ch;
-			for (ch = 0; ch < mChannels; ch++)
-				memcpy(mData + samples + mSampleCount * ch, outputs[ch], sizeof(float) * n);
-
-			samples += n;
+			break;
 		}
-        stb_vorbis_close(vorbis);
 
-		return 0;
+		unsigned int ch;
+		for (ch = 0; ch < mChannels; ch++)
+			memcpy(mData + samples + mSampleCount * ch, outputs[ch], sizeof(float) * n);
+
+		samples += n;
 	}
+	stb_vorbis_close(vorbis);
 
-	result Wav::loadmp3(MemoryFile *aReader)
-	{
-		drmp3 decoder;
+	return 0;
+}
 
-		if (!drmp3_init_memory(&decoder, aReader->getMemPtr(), aReader->length(), NULL))
-		{
-			return FILE_LOAD_FAILED;
-		}
+result Wav::loadmp3(MemoryFile *aReader)
+{
+	drmp3 decoder;
+
+	if (!drmp3_init_memory(&decoder, aReader->getMemPtr(), aReader->length(), NULL))
+	{
+		return FILE_LOAD_FAILED;
+	}
 
-		drmp3_uint64 samples = drmp3_get_pcm_frame_count(&decoder);
+	drmp3_uint64 samples = drmp3_get_pcm_frame_count(&decoder);
 
-		if (!samples)
-		{
-			drmp3_uninit(&decoder);
-			return FILE_LOAD_FAILED;
-		}
+	if (!samples)
+	{
+		drmp3_uninit(&decoder);
+		return FILE_LOAD_FAILED;
+	}
 
-		mData = new float[(unsigned int)(samples * decoder.channels)];
-		mBaseSamplerate = (float)decoder.sampleRate;
-		mSampleCount = (unsigned int)samples;
-		mChannels = decoder.channels;
-		drmp3_seek_to_pcm_frame(&decoder, 0); 
+	mData = new float[(unsigned int)(samples * decoder.channels)];
+	mBaseSamplerate = (float)decoder.sampleRate;
+	mSampleCount = (unsigned int)samples;
+	mChannels = decoder.channels;
+	drmp3_seek_to_pcm_frame(&decoder, 0);
 
-		unsigned int i, j, k;
-		for (i = 0; i<mSampleCount; i += 512)
+	unsigned int i, j, k;
+	for (i = 0; i < mSampleCount; i += 512)
+	{
+		float tmp[512 * MAX_CHANNELS];
+		unsigned int blockSize = (mSampleCount - i) > 512 ? 512 : mSampleCount - i;
+		drmp3_read_pcm_frames_f32(&decoder, blockSize, tmp);
+		for (j = 0; j < blockSize; j++)
 		{
-			float tmp[512 * MAX_CHANNELS];
-			unsigned int blockSize = (mSampleCount - i) > 512 ? 512 : mSampleCount - i;
-			drmp3_read_pcm_frames_f32(&decoder, blockSize, tmp);
-			for (j = 0; j < blockSize; j++) 
+			for (k = 0; k < decoder.channels; k++)
 			{
-				for (k = 0; k < decoder.channels; k++) 
-				{
-					mData[k * mSampleCount + i + j] = tmp[j * decoder.channels + k];
-				}
+				mData[k * mSampleCount + i + j] = tmp[j * decoder.channels + k];
 			}
 		}
-		drmp3_uninit(&decoder);
-
-		return SO_NO_ERROR;
 	}
+	drmp3_uninit(&decoder);
 
-	result Wav::loadflac(MemoryFile *aReader)
-	{
-		drflac *decoder = drflac_open_memory(aReader->mDataPtr, aReader->mDataLength, NULL);
+	return SO_NO_ERROR;
+}
 
-		if (!decoder)
-		{
-			return FILE_LOAD_FAILED;
-		}
+result Wav::loadflac(MemoryFile *aReader)
+{
+	drflac *decoder = drflac_open_memory(aReader->mDataPtr, aReader->mDataLength, NULL);
 
-		drflac_uint64 samples = decoder->totalPCMFrameCount;
+	if (!decoder)
+	{
+		return FILE_LOAD_FAILED;
+	}
 
-		if (!samples)
-		{
-			drflac_close(decoder);
-			return FILE_LOAD_FAILED;
-		}
+	drflac_uint64 samples = decoder->totalPCMFrameCount;
+
+	if (!samples)
+	{
+		drflac_close(decoder);
+		return FILE_LOAD_FAILED;
+	}
 
-		mData = new float[(unsigned int)(samples * decoder->channels)];
-		mBaseSamplerate = (float)decoder->sampleRate;
-		mSampleCount = (unsigned int)samples;
-		mChannels = decoder->channels;
-		drflac_seek_to_pcm_frame(decoder, 0);
+	mData = new float[(unsigned int)(samples * decoder->channels)];
+	mBaseSamplerate = (float)decoder->sampleRate;
+	mSampleCount = (unsigned int)samples;
+	mChannels = decoder->channels;
+	drflac_seek_to_pcm_frame(decoder, 0);
 
-		unsigned int i, j, k;
-		for (i = 0; i < mSampleCount; i += 512)
+	unsigned int i, j, k;
+	for (i = 0; i < mSampleCount; i += 512)
+	{
+		float tmp[512 * MAX_CHANNELS];
+		unsigned int blockSize = (mSampleCount - i) > 512 ? 512 : mSampleCount - i;
+		drflac_read_pcm_frames_f32(decoder, blockSize, tmp);
+		for (j = 0; j < blockSize; j++)
 		{
-			float tmp[512 * MAX_CHANNELS];
-			unsigned int blockSize = (mSampleCount - i) > 512 ? 512 : mSampleCount - i;
-			drflac_read_pcm_frames_f32(decoder, blockSize, tmp);
-			for (j = 0; j < blockSize; j++)
+			for (k = 0; k < decoder->channels; k++)
 			{
-				for (k = 0; k < decoder->channels; k++)
-				{
-					mData[k * mSampleCount + i + j] = tmp[j * decoder->channels + k];
-				}
+				mData[k * mSampleCount + i + j] = tmp[j * decoder->channels + k];
 			}
 		}
-		drflac_close(decoder);
-
-		return SO_NO_ERROR;
 	}
+	drflac_close(decoder);
 
-    result Wav::testAndLoadFile(MemoryFile *aReader)
-    {
-		delete[] mData;
-		mData = 0;
-		mSampleCount = 0;
-		mChannels = 1;
-        int tag = aReader->read32();
-		if (tag == MAKEDWORD('O','g','g','S')) 
-        {
-			return loadogg(aReader);
-
-		} 
-        else if (tag == MAKEDWORD('R','I','F','F')) 
-        {
-			return loadwav(aReader);
-		}
-		else if (tag == MAKEDWORD('f', 'L', 'a', 'C'))
-		{
-			return loadflac(aReader);
-		}
-		else if (loadmp3(aReader) == SO_NO_ERROR)
-		{
-			return SO_NO_ERROR;
-		}
+	return SO_NO_ERROR;
+}
 
-		return FILE_LOAD_FAILED;
-    }
-
-	result Wav::load(const char *aFilename)
+result Wav::loadffmpeg(MemoryFile *aReader)
+{
+	if (mSoloud)
+		mSoloud->lockAudioMutex_internal();
+	result retval = (!FFmpeg::FFmpegLoader::init() || !FFmpeg::FFmpegLoader::isAvailable()) ? FILE_LOAD_FAILED : SO_NO_ERROR;
+	if (mSoloud)
+		mSoloud->unlockAudioMutex_internal();
+	if (retval != SO_NO_ERROR)
 	{
-		if (aFilename == 0)
-			return INVALID_PARAMETER;
-		stop();
-		DiskFile dr;
-		int res = dr.open(aFilename);
-		if (res == SO_NO_ERROR)
-			return loadFile(&dr);
-		return res;
+#ifdef _DEBUG
+		printf("debug: failed to load ffmpeg %s\n", FFmpeg::FFmpegLoader::getErrorDetails().c_str());
+#endif
+		return retval;
 	}
 
-	result Wav::loadMem(const unsigned char *aMem, unsigned int aLength, bool aCopy, bool aTakeOwnership)
-	{
-		if (aMem == NULL || aLength == 0)
-			return INVALID_PARAMETER;
-		stop();
+	float *data = nullptr;
+	unsigned int channels = 2, sampleCount = 0;
+	float sampleRate = 44100.0f;
 
-		MemoryFile dr;
-        dr.openMem(aMem, aLength, aCopy, aTakeOwnership);
-		return testAndLoadFile(&dr);
+	result res = FFmpeg::loadToMemory(aReader, &data, &sampleCount, &channels, &sampleRate);
+	if (res != SO_NO_ERROR || sampleCount == 0)
+	{
+		if (data)
+			delete[] data;
+		return FILE_LOAD_FAILED;
 	}
 
-	result Wav::loadFile(File *aFile)
-	{
-		if (!aFile)
-			return INVALID_PARAMETER;
-		stop();
+	mData = data;
+	mSampleCount = sampleCount;
+	mChannels = channels;
+	mBaseSamplerate = sampleRate;
 
-		MemoryFile mr;
-		result res = mr.openFileToMem(aFile);
+	return SO_NO_ERROR;
+}
 
-		if (res != SO_NO_ERROR)
-		{
-			return res;
-		}
-		return testAndLoadFile(&mr);
+result Wav::testAndLoadFile(MemoryFile *aReader)
+{
+	delete[] mData;
+	mData = 0;
+	mSampleCount = 0;
+	mChannels = 1;
+	int tag = aReader->read32();
+	if (tag == MAKEDWORD('O', 'g', 'g', 'S'))
+	{
+		return loadogg(aReader);
 	}
-
-	AudioSourceInstance *Wav::createInstance()
+	else if (tag == MAKEDWORD('R', 'I', 'F', 'F'))
 	{
-		return new WavInstance(this);
+		return loadwav(aReader);
 	}
-
-	double Wav::getLength()
+	else if (tag == MAKEDWORD('f', 'L', 'a', 'C'))
 	{
-		if (mBaseSamplerate == 0)
-			return 0;
-		return mSampleCount / mBaseSamplerate;
+		return loadflac(aReader);
 	}
-
-	result Wav::loadRawWave8(unsigned char *aMem, unsigned int aLength, float aSamplerate, unsigned int aChannels)
+	else if (loadmp3(aReader) == SO_NO_ERROR)
 	{
-		if (aMem == 0 || aLength == 0 || aSamplerate <= 0 || aChannels < 1)
-			return INVALID_PARAMETER;
-		stop();
-		delete[] mData;
-		mData = new float[aLength];	
-		mSampleCount = aLength / aChannels;
-		mChannels = aChannels;
-		mBaseSamplerate = aSamplerate;
-		unsigned int i;
-		for (i = 0; i < aLength; i++)
-			mData[i] = ((signed)aMem[i] - 128) / (float)0x80;
 		return SO_NO_ERROR;
 	}
-
-	result Wav::loadRawWave16(short *aMem, unsigned int aLength, float aSamplerate, unsigned int aChannels)
+	else if (loadffmpeg(aReader) == SO_NO_ERROR)
 	{
-		if (aMem == 0 || aLength == 0 || aSamplerate <= 0 || aChannels < 1)
-			return INVALID_PARAMETER;
-		stop();
-		delete[] mData;
-		mData = new float[aLength];
-		mSampleCount = aLength / aChannels;
-		mChannels = aChannels;
-		mBaseSamplerate = aSamplerate;
-		unsigned int i;
-		for (i = 0; i < aLength; i++)
-			mData[i] = ((signed short)aMem[i]) / (float)0x8000;
 		return SO_NO_ERROR;
 	}
+	return FILE_LOAD_FAILED;
+}
+
+result Wav::load(const char *aFilename)
+{
+	if (aFilename == 0)
+		return INVALID_PARAMETER;
+	stop();
+	DiskFile dr;
+	int res = dr.open(aFilename);
+	if (res == SO_NO_ERROR)
+		return loadFile(&dr);
+	return res;
+}
+
+result Wav::loadMem(const unsigned char *aMem, unsigned int aLength, bool aCopy, bool aTakeOwnership)
+{
+	if (aMem == NULL || aLength == 0)
+		return INVALID_PARAMETER;
+	stop();
 
-	result Wav::loadRawWave(float *aMem, unsigned int aLength, float aSamplerate, unsigned int aChannels, bool aCopy, bool aTakeOwndership)
+	MemoryFile dr;
+	dr.openMem(aMem, aLength, aCopy, aTakeOwnership);
+	return testAndLoadFile(&dr);
+}
+
+result Wav::loadFile(File *aFile)
+{
+	if (!aFile)
+		return INVALID_PARAMETER;
+	stop();
+
+	MemoryFile mr;
+	result res = mr.openFileToMem(aFile);
+
+	if (res != SO_NO_ERROR)
 	{
-		if (aMem == 0 || aLength == 0 || aSamplerate <= 0 || aChannels < 1)
-			return INVALID_PARAMETER;
-		stop();
-		delete[] mData;
-		if (aCopy == true || aTakeOwndership == false)
-		{
-			mData = new float[aLength];
-			memcpy(mData, aMem, sizeof(float) * aLength);
-		}
-		else
-		{
-			mData = aMem;
-		}
-		mSampleCount = aLength / aChannels;
-		mChannels = aChannels;
-		mBaseSamplerate = aSamplerate;
-		return SO_NO_ERROR;
+		return res;
+	}
+	return testAndLoadFile(&mr);
+}
+
+AudioSourceInstance *Wav::createInstance()
+{
+	return new WavInstance(this);
+}
+
+double Wav::getLength()
+{
+	if (mBaseSamplerate == 0)
+		return 0;
+	return mSampleCount / mBaseSamplerate;
+}
+
+result Wav::loadRawWave8(unsigned char *aMem, unsigned int aLength, float aSamplerate, unsigned int aChannels)
+{
+	if (aMem == 0 || aLength == 0 || aSamplerate <= 0 || aChannels < 1)
+		return INVALID_PARAMETER;
+	stop();
+	delete[] mData;
+	mData = new float[aLength];
+	mSampleCount = aLength / aChannels;
+	mChannels = aChannels;
+	mBaseSamplerate = aSamplerate;
+	unsigned int i;
+	for (i = 0; i < aLength; i++)
+		mData[i] = ((signed)aMem[i] - 128) / (float)0x80;
+	return SO_NO_ERROR;
+}
+
+result Wav::loadRawWave16(short *aMem, unsigned int aLength, float aSamplerate, unsigned int aChannels)
+{
+	if (aMem == 0 || aLength == 0 || aSamplerate <= 0 || aChannels < 1)
+		return INVALID_PARAMETER;
+	stop();
+	delete[] mData;
+	mData = new float[aLength];
+	mSampleCount = aLength / aChannels;
+	mChannels = aChannels;
+	mBaseSamplerate = aSamplerate;
+	unsigned int i;
+	for (i = 0; i < aLength; i++)
+		mData[i] = ((signed short)aMem[i]) / (float)0x8000;
+	return SO_NO_ERROR;
+}
+
+result Wav::loadRawWave(float *aMem, unsigned int aLength, float aSamplerate, unsigned int aChannels, bool aCopy, bool aTakeOwndership)
+{
+	if (aMem == 0 || aLength == 0 || aSamplerate <= 0 || aChannels < 1)
+		return INVALID_PARAMETER;
+	stop();
+	delete[] mData;
+	if (aCopy == true || aTakeOwndership == false)
+	{
+		mData = new float[aLength];
+		memcpy(mData, aMem, sizeof(float) * aLength);
+	}
+	else
+	{
+		mData = aMem;
 	}
-};
+	mSampleCount = aLength / aChannels;
+	mChannels = aChannels;
+	mBaseSamplerate = aSamplerate;
+	return SO_NO_ERROR;
+}
+}; // namespace SoLoud
diff --git a/src/audiosource/wav/soloud_wavstream.cpp b/src/audiosource/wav/soloud_wavstream.cpp
index aeeca53..06542ac 100644
--- a/src/audiosource/wav/soloud_wavstream.cpp
+++ b/src/audiosource/wav/soloud_wavstream.cpp
@@ -22,748 +22,825 @@ freely, subject to the following restrictions:
    distribution.
 */
 
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "soloud.h"
+#include <cmath>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+
 #include "dr_flac.h"
 #include "dr_mp3.h"
 #include "dr_wav.h"
-#include "soloud_wavstream.h"
-#include "soloud_file.h"
 #include "stb_vorbis.h"
 
+#include "soloud_ffmpeg.h"
+#include "soloud_ffmpeg_load.h"
+
+#include "soloud.h"
+#include "soloud_file.h"
+#include "soloud_wavstream.h"
+
 namespace SoLoud
 {
-	size_t drflac_read_func(void* pUserData, void* pBufferOut, size_t bytesToRead)
-	{
-		File *fp = (File*)pUserData;
-		return fp->read((unsigned char*)pBufferOut, (unsigned int)bytesToRead);
-	}
+size_t drflac_read_func(void *pUserData, void *pBufferOut, size_t bytesToRead)
+{
+	File *fp = (File *)pUserData;
+	return fp->read((unsigned char *)pBufferOut, (unsigned int)bytesToRead);
+}
 
-	size_t drmp3_read_func(void* pUserData, void* pBufferOut, size_t bytesToRead)
-	{
-		File *fp = (File*)pUserData;
-		return fp->read((unsigned char*)pBufferOut, (unsigned int)bytesToRead);
-	}
+size_t drmp3_read_func(void *pUserData, void *pBufferOut, size_t bytesToRead)
+{
+	File *fp = (File *)pUserData;
+	return fp->read((unsigned char *)pBufferOut, (unsigned int)bytesToRead);
+}
+
+size_t drwav_read_func(void *pUserData, void *pBufferOut, size_t bytesToRead)
+{
+	File *fp = (File *)pUserData;
+	return fp->read((unsigned char *)pBufferOut, (unsigned int)bytesToRead);
+}
 
-	size_t drwav_read_func(void* pUserData, void* pBufferOut, size_t bytesToRead)
+drflac_bool32 drflac_seek_func(void *pUserData, int offset, drflac_seek_origin origin)
+{
+	File *fp = (File *)pUserData;
+	if (origin != drflac_seek_origin_start)
+		offset += fp->pos();
+	fp->seek(offset);
+	return 1;
+}
+
+drmp3_bool32 drmp3_seek_func(void *pUserData, int offset, drmp3_seek_origin origin)
+{
+	File *fp = (File *)pUserData;
+	if (origin != drmp3_seek_origin_start)
+		offset += fp->pos();
+	fp->seek(offset);
+	return 1;
+}
+
+drmp3_bool32 drwav_seek_func(void *pUserData, int offset, drwav_seek_origin origin)
+{
+	File *fp = (File *)pUserData;
+	if (origin != drwav_seek_origin_start)
+		offset += fp->pos();
+	fp->seek(offset);
+	return 1;
+}
+
+WavStreamInstance::WavStreamInstance(WavStream *aParent)
+{
+	mOggFrameSize = 0;
+	mParent = aParent;
+	mOffset = 0;
+	mCodec.mOgg = 0;
+	mCodec.mFlac = 0;
+	mCodec.mWav = 0;
+	mCodec.mMp3 = 0;
+	mCodec.mFfmpeg = 0;
+	mFile = 0;
+
+	if (aParent->mMemFile)
 	{
-		File *fp = (File*)pUserData;
-		return fp->read((unsigned char*)pBufferOut, (unsigned int)bytesToRead);
+		MemoryFile *mf = new MemoryFile();
+		mFile = mf;
+		mf->openMem(aParent->mMemFile->getMemPtr(), aParent->mMemFile->length(), false, false);
 	}
-
-	drflac_bool32 drflac_seek_func(void* pUserData, int offset, drflac_seek_origin origin)
+	else if (aParent->mFilename)
 	{
-		File *fp = (File*)pUserData;
-		if (origin != drflac_seek_origin_start)
-			offset += fp->pos();
-		fp->seek(offset);
-		return 1;
+		DiskFile *df = new DiskFile;
+		mFile = df;
+		df->open(aParent->mFilename);
 	}
-
-	drmp3_bool32 drmp3_seek_func(void* pUserData, int offset, drmp3_seek_origin origin)
+	else if (aParent->mStreamFile)
 	{
-		File *fp = (File*)pUserData;
-		if (origin != drmp3_seek_origin_start)
-			offset += fp->pos();
-		fp->seek(offset);
-		return 1;
+		mFile = aParent->mStreamFile;
+		mFile->seek(0); // stb_vorbis assumes file offset to be at start of ogg
 	}
-
-	drmp3_bool32 drwav_seek_func(void* pUserData, int offset, drwav_seek_origin origin)
+	else
 	{
-		File *fp = (File*)pUserData;
-		if (origin != drwav_seek_origin_start)
-			offset += fp->pos();
-		fp->seek(offset);
-		return 1;
+		return;
 	}
 
-	WavStreamInstance::WavStreamInstance(WavStream *aParent)
+	if (mFile)
 	{
-		mOggFrameSize = 0;
-		mParent = aParent;
-		mOffset = 0;
-		mCodec.mOgg = 0;
-		mCodec.mFlac = 0;
-		mFile = 0;
-		if (aParent->mMemFile)
-		{
-			MemoryFile *mf = new MemoryFile();
-			mFile = mf;
-			mf->openMem(aParent->mMemFile->getMemPtr(), aParent->mMemFile->length(), false, false);
-		}
-		else
-		if (aParent->mFilename)
-		{
-			DiskFile *df = new DiskFile;
-			mFile = df;
-			df->open(aParent->mFilename);
-		}
-		else
-		if (aParent->mStreamFile)
-		{
-			mFile = aParent->mStreamFile;
-			mFile->seek(0); // stb_vorbis assumes file offset to be at start of ogg
-		}
-		else
-		{
-			return;
-		}
-
-		if (mFile)
+		if (mParent->mFiletype == WAVSTREAM_WAV)
 		{
-			if (mParent->mFiletype == WAVSTREAM_WAV)
+			mCodec.mWav = new drwav;
+			if (!drwav_init(mCodec.mWav, drwav_read_func, drwav_seek_func, (void *)mFile, NULL))
 			{
-				mCodec.mWav = new drwav;
-				if (!drwav_init(mCodec.mWav, drwav_read_func, drwav_seek_func, (void*)mFile, NULL))
-				{
-					delete mCodec.mWav;
-					mCodec.mWav = 0;
-					if (mFile != mParent->mStreamFile)
-						delete mFile;
-					mFile = 0;
-				}
+				delete mCodec.mWav;
+				mCodec.mWav = 0;
+				if (mFile != mParent->mStreamFile)
+					delete mFile;
+				mFile = 0;
 			}
-			else
-			if (mParent->mFiletype == WAVSTREAM_OGG)
-			{
-				int e;
+		}
+		else if (mParent->mFiletype == WAVSTREAM_OGG)
+		{
+			int e;
 
-				mCodec.mOgg = stb_vorbis_open_file((Soloud_Filehack *)mFile, 0, &e, 0);
+			mCodec.mOgg = stb_vorbis_open_file((Soloud_Filehack *)mFile, 0, &e, 0);
 
-				if (!mCodec.mOgg)
-				{
-					if (mFile != mParent->mStreamFile)
-						delete mFile;
-					mFile = 0;
-				}
-				mOggFrameSize = 0;
-				mOggFrameOffset = 0;
-				mOggOutputs = 0;
-			}
-			else
-			if (mParent->mFiletype == WAVSTREAM_FLAC)
-			{
-				mCodec.mFlac = drflac_open(drflac_read_func, drflac_seek_func, (void*)mFile, NULL);
-				if (!mCodec.mFlac)
-				{
-					if (mFile != mParent->mStreamFile)
-						delete mFile;
-					mFile = 0;
-				}
-			}
-			else
-			if (mParent->mFiletype == WAVSTREAM_MP3)
-			{
-				mCodec.mMp3 = new drmp3;
-				if (!drmp3_init(mCodec.mMp3, drmp3_read_func, drmp3_seek_func, NULL, NULL, (void*)mFile, NULL))
-				{
-					delete mCodec.mMp3;
-					mCodec.mMp3 = 0;
-					if (mFile != mParent->mStreamFile)
-						delete mFile;
-					mFile = 0;
-				}
-				else if (mParent->mMp3SeekPointCount > 0 && mParent->mMp3SeekPoints != nullptr)
-				{
-					drmp3_bind_seek_table(mCodec.mMp3, mParent->mMp3SeekPointCount, mParent->mMp3SeekPoints);
-				}
-			}
-			else
+			if (!mCodec.mOgg)
 			{
 				if (mFile != mParent->mStreamFile)
 					delete mFile;
-				mFile = NULL;
-				return;
+				mFile = 0;
 			}
+			mOggFrameSize = 0;
+			mOggFrameOffset = 0;
+			mOggOutputs = 0;
 		}
-	}
-
-	WavStreamInstance::~WavStreamInstance()
-	{
-		switch (mParent->mFiletype)
+		else if (mParent->mFiletype == WAVSTREAM_FLAC)
 		{
-		case WAVSTREAM_OGG:
-			if (mCodec.mOgg)
+			mCodec.mFlac = drflac_open(drflac_read_func, drflac_seek_func, (void *)mFile, NULL);
+			if (!mCodec.mFlac)
 			{
-				stb_vorbis_close(mCodec.mOgg);
-			}
-			break;
-		case WAVSTREAM_FLAC:
-			if (mCodec.mFlac)
-			{
-				drflac_close(mCodec.mFlac);
+				if (mFile != mParent->mStreamFile)
+					delete mFile;
+				mFile = 0;
 			}
-			break;
-		case WAVSTREAM_MP3:
-			if (mCodec.mMp3)
+		}
+		else if (mParent->mFiletype == WAVSTREAM_MP3)
+		{
+			mCodec.mMp3 = new drmp3;
+			if (!drmp3_init(mCodec.mMp3, drmp3_read_func, drmp3_seek_func, NULL, NULL, (void *)mFile, NULL))
 			{
-				drmp3_uninit(mCodec.mMp3);
 				delete mCodec.mMp3;
 				mCodec.mMp3 = 0;
+				if (mFile != mParent->mStreamFile)
+					delete mFile;
+				mFile = 0;
 			}
-			break;
-		case WAVSTREAM_WAV:
-			if (mCodec.mWav)
+			else if (mParent->mMp3SeekPointCount > 0 && mParent->mMp3SeekPoints != nullptr)
 			{
-				drwav_uninit(mCodec.mWav);
-				delete mCodec.mWav;
-				mCodec.mWav = 0;
+				drmp3_bind_seek_table(mCodec.mMp3, mParent->mMp3SeekPointCount, mParent->mMp3SeekPoints);
+			}
+		}
+		else if (mParent->mFiletype == WAVSTREAM_FFMPEG)
+		{
+			mCodec.mFfmpeg = FFmpeg::open(mFile);
+			if (!mCodec.mFfmpeg)
+			{
+				if (mFile != mParent->mStreamFile)
+					delete mFile;
+				mFile = 0;
 			}
-			break;
 		}
-		if (mFile != mParent->mStreamFile)
+		else
 		{
-			delete mFile;
+			if (mFile != mParent->mStreamFile)
+				delete mFile;
+			mFile = NULL;
+			return;
 		}
 	}
+}
 
-	static int getOggData(float **aOggOutputs, float *aBuffer, int aSamples, int aPitch, int aFrameSize, int aFrameOffset, int aChannels)
+WavStreamInstance::~WavStreamInstance()
+{
+	switch (mParent->mFiletype)
 	{
-		if (aFrameSize <= 0)
-			return 0;
-
-		int samples = aSamples;
-		if (aFrameSize - aFrameOffset < samples)
+	case WAVSTREAM_OGG:
+		if (mCodec.mOgg)
 		{
-			samples = aFrameSize - aFrameOffset;
+			stb_vorbis_close(mCodec.mOgg);
 		}
-
-		int i;
-		for (i = 0; i < aChannels; i++)
+		break;
+	case WAVSTREAM_FLAC:
+		if (mCodec.mFlac)
 		{
-			memcpy(aBuffer + aPitch * i, aOggOutputs[i] + aFrameOffset, sizeof(float) * samples);
+			drflac_close(mCodec.mFlac);
 		}
-		return samples;
+		break;
+	case WAVSTREAM_MP3:
+		if (mCodec.mMp3)
+		{
+			drmp3_uninit(mCodec.mMp3);
+			delete mCodec.mMp3;
+			mCodec.mMp3 = 0;
+		}
+		break;
+	case WAVSTREAM_WAV:
+		if (mCodec.mWav)
+		{
+			drwav_uninit(mCodec.mWav);
+			delete mCodec.mWav;
+			mCodec.mWav = 0;
+		}
+		break;
+	case WAVSTREAM_FFMPEG:
+		if (mCodec.mFfmpeg)
+		{
+			FFmpeg::close(mCodec.mFfmpeg);
+			mCodec.mFfmpeg = nullptr;
+		}
+		break;
+	}
+	if (mFile != mParent->mStreamFile)
+	{
+		delete mFile;
 	}
+}
 
+static int getOggData(float **aOggOutputs, float *aBuffer, int aSamples, int aPitch, int aFrameSize, int aFrameOffset, int aChannels)
+{
+	if (aFrameSize <= 0)
+		return 0;
+
+	int samples = aSamples;
+	if (aFrameSize - aFrameOffset < samples)
+	{
+		samples = aFrameSize - aFrameOffset;
+	}
 
+	int i;
+	for (i = 0; i < aChannels; i++)
+	{
+		memcpy(aBuffer + aPitch * i, aOggOutputs[i] + aFrameOffset, sizeof(float) * samples);
+	}
+	return samples;
+}
 
-	unsigned int WavStreamInstance::getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize)
+unsigned int WavStreamInstance::getAudio(float *aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize)
+{
+	unsigned int offset = 0;
+	float tmp[512 * MAX_CHANNELS];
+	if (aBuffer == NULL || mFile == NULL)
+		return 0;
+	switch (mParent->mFiletype)
 	{
-		unsigned int offset = 0;
-		float tmp[512 * MAX_CHANNELS];
-		if (aBuffer == NULL || mFile == NULL)
-			return 0;
-		switch (mParent->mFiletype)
+	case WAVSTREAM_FLAC: {
+		unsigned int i, j, k;
+
+		for (i = 0; i < aSamplesToRead; i += 512)
 		{
-		case WAVSTREAM_FLAC:
-			{
-				unsigned int i, j, k;
+			unsigned int blockSize = (aSamplesToRead - i) > 512 ? 512 : aSamplesToRead - i;
+			offset += (unsigned int)drflac_read_pcm_frames_f32(mCodec.mFlac, blockSize, tmp);
 
-				for (i = 0; i < aSamplesToRead; i += 512)
-				{
-					unsigned int blockSize = (aSamplesToRead - i) > 512 ? 512 : aSamplesToRead - i;
-					offset += (unsigned int)drflac_read_pcm_frames_f32(mCodec.mFlac, blockSize, tmp);
-
-					for (j = 0; j < blockSize; j++)
-					{
-						for (k = 0; k < mChannels; k++)
-						{
-							aBuffer[k * aSamplesToRead + i + j] = tmp[j * mCodec.mFlac->channels + k];
-						}
-					}
-				}
-				mOffset += offset;
-				return offset;
-			}
-			break;
-		case WAVSTREAM_MP3:
+			for (j = 0; j < blockSize; j++)
 			{
-				unsigned int i, j, k;
-
-				for (i = 0; i < aSamplesToRead; i += 512)
+				for (k = 0; k < mChannels; k++)
 				{
-					unsigned int blockSize = (aSamplesToRead - i) > 512 ? 512 : aSamplesToRead - i;
-					offset += (unsigned int)drmp3_read_pcm_frames_f32(mCodec.mMp3, blockSize, tmp);
-
-					for (j = 0; j < blockSize; j++)
-					{
-						for (k = 0; k < mChannels; k++)
-						{
-							aBuffer[k * aSamplesToRead + i + j] = tmp[j * mCodec.mMp3->channels + k];
-						}
-					}
+					aBuffer[k * aSamplesToRead + i + j] = tmp[j * mCodec.mFlac->channels + k];
 				}
-				mOffset += offset;
-				return offset;
 			}
-		break;
-		case WAVSTREAM_OGG:
-			{
-				if (mOggFrameOffset < mOggFrameSize)
-				{
-					int b = getOggData(mOggOutputs, aBuffer, aSamplesToRead, aBufferSize, mOggFrameSize, mOggFrameOffset, mChannels);
-					mOffset += b;
-					offset += b;
-					mOggFrameOffset += b;
-				}
+		}
+		mOffset += offset;
+		return offset;
+	}
+	break;
+	case WAVSTREAM_MP3: {
+		unsigned int i, j, k;
 
-				while (offset < aSamplesToRead)
-				{
-					mOggFrameSize = stb_vorbis_get_frame_float(mCodec.mOgg, NULL, &mOggOutputs);
-					mOggFrameOffset = 0;
-					int b = getOggData(mOggOutputs, aBuffer + offset, aSamplesToRead - offset, aBufferSize, mOggFrameSize, mOggFrameOffset, mChannels);
-					mOffset += b;
-					offset += b;
-					mOggFrameOffset += b;
-
-					if (mOffset >= mParent->mSampleCount || b == 0)
-					{
-						mOffset += offset;
-						return offset;
-					}
-				}
-			}
-			break;
-		case WAVSTREAM_WAV:
-			{
-				unsigned int i, j, k;
+		for (i = 0; i < aSamplesToRead; i += 512)
+		{
+			unsigned int blockSize = (aSamplesToRead - i) > 512 ? 512 : aSamplesToRead - i;
+			offset += (unsigned int)drmp3_read_pcm_frames_f32(mCodec.mMp3, blockSize, tmp);
 
-				for (i = 0; i < aSamplesToRead; i += 512)
+			for (j = 0; j < blockSize; j++)
+			{
+				for (k = 0; k < mChannels; k++)
 				{
-					unsigned int blockSize = (aSamplesToRead - i) > 512 ? 512 : aSamplesToRead - i;
-					offset += (unsigned int)drwav_read_pcm_frames_f32(mCodec.mWav, blockSize, tmp);
-
-					for (j = 0; j < blockSize; j++)
-					{
-						for (k = 0; k < mChannels; k++)
-						{
-							aBuffer[k * aSamplesToRead + i + j] = tmp[j * mCodec.mWav->channels + k];
-						}
-					}
+					aBuffer[k * aSamplesToRead + i + j] = tmp[j * mCodec.mMp3->channels + k];
 				}
-				mOffset += offset;
-				return offset;
 			}
-			break;
 		}
-		return aSamplesToRead;
+		mOffset += offset;
+		return offset;
 	}
-
-	result WavStreamInstance::seek(double aSeconds, float* mScratch, unsigned int mScratchSize)
-	{
-		if (mParent->mFiletype == WAVSTREAM_MP3 && mCodec.mMp3)
+	break;
+	case WAVSTREAM_OGG: {
+		if (mOggFrameOffset < mOggFrameSize)
 		{
-			drmp3_uint64 targetFrame = (drmp3_uint64)floor(aSeconds * mCodec.mMp3->sampleRate);
-			if (drmp3_seek_to_pcm_frame(mCodec.mMp3, targetFrame))
-			{
-				// Since the position that we just sought to might not be *exactly*
-				// the position we asked for, we're re-calculating the position just
-				// for the sake of correctness.
-				mOffset = (unsigned int)mCodec.mMp3->currentPCMFrame;
-				double newPosition = static_cast<double>(mOffset) / mBaseSamplerate;
-				mStreamPosition = newPosition;
-				return SO_NO_ERROR;
-			}
-			return UNKNOWN_ERROR;
+			int b = getOggData(mOggOutputs, aBuffer, aSamplesToRead, aBufferSize, mOggFrameSize, mOggFrameOffset, mChannels);
+			mOffset += b;
+			offset += b;
+			mOggFrameOffset += b;
 		}
-		else if (mParent->mFiletype == WAVSTREAM_OGG && mCodec.mOgg)
+
+		while (offset < aSamplesToRead)
 		{
-			mOggFrameSize = 0;
+			mOggFrameSize = stb_vorbis_get_frame_float(mCodec.mOgg, NULL, &mOggOutputs);
 			mOggFrameOffset = 0;
+			int b = getOggData(mOggOutputs, aBuffer + offset, aSamplesToRead - offset, aBufferSize, mOggFrameSize, mOggFrameOffset, mChannels);
+			mOffset += b;
+			offset += b;
+			mOggFrameOffset += b;
 
-			int pos = (int)floor(mBaseSamplerate * aSeconds);
-
-			if (stb_vorbis_seek(mCodec.mOgg, pos) == 1)
+			if (mOffset >= mParent->mSampleCount || b == 0)
 			{
-				/* Same as above */
-				mOffset = stb_vorbis_get_sample_offset(mCodec.mOgg);
-				double newPosition = static_cast<double>(mOffset) / mBaseSamplerate;
-				mStreamPosition = newPosition;
-				return SO_NO_ERROR;
+				mOffset += offset;
+				return offset;
 			}
-			return UNKNOWN_ERROR;
 		}
-		else if (mParent->mFiletype == WAVSTREAM_WAV && mCodec.mWav)
+	}
+	break;
+	case WAVSTREAM_WAV: {
+		unsigned int i, j, k;
+
+		for (i = 0; i < aSamplesToRead; i += 512)
 		{
-			drwav_uint64 targetFrame = (drwav_uint64)floor(aSeconds * mCodec.mWav->sampleRate);
+			unsigned int blockSize = (aSamplesToRead - i) > 512 ? 512 : aSamplesToRead - i;
+			offset += (unsigned int)drwav_read_pcm_frames_f32(mCodec.mWav, blockSize, tmp);
 
-			if (drwav_seek_to_pcm_frame(mCodec.mWav, targetFrame))
+			for (j = 0; j < blockSize; j++)
 			{
-				/* Same as above */
-				mOffset = (unsigned int)mCodec.mWav->readCursorInPCMFrames;
-				double newPosition = static_cast<double>(mOffset) / mBaseSamplerate;
-				mStreamPosition = newPosition;
-				return SO_NO_ERROR;
+				for (k = 0; k < mChannels; k++)
+				{
+					aBuffer[k * aSamplesToRead + i + j] = tmp[j * mCodec.mWav->channels + k];
+				}
 			}
-			return UNKNOWN_ERROR;
 		}
-		else if (mParent->mFiletype == WAVSTREAM_FLAC && mCodec.mFlac)
+		mOffset += offset;
+		return offset;
+	}
+	break;
+	case WAVSTREAM_FFMPEG: {
+		if (mCodec.mFfmpeg)
 		{
-			drflac_uint64 targetFrame = (drflac_uint64)floor(aSeconds * mCodec.mFlac->sampleRate);
-
-			if (drflac_seek_to_pcm_frame(mCodec.mFlac, targetFrame))
-			{
-				/* Same as above */
-				mOffset = (unsigned int)mCodec.mFlac->currentPCMFrame;
-				double newPosition = static_cast<double>(mOffset) / mBaseSamplerate;
-				mStreamPosition = newPosition;
-				return SO_NO_ERROR;
-			}
-			return UNKNOWN_ERROR;
+			offset = (unsigned int)FFmpeg::readFrames(mCodec.mFfmpeg, aSamplesToRead, aBuffer);
+			mOffset += offset;
 		}
-		return AudioSourceInstance::seek(aSeconds, mScratch, mScratchSize);
+		return offset;
+	}
+	break;
 	}
+	return aSamplesToRead;
+}
 
-	result WavStreamInstance::rewind()
+result WavStreamInstance::seek(double aSeconds, float *mScratch, unsigned int mScratchSize)
+{
+	if (mParent->mFiletype == WAVSTREAM_MP3 && mCodec.mMp3)
+	{
+		drmp3_uint64 targetFrame = (drmp3_uint64)floor(aSeconds * mCodec.mMp3->sampleRate);
+		if (drmp3_seek_to_pcm_frame(mCodec.mMp3, targetFrame))
+		{
+			// Since the position that we just sought to might not be *exactly*
+			// the position we asked for, we're re-calculating the position just
+			// for the sake of correctness.
+			mOffset = (unsigned int)mCodec.mMp3->currentPCMFrame;
+			double newPosition = static_cast<double>(mOffset) / mBaseSamplerate;
+			mStreamPosition = newPosition;
+			return SO_NO_ERROR;
+		}
+		return UNKNOWN_ERROR;
+	}
+	else if (mParent->mFiletype == WAVSTREAM_OGG && mCodec.mOgg)
 	{
-		switch (mParent->mFiletype)
+		mOggFrameSize = 0;
+		mOggFrameOffset = 0;
+
+		int pos = (int)floor(mBaseSamplerate * aSeconds);
+
+		if (stb_vorbis_seek(mCodec.mOgg, pos) == 1)
 		{
-		case WAVSTREAM_OGG:
-			if (mCodec.mOgg)
-			{
-				stb_vorbis_seek_start(mCodec.mOgg);
-			}
-			break;
-		case WAVSTREAM_FLAC:
-			if (mCodec.mFlac)
-			{
-				drflac_seek_to_pcm_frame(mCodec.mFlac, 0);
-			}
-			break;
-		case WAVSTREAM_MP3:
-			if (mCodec.mMp3)
-			{
-				drmp3_seek_to_pcm_frame(mCodec.mMp3, 0);
-			}
-			break;
-		case WAVSTREAM_WAV:
-			if (mCodec.mWav)
-			{
-				drwav_seek_to_pcm_frame(mCodec.mWav, 0);
-			}
-			break;
+			/* Same as above */
+			mOffset = stb_vorbis_get_sample_offset(mCodec.mOgg);
+			double newPosition = static_cast<double>(mOffset) / mBaseSamplerate;
+			mStreamPosition = newPosition;
+			return SO_NO_ERROR;
 		}
-		mOffset = 0;
-		mStreamPosition = 0.0f;
-		return 0;
+		return UNKNOWN_ERROR;
 	}
+	else if (mParent->mFiletype == WAVSTREAM_WAV && mCodec.mWav)
+	{
+		drwav_uint64 targetFrame = (drwav_uint64)floor(aSeconds * mCodec.mWav->sampleRate);
 
-	bool WavStreamInstance::hasEnded()
+		if (drwav_seek_to_pcm_frame(mCodec.mWav, targetFrame))
+		{
+			/* Same as above */
+			mOffset = (unsigned int)mCodec.mWav->readCursorInPCMFrames;
+			double newPosition = static_cast<double>(mOffset) / mBaseSamplerate;
+			mStreamPosition = newPosition;
+			return SO_NO_ERROR;
+		}
+		return UNKNOWN_ERROR;
+	}
+	else if (mParent->mFiletype == WAVSTREAM_FLAC && mCodec.mFlac)
 	{
-		if (mOffset >= mParent->mSampleCount)
+		drflac_uint64 targetFrame = (drflac_uint64)floor(aSeconds * mCodec.mFlac->sampleRate);
+
+		if (drflac_seek_to_pcm_frame(mCodec.mFlac, targetFrame))
 		{
-			return 1;
+			/* Same as above */
+			mOffset = (unsigned int)mCodec.mFlac->currentPCMFrame;
+			double newPosition = static_cast<double>(mOffset) / mBaseSamplerate;
+			mStreamPosition = newPosition;
+			return SO_NO_ERROR;
 		}
-		else if (mParent->mFiletype == WAVSTREAM_MP3 && mCodec.mMp3 && mCodec.mMp3->atEnd) // no idea
+		return UNKNOWN_ERROR;
+	}
+	else if (mParent->mFiletype == WAVSTREAM_FFMPEG && mCodec.mFfmpeg)
+	{
+		unsigned long long targetFrame = (unsigned long long)floor(aSeconds * mBaseSamplerate);
+
+		if (FFmpeg::seekToFrame(mCodec.mFfmpeg, targetFrame))
 		{
-			mOffset = mParent->mSampleCount;
-			return 1;
+			mOffset = (unsigned int)FFmpeg::getCurrentFrame(mCodec.mFfmpeg);
+			mStreamPosition = static_cast<double>(mOffset) / mBaseSamplerate;
+			return SO_NO_ERROR;
 		}
-		return 0;
+		return UNKNOWN_ERROR;
 	}
+	return AudioSourceInstance::seek(aSeconds, mScratch, mScratchSize);
+}
 
-	WavStream::WavStream()
+result WavStreamInstance::rewind()
+{
+	switch (mParent->mFiletype)
 	{
-		mFilename = 0;
-		mSampleCount = 0;
-		mFiletype = WAVSTREAM_WAV;
-		mMemFile = 0;
-		mStreamFile = 0;
-		mMp3SeekPoints = nullptr;
-		mMp3SeekPointCount = 0;
+	case WAVSTREAM_OGG:
+		if (mCodec.mOgg)
+		{
+			stb_vorbis_seek_start(mCodec.mOgg);
+		}
+		break;
+	case WAVSTREAM_FLAC:
+		if (mCodec.mFlac)
+		{
+			drflac_seek_to_pcm_frame(mCodec.mFlac, 0);
+		}
+		break;
+	case WAVSTREAM_MP3:
+		if (mCodec.mMp3)
+		{
+			drmp3_seek_to_pcm_frame(mCodec.mMp3, 0);
+		}
+		break;
+	case WAVSTREAM_WAV:
+		if (mCodec.mWav)
+		{
+			drwav_seek_to_pcm_frame(mCodec.mWav, 0);
+		}
+		break;
+	case WAVSTREAM_FFMPEG:
+		if (mCodec.mFfmpeg)
+		{
+			FFmpeg::seekToFrame(mCodec.mFfmpeg, 0);
+		}
+		break;
 	}
+	mOffset = 0;
+	mStreamPosition = 0.0f;
+	return 0;
+}
 
-	WavStream::~WavStream()
+bool WavStreamInstance::hasEnded()
+{
+	if (mOffset >= mParent->mSampleCount)
 	{
-		stop();
-		delete[] mFilename;
-		delete mMemFile;
-		delete[] mMp3SeekPoints;
+		return 1;
 	}
-
-#define MAKEDWORD(a,b,c,d) (((d) << 24) | ((c) << 16) | ((b) << 8) | (a))
-
-	result WavStream::loadwav(File * fp)
+	else if (mParent->mFiletype == WAVSTREAM_MP3 && mCodec.mMp3 && mCodec.mMp3->atEnd)
 	{
-		fp->seek(0);
-		drwav decoder;
+		mOffset = mParent->mSampleCount;
+		return 1;
+	}
+	return 0;
+}
 
-		if (!drwav_init(&decoder, drwav_read_func, drwav_seek_func, (void*)fp, NULL))
-			return FILE_LOAD_FAILED;
+WavStream::WavStream()
+{
+	mFilename = 0;
+	mSampleCount = 0;
+	mFiletype = WAVSTREAM_WAV;
+	mMemFile = 0;
+	mStreamFile = 0;
+	mMp3SeekPoints = nullptr;
+	mMp3SeekPointCount = 0;
+}
+
+WavStream::~WavStream()
+{
+	stop();
+	delete[] mFilename;
+	delete mMemFile;
+	delete[] mMp3SeekPoints;
+}
 
-		mChannels = decoder.channels;
-		if (mChannels > MAX_CHANNELS)
-		{
-			mChannels = MAX_CHANNELS;
-		}
+#define MAKEDWORD(a, b, c, d) (((d) << 24) | ((c) << 16) | ((b) << 8) | (a))
 
-		mBaseSamplerate = (float)decoder.sampleRate;
-		mSampleCount = (unsigned int)decoder.totalPCMFrameCount;
-		mFiletype = WAVSTREAM_WAV;
-		drwav_uninit(&decoder);
+result WavStream::loadwav(File *fp)
+{
+	fp->seek(0);
+	drwav decoder;
 
-		return SO_NO_ERROR;
-	}
+	if (!drwav_init(&decoder, drwav_read_func, drwav_seek_func, (void *)fp, NULL))
+		return FILE_LOAD_FAILED;
 
-	result WavStream::loadogg(File * fp)
+	mChannels = decoder.channels;
+	if (mChannels > MAX_CHANNELS)
 	{
-		fp->seek(0);
-		int e;
-		stb_vorbis *v;
-		v = stb_vorbis_open_file((Soloud_Filehack *)fp, 0, &e, 0);
-		if (v == NULL)
-			return FILE_LOAD_FAILED;
-		stb_vorbis_info info = stb_vorbis_get_info(v);
-		mChannels = info.channels;
-		if (info.channels > MAX_CHANNELS)
-		{
-			mChannels = MAX_CHANNELS;
-		}
-		mBaseSamplerate = (float)info.sample_rate;
-		int samples = stb_vorbis_stream_length_in_samples(v);
-		stb_vorbis_close(v);
-		mFiletype = WAVSTREAM_OGG;
+		mChannels = MAX_CHANNELS;
+	}
 
-		mSampleCount = samples;
+	mBaseSamplerate = (float)decoder.sampleRate;
+	mSampleCount = (unsigned int)decoder.totalPCMFrameCount;
+	mFiletype = WAVSTREAM_WAV;
+	drwav_uninit(&decoder);
 
-		return 0;
-	}
+	return SO_NO_ERROR;
+}
 
-	result WavStream::loadflac(File * fp)
+result WavStream::loadogg(File *fp)
+{
+	fp->seek(0);
+	int e;
+	stb_vorbis *v;
+	v = stb_vorbis_open_file((Soloud_Filehack *)fp, 0, &e, 0);
+	if (v == NULL)
+		return FILE_LOAD_FAILED;
+	stb_vorbis_info info = stb_vorbis_get_info(v);
+	mChannels = info.channels;
+	if (info.channels > MAX_CHANNELS)
 	{
-		fp->seek(0);
-		drflac* decoder = drflac_open(drflac_read_func, drflac_seek_func, (void*)fp, NULL);
+		mChannels = MAX_CHANNELS;
+	}
+	mBaseSamplerate = (float)info.sample_rate;
+	int samples = stb_vorbis_stream_length_in_samples(v);
+	stb_vorbis_close(v);
+	mFiletype = WAVSTREAM_OGG;
 
-		if (decoder == NULL)
-			return FILE_LOAD_FAILED;
+	mSampleCount = samples;
 
-		mChannels = decoder->channels;
-		if (mChannels > MAX_CHANNELS)
-		{
-			mChannels = MAX_CHANNELS;
-		}
+	return 0;
+}
 
-		mBaseSamplerate = (float)decoder->sampleRate;
-		mSampleCount = (unsigned int)decoder->totalPCMFrameCount;
-		mFiletype = WAVSTREAM_FLAC;
-		drflac_close(decoder);
+result WavStream::loadflac(File *fp)
+{
+	fp->seek(0);
+	drflac *decoder = drflac_open(drflac_read_func, drflac_seek_func, (void *)fp, NULL);
 
-		return SO_NO_ERROR;
-	}
+	if (decoder == NULL)
+		return FILE_LOAD_FAILED;
 
-	result WavStream::loadmp3(File * fp)
+	mChannels = decoder->channels;
+	if (mChannels > MAX_CHANNELS)
 	{
-		fp->seek(0);
-		drmp3 decoder;
-		if (!drmp3_init(&decoder, drmp3_read_func, drmp3_seek_func, NULL, NULL, (void*)fp, NULL))
-			return FILE_LOAD_FAILED;
+		mChannels = MAX_CHANNELS;
+	}
 
-		mChannels = decoder.channels;
-		if (mChannels > MAX_CHANNELS)
-		{
-			mChannels = MAX_CHANNELS;
-		}
+	mBaseSamplerate = (float)decoder->sampleRate;
+	mSampleCount = (unsigned int)decoder->totalPCMFrameCount;
+	mFiletype = WAVSTREAM_FLAC;
+	drflac_close(decoder);
 
-		drmp3_uint64 samples = drmp3_get_pcm_frame_count(&decoder);
+	return SO_NO_ERROR;
+}
 
-		mBaseSamplerate = (float)decoder.sampleRate;
-		mSampleCount = (unsigned int)samples;
-		mFiletype = WAVSTREAM_MP3;
+result WavStream::loadmp3(File *fp)
+{
+	fp->seek(0);
+	drmp3 decoder;
+	if (!drmp3_init(&decoder, drmp3_read_func, drmp3_seek_func, NULL, NULL, (void *)fp, NULL))
+		return FILE_LOAD_FAILED;
 
-		delete[] mMp3SeekPoints;
-		mMp3SeekPoints = nullptr;
-		mMp3SeekPointCount = 0;
+	mChannels = decoder.channels;
+	if (mChannels > MAX_CHANNELS)
+	{
+		mChannels = MAX_CHANNELS;
+	}
 
-		double fileLengthSeconds = static_cast<double>(mSampleCount) / mBaseSamplerate;
-		double seekPointIntervalSeconds = 5.0; // 1 seek point every 5 seconds
+	drmp3_uint64 samples = drmp3_get_pcm_frame_count(&decoder);
 
-		// cap seek points to avoid memory blowup
-		mMp3SeekPointCount = (drmp3_uint32)((fileLengthSeconds / seekPointIntervalSeconds) + 1);
-		mMp3SeekPointCount = mMp3SeekPointCount < 16 ? 16 : mMp3SeekPointCount;
-		mMp3SeekPointCount = mMp3SeekPointCount > 1000 ? 1000 : mMp3SeekPointCount;
+	mBaseSamplerate = (float)decoder.sampleRate;
+	mSampleCount = (unsigned int)samples;
+	mFiletype = WAVSTREAM_MP3;
 
-		mMp3SeekPoints = new drmp3_seek_point[mMp3SeekPointCount];
-		if (!drmp3_calculate_seek_points(&decoder, &mMp3SeekPointCount, mMp3SeekPoints)) {
-			delete[] mMp3SeekPoints;
-			mMp3SeekPoints = nullptr;
-			mMp3SeekPointCount = 0;
-		}
+	delete[] mMp3SeekPoints;
+	mMp3SeekPoints = nullptr;
+	mMp3SeekPointCount = 0;
 
-		drmp3_uninit(&decoder);
+	double fileLengthSeconds = static_cast<double>(mSampleCount) / mBaseSamplerate;
+	double seekPointIntervalSeconds = 5.0; // 1 seek point every 5 seconds
 
-		return SO_NO_ERROR;
-	}
+	// cap seek points to avoid memory blowup
+	mMp3SeekPointCount = (drmp3_uint32)((fileLengthSeconds / seekPointIntervalSeconds) + 1);
+	mMp3SeekPointCount = mMp3SeekPointCount < 16 ? 16 : mMp3SeekPointCount;
+	mMp3SeekPointCount = mMp3SeekPointCount > 1000 ? 1000 : mMp3SeekPointCount;
 
-	result WavStream::load(const char *aFilename)
+	mMp3SeekPoints = new drmp3_seek_point[mMp3SeekPointCount];
+	if (!drmp3_calculate_seek_points(&decoder, &mMp3SeekPointCount, mMp3SeekPoints))
 	{
-		delete[] mFilename;
-		delete mMemFile;
 		delete[] mMp3SeekPoints;
 		mMp3SeekPoints = nullptr;
 		mMp3SeekPointCount = 0;
-		mMemFile = 0;
-		mFilename = 0;
-		mSampleCount = 0;
-		DiskFile fp;
-		int res = fp.open(aFilename);
-		if (res != SO_NO_ERROR)
-			return res;
-
-		int len = (int)strlen(aFilename);
-		mFilename = new char[len+1];
-		memcpy(mFilename, aFilename, len);
-		mFilename[len] = 0;
+	}
 
-		res = parse(&fp);
+	drmp3_uninit(&decoder);
 
-		if (res != SO_NO_ERROR)
-		{
-			delete[] mFilename;
-			mFilename = 0;
-			return res;
-		}
+	return SO_NO_ERROR;
+}
 
-		return 0;
+result WavStream::loadffmpeg(File *fp)
+{
+	if (mSoloud)
+		mSoloud->lockAudioMutex_internal();
+	result retval = (!FFmpeg::FFmpegLoader::init() || !FFmpeg::FFmpegLoader::isAvailable()) ? FILE_LOAD_FAILED : SO_NO_ERROR;
+	if (mSoloud)
+		mSoloud->unlockAudioMutex_internal();
+	if (retval != SO_NO_ERROR)
+	{
+#ifdef _DEBUG
+		printf("debug: failed to load ffmpeg %s\n", FFmpeg::FFmpegLoader::getErrorDetails().c_str());
+#endif
+		return retval;
 	}
 
-	result WavStream::loadMem(const unsigned char *aData, unsigned int aDataLen, bool aCopy, bool aTakeOwnership)
-	{
-		delete[] mFilename;
-		delete mMemFile;
-		delete[] mMp3SeekPoints;
-		mMp3SeekPoints = nullptr;
-		mMp3SeekPointCount = 0;
-		mStreamFile = 0;
-		mMemFile = 0;
-		mFilename = 0;
-		mSampleCount = 0;
+	fp->seek(0);
+	FFmpeg::FFmpegDecoder *decoder = FFmpeg::open(fp);
+	if (!decoder)
+		return FILE_LOAD_FAILED;
 
-		if (aData == NULL || aDataLen == 0)
-			return INVALID_PARAMETER;
+	mChannels = FFmpeg::getChannels(decoder);
+	if (mChannels > MAX_CHANNELS)
+	{
+		mChannels = MAX_CHANNELS;
+	}
+	mBaseSamplerate = (float)FFmpeg::getSampleRate(decoder);
+	mSampleCount = (unsigned int)FFmpeg::getTotalFrameCount(decoder);
+	mFiletype = WAVSTREAM_FFMPEG;
 
-		MemoryFile *mf = new MemoryFile();
-		int res = mf->openMem(aData, aDataLen, aCopy, aTakeOwnership);
-		if (res != SO_NO_ERROR)
-		{
-			delete mf;
-			return res;
-		}
+	FFmpeg::close(decoder);
+	return SO_NO_ERROR;
+}
 
-		res = parse(mf);
+result WavStream::load(const char *aFilename)
+{
+	delete[] mFilename;
+	delete mMemFile;
+	delete[] mMp3SeekPoints;
+	mMp3SeekPoints = nullptr;
+	mMp3SeekPointCount = 0;
+	mMemFile = 0;
+	mFilename = 0;
+	mSampleCount = 0;
+	DiskFile fp;
+	int res = fp.open(aFilename);
+	if (res != SO_NO_ERROR)
+		return res;
 
-		if (res != SO_NO_ERROR)
-		{
-			delete mf;
-			return res;
-		}
+	int len = (int)strlen(aFilename);
+	mFilename = new char[len + 1];
+	memcpy(mFilename, aFilename, len);
+	mFilename[len] = 0;
 
-		mMemFile = mf;
+	res = parse(&fp);
 
-		return 0;
+	if (res != SO_NO_ERROR)
+	{
+		delete[] mFilename;
+		mFilename = 0;
+		return res;
 	}
 
-	result WavStream::loadToMem(const char *aFilename)
+	return 0;
+}
+
+result WavStream::loadMem(const unsigned char *aData, unsigned int aDataLen, bool aCopy, bool aTakeOwnership)
+{
+	delete[] mFilename;
+	delete mMemFile;
+	delete[] mMp3SeekPoints;
+	mMp3SeekPoints = nullptr;
+	mMp3SeekPointCount = 0;
+	mStreamFile = 0;
+	mMemFile = 0;
+	mFilename = 0;
+	mSampleCount = 0;
+
+	if (aData == NULL || aDataLen == 0)
+		return INVALID_PARAMETER;
+
+	MemoryFile *mf = new MemoryFile();
+	int res = mf->openMem(aData, aDataLen, aCopy, aTakeOwnership);
+	if (res != SO_NO_ERROR)
 	{
-		DiskFile df;
-		int res = df.open(aFilename);
-		if (res == SO_NO_ERROR)
-		{
-			res = loadFileToMem(&df);
-		}
+		delete mf;
 		return res;
 	}
 
-	result WavStream::loadFile(File *aFile)
-	{
-		delete[] mFilename;
-		delete mMemFile;
-		delete[] mMp3SeekPoints;
-		mMp3SeekPoints = nullptr;
-		mMp3SeekPointCount = 0;
-		mStreamFile = 0;
-		mMemFile = 0;
-		mFilename = 0;
-		mSampleCount = 0;
+	res = parse(mf);
 
-		int res = parse(aFile);
+	if (res != SO_NO_ERROR)
+	{
+		delete mf;
+		return res;
+	}
 
-		if (res != SO_NO_ERROR)
-		{
-			return res;
-		}
+	mMemFile = mf;
 
-		mStreamFile = aFile;
+	return 0;
+}
 
-		return 0;
+result WavStream::loadToMem(const char *aFilename)
+{
+	DiskFile df;
+	int res = df.open(aFilename);
+	if (res == SO_NO_ERROR)
+	{
+		res = loadFileToMem(&df);
 	}
+	return res;
+}
 
-	result WavStream::loadFileToMem(File *aFile)
+result WavStream::loadFile(File *aFile)
+{
+	delete[] mFilename;
+	delete mMemFile;
+	delete[] mMp3SeekPoints;
+	mMp3SeekPoints = nullptr;
+	mMp3SeekPointCount = 0;
+	mStreamFile = 0;
+	mMemFile = 0;
+	mFilename = 0;
+	mSampleCount = 0;
+
+	int res = parse(aFile);
+
+	if (res != SO_NO_ERROR)
 	{
-		delete[] mFilename;
-		delete mMemFile;
-		delete[] mMp3SeekPoints;
-		mMp3SeekPoints = nullptr;
-		mMp3SeekPointCount = 0;
-		mStreamFile = 0;
-		mMemFile = 0;
-		mFilename = 0;
-		mSampleCount = 0;
-
-		MemoryFile *mf = new MemoryFile();
-		int res = mf->openFileToMem(aFile);
-		if (res != SO_NO_ERROR)
-		{
-			delete mf;
-			return res;
-		}
+		return res;
+	}
 
-		res = parse(mf);
+	mStreamFile = aFile;
 
-		if (res != SO_NO_ERROR)
-		{
-			delete mf;
-			return res;
-		}
-
-		mMemFile = mf;
+	return 0;
+}
 
+result WavStream::loadFileToMem(File *aFile)
+{
+	delete[] mFilename;
+	delete mMemFile;
+	delete[] mMp3SeekPoints;
+	mMp3SeekPoints = nullptr;
+	mMp3SeekPointCount = 0;
+	mStreamFile = 0;
+	mMemFile = 0;
+	mFilename = 0;
+	mSampleCount = 0;
+
+	MemoryFile *mf = new MemoryFile();
+	int res = mf->openFileToMem(aFile);
+	if (res != SO_NO_ERROR)
+	{
+		delete mf;
 		return res;
 	}
 
+	res = parse(mf);
 
-	result WavStream::parse(File *aFile)
+	if (res != SO_NO_ERROR)
 	{
-		int tag = aFile->read32();
-		int res = SO_NO_ERROR;
-		if (tag == MAKEDWORD('O', 'g', 'g', 'S'))
-		{
-			res = loadogg(aFile);
-		}
-		else
-		if (tag == MAKEDWORD('R', 'I', 'F', 'F'))
-		{
-			res = loadwav(aFile);
-		}
-		else
-		if (tag == MAKEDWORD('f', 'L', 'a', 'C'))
-		{
-			res = loadflac(aFile);
-		}
-		else
-		if (loadmp3(aFile) == SO_NO_ERROR)
-		{
-			res = SO_NO_ERROR;
-		}
-		else
-		{
-			res = FILE_LOAD_FAILED;
-		}
+		delete mf;
 		return res;
 	}
 
-	AudioSourceInstance *WavStream::createInstance()
+	mMemFile = mf;
+
+	return res;
+}
+
+result WavStream::parse(File *aFile)
+{
+	int tag = aFile->read32();
+	int res = SO_NO_ERROR;
+	if (tag == MAKEDWORD('O', 'g', 'g', 'S'))
 	{
-		return new WavStreamInstance(this);
+		res = loadogg(aFile);
 	}
-
-	double WavStream::getLength()
+	else if (tag == MAKEDWORD('R', 'I', 'F', 'F'))
+	{
+		res = loadwav(aFile);
+	}
+	else if (tag == MAKEDWORD('f', 'L', 'a', 'C'))
+	{
+		res = loadflac(aFile);
+	}
+	else if (loadmp3(aFile) == SO_NO_ERROR)
+	{
+		res = SO_NO_ERROR;
+	}
+	else if (loadffmpeg(aFile) == SO_NO_ERROR)
+	{
+		res = SO_NO_ERROR;
+	}
+	else
 	{
-		if (mBaseSamplerate == 0)
-			return 0;
-		return static_cast<double>(mSampleCount) / mBaseSamplerate;
+		res = FILE_LOAD_FAILED;
 	}
-};
+	return res;
+}
+
+AudioSourceInstance *WavStream::createInstance()
+{
+	return new WavStreamInstance(this);
+}
+
+double WavStream::getLength()
+{
+	if (mBaseSamplerate == 0)
+		return 0;
+	return static_cast<double>(mSampleCount) / mBaseSamplerate;
+}
+}; // namespace SoLoud
-- 
2.49.0


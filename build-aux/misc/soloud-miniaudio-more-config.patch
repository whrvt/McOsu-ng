From 5c269f0c1aa6843a0ba70bd422daf8032744fcaf Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Thu, 12 Jun 2025 22:41:56 -0700
Subject: [PATCH] miniaudio config

---
 include/soloud.h                           |   6 +
 include/soloud_internal.h                  |  10 +
 src/backend/miniaudio/miniaudio.h          |   6 +-
 src/backend/miniaudio/soloud_miniaudio.cpp | 362 ++++++++++++++++++---
 src/core/soloud.cpp                        | 101 +++++-
 5 files changed, 428 insertions(+), 57 deletions(-)

diff --git a/include/soloud.h b/include/soloud.h
index ed042a2..808c067 100644
--- a/include/soloud.h
+++ b/include/soloud.h
@@ -495,8 +495,14 @@ public:
 
 	// Returns mixed float samples in buffer. Called by the back-end, or user with null driver.
 	void mix(float *aBuffer, unsigned int aSamples);
+	// Returns mixed 8-bit unsigned integer samples in buffer. Called by the back-end, or user with null driver.
+	void mixUnsigned8(unsigned char *aBuffer, unsigned int aSamples);
 	// Returns mixed 16-bit signed integer samples in buffer. Called by the back-end, or user with null driver.
 	void mixSigned16(short *aBuffer, unsigned int aSamples);
+	// Returns mixed 24-bit signed integer samples in buffer. Called by the back-end, or user with null driver.
+	void mixSigned24(unsigned char *aBuffer, unsigned int aSamples);
+	// Returns mixed 32-bit signed integer samples in buffer. Called by the back-end, or user with null driver.
+	void mixSigned32(int *aBuffer, unsigned int aSamples);
 
 public:
 	// Mix N samples * M channels. Called by other mix_ functions.
diff --git a/include/soloud_internal.h b/include/soloud_internal.h
index 0838ce6..62a0fbf 100644
--- a/include/soloud_internal.h
+++ b/include/soloud_internal.h
@@ -89,8 +89,18 @@ namespace SoLoud
 	// Interlace samples in a buffer. From 11112222 to 12121212
 	void interlace_samples_float(const float *aSourceBuffer, float *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride);
 
+	// Convert to unsigned 8-bit and interlace samples in a buffer. From 11112222 to 12121212
+	void interlace_samples_u8(const float *aSourceBuffer, unsigned char *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride);
+
 	// Convert to 16-bit and interlace samples in a buffer. From 11112222 to 12121212
 	void interlace_samples_s16(const float *aSourceBuffer, short *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride);
+
+	// Convert to 24-bit (packed) and interlace samples in a buffer. From 11112222 to 12121212
+	void interlace_samples_s24(const float *aSourceBuffer, unsigned char *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride);
+
+	// Convert to 32-bit and interlace samples in a buffer. From 11112222 to 12121212
+	void interlace_samples_s32(const float *aSourceBuffer, int *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride);
+
 };
 
 #define FOR_ALL_VOICES_PRE \
diff --git a/src/backend/miniaudio/miniaudio.h b/src/backend/miniaudio/miniaudio.h
index c74bebe..f7893df 100644
--- a/src/backend/miniaudio/miniaudio.h
+++ b/src/backend/miniaudio/miniaudio.h
@@ -30457,11 +30457,7 @@ static void ma_device_on_rerouted__pulse(ma_pa_stream* pStream, void* pUserData)
 
 static ma_uint32 ma_calculate_period_size_in_frames_from_descriptor__pulse(const ma_device_descriptor* pDescriptor, ma_uint32 nativeSampleRate, ma_performance_profile performanceProfile)
 {
-    /*
-    There have been reports from users where buffers of < ~20ms result glitches when running through
-    PipeWire. To work around this we're going to have to use a different default buffer size.
-    */
-    const ma_uint32 defaultPeriodSizeInMilliseconds_LowLatency   = 25;
+    const ma_uint32 defaultPeriodSizeInMilliseconds_LowLatency   = MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_LOW_LATENCY;
     const ma_uint32 defaultPeriodSizeInMilliseconds_Conservative = MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_CONSERVATIVE;
 
     MA_ASSERT(nativeSampleRate != 0);
diff --git a/src/backend/miniaudio/soloud_miniaudio.cpp b/src/backend/miniaudio/soloud_miniaudio.cpp
index cb9ecad..d887a67 100644
--- a/src/backend/miniaudio/soloud_miniaudio.cpp
+++ b/src/backend/miniaudio/soloud_miniaudio.cpp
@@ -21,70 +21,340 @@ misrepresented as being the original software.
 3. This notice may not be removed or altered from any source
 distribution.
 */
-#include <stdlib.h>
-
 #include "soloud.h"
 
 #if !defined(WITH_MINIAUDIO)
 
 namespace SoLoud
 {
-    result miniaudio_init(SoLoud::Soloud *aSoloud, unsigned int aFlags, unsigned int aSamplerate, unsigned int aBuffer)
-    {
-        return NOT_IMPLEMENTED;
-    }
+result miniaudio_init(SoLoud::Soloud *aSoloud, unsigned int aFlags, unsigned int aSamplerate, unsigned int aBuffer)
+{
+	return NOT_IMPLEMENTED;
 }
+} // namespace SoLoud
 
 #else
 
 #define MINIAUDIO_IMPLEMENTATION
-#define MA_NO_NULL
+
+#ifdef __linux__
+#define MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_LOW_LATENCY 5 // smaller period size results in less crackling when auto-negotiated? idk why
+#endif
+
+#if defined(_WIN32) || defined(_WIN64) || defined(_MSC_VER)
+#define MA_COINIT_VALUE \
+	0x2 // apartment-threaded (there's some weird workaround that miniaudio does with multithreaded init which i'm not sure is required for our use case)
+#define MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_LOW_LATENCY 1 // this seems to safely auto-renegotiate to the lowest period size anyways
+#endif
+
+// disable unneeded miniaudio features, we just want playback functionality
+#define MA_NO_NULL // no null audio backend
 #define MA_NO_DECODING
+#define MA_NO_ENCODING
 #define MA_NO_WAV
 #define MA_NO_FLAC
 #define MA_NO_MP3
+#define MA_NO_RESOURCE_MANAGER
+#define MA_NO_NODE_GRAPH
+#define MA_NO_ENGINE
+
 #include "miniaudio.h"
-#include <math.h>
+
+#include "soloud_internal.h"
+
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
 
 namespace SoLoud
 {
-    ma_device gDevice;
-
-    void soloud_miniaudio_audiomixer(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount)
-    {
-        SoLoud::Soloud *soloud = (SoLoud::Soloud *)pDevice->pUserData;
-            soloud->mix((float *)pOutput, frameCount);
-    }
-
-    static void soloud_miniaudio_deinit(SoLoud::Soloud *aSoloud)
-    {
-        ma_device_uninit(&gDevice);
-    }
-
-    result miniaudio_init(SoLoud::Soloud *aSoloud, unsigned int aFlags, unsigned int aSamplerate, unsigned int aBuffer, unsigned int aChannels)
-    {
-        ma_device_config config = ma_device_config_init(ma_device_type_playback);
-        //config.periodSizeInFrames = aBuffer; // setting to aBuffer (like 2048) causes miniaudio to crash; let's just use the default.
-        config.playback.format    = ma_format_f32;
-        config.playback.channels  = aChannels;
-        config.sampleRate         = aSamplerate;
-        config.dataCallback       = soloud_miniaudio_audiomixer;
-        config.pUserData          = (void *)aSoloud;
-        config.noPreSilencedOutputBuffer = true;
-        config.noClip = true;
-
-        if (ma_device_init(NULL, &config, &gDevice) != MA_SUCCESS)
-        {
-            return UNKNOWN_ERROR;
-        }
-
-        aSoloud->postinit_internal(gDevice.sampleRate, gDevice.playback.internalPeriodSizeInFrames, aFlags, gDevice.playback.channels);
-
-        aSoloud->mBackendCleanupFunc = soloud_miniaudio_deinit;
-
-        ma_device_start(&gDevice);
-        aSoloud->mBackendString = "MiniAudio";
-        return 0;
-    }
+struct MiniaudioData
+{
+	ma_context context{};
+	ma_device device{};
+	ma_log log{};
+	bool contextInitialized{false};
+	bool deviceInitialized{false};
+	bool logInitialized{false};
+	ma_uint32 maxLogLevel{0};
+
+	MiniaudioData() = default;
 };
+
+namespace // static
+{
+void soloud_miniaudio_log_callback(void *pUserData, ma_uint32 level, const char *pMessage)
+{
+	ma_uint32 maxLevel = *static_cast<ma_uint32 *>(pUserData);
+
+	if (level > maxLevel)
+		return; // don't log if level is more verbose than our max
+
+	const char *levelStr = nullptr;
+	switch (level)
+	{
+	case MA_LOG_LEVEL_DEBUG:
+		levelStr = "DEBUG";
+		break;
+	case MA_LOG_LEVEL_INFO:
+		levelStr = "INFO";
+		break;
+	case MA_LOG_LEVEL_WARNING:
+		levelStr = "WARNING";
+		break;
+	case MA_LOG_LEVEL_ERROR:
+		levelStr = "ERROR";
+		break;
+	default:
+		levelStr = "UNKNOWN";
+		break;
+	}
+
+	fprintf(stderr, "[MiniAudio %s] %s", levelStr, pMessage); // it seems that the log messages are pre-newline-terminated
+}
+
+ma_uint32 parse_log_level_from_env()
+{
+	static const char *env = getenv("MINIAUDIO_DEBUG");
+	if (!env)
+	{
+#ifdef _DEBUG
+		return MA_LOG_LEVEL_WARNING;
+#else
+		return 0; // none
+#endif
+	}
+
+	if (strcmp(env, "debug") == 0)
+		return MA_LOG_LEVEL_DEBUG;
+	if (strcmp(env, "info") == 0)
+		return MA_LOG_LEVEL_INFO;
+	if (strcmp(env, "warn") == 0)
+		return MA_LOG_LEVEL_WARNING;
+	if (strcmp(env, "error") == 0)
+		return MA_LOG_LEVEL_ERROR;
+	if (strcmp(env, "none") == 0)
+		return 0;
+
+	// default fallback for unrecognized values
+#ifdef _DEBUG
+	return MA_LOG_LEVEL_WARNING;
+#else
+	return 0;
+#endif
+}
+
+void soloud_miniaudio_audiomixer(ma_device *pDevice, void *pOutput, const void * /*pInput*/, ma_uint32 frameCount)
+{
+	auto *soloud = static_cast<SoLoud::Soloud *>(pDevice->pUserData);
+
+	switch (pDevice->playback.internalFormat)
+	{
+	case ma_format_f32:
+		soloud->mix(static_cast<float *>(pOutput), frameCount);
+		break;
+	case ma_format_s16:
+		soloud->mixSigned16(static_cast<short *>(pOutput), frameCount);
+		break;
+	case ma_format_u8:
+		soloud->mixUnsigned8(static_cast<unsigned char *>(pOutput), frameCount);
+		break;
+	case ma_format_s24:
+		soloud->mixSigned24(static_cast<unsigned char *>(pOutput), frameCount);
+		break;
+	case ma_format_s32:
+		soloud->mixSigned32(static_cast<int *>(pOutput), frameCount);
+		break;
+	default:
+		// fallback to float if format is unknown or unsupported
+		soloud->mix(static_cast<float *>(pOutput), frameCount);
+		break;
+	}
+}
+
+void soloud_miniaudio_deinit(SoLoud::Soloud *aSoloud)
+{
+	auto *data = static_cast<MiniaudioData *>(aSoloud->mBackendData);
+	if (data)
+	{
+		if (data->deviceInitialized)
+		{
+			ma_device_uninit(&data->device);
+			data->deviceInitialized = false;
+		}
+		if (data->contextInitialized)
+		{
+			ma_context_uninit(&data->context);
+			data->contextInitialized = false;
+		}
+		if (data->logInitialized)
+		{
+			ma_log_uninit(&data->log);
+			data->logInitialized = false;
+		}
+		delete data;
+		aSoloud->mBackendData = nullptr;
+	}
+}
+
+result soloud_miniaudio_pause(SoLoud::Soloud *aSoloud)
+{
+	auto *data = static_cast<MiniaudioData *>(aSoloud->mBackendData);
+	if (data && data->deviceInitialized)
+	{
+		if (ma_device_stop(&data->device) != MA_SUCCESS)
+			return UNKNOWN_ERROR;
+	}
+	return SO_NO_ERROR;
+}
+
+result soloud_miniaudio_resume(SoLoud::Soloud *aSoloud)
+{
+	auto *data = static_cast<MiniaudioData *>(aSoloud->mBackendData);
+	if (data && data->deviceInitialized)
+	{
+		if (ma_device_start(&data->device) != MA_SUCCESS)
+			return UNKNOWN_ERROR;
+	}
+	return SO_NO_ERROR;
+}
+
+} // namespace
+
+result miniaudio_init(SoLoud::Soloud *aSoloud, unsigned int aFlags, unsigned int aSamplerate, unsigned int aBuffer, unsigned int aChannels)
+{
+	auto *data = new MiniaudioData();
+	aSoloud->mBackendData = data;
+
+	// setup logging
+	data->maxLogLevel = parse_log_level_from_env();
+	if (data->maxLogLevel > 0)
+	{
+		ma_result logResult = ma_log_init(nullptr, &data->log);
+		if (logResult == MA_SUCCESS)
+		{
+			data->logInitialized = true;
+			ma_log_callback callback = ma_log_callback_init(soloud_miniaudio_log_callback, &data->maxLogLevel);
+			ma_log_register_callback(&data->log, callback);
+		}
+	}
+
+	ma_context_config contextConfig = ma_context_config_init();
+	contextConfig.threadPriority = ma_thread_priority_highest;
+	if (data->logInitialized)
+		contextConfig.pLog = &data->log;
+
+	// this can be set+reordered if we want a different priority
+	// const ma_backend backends[] = {ma_backend_wasapi, ma_backend_dsound, ma_backend_winmm,    ma_backend_coreaudio,  ma_backend_sndio,
+	//                                ma_backend_audio4, ma_backend_oss,    ma_backend_alsa,     ma_backend_pulseaudio, ma_backend_jack,
+	//                                ma_backend_aaudio, ma_backend_opensl, ma_backend_webaudio, ma_backend_custom,     ma_backend_null};
+
+	// ma_result result = ma_context_init(&backends[0], sizeof(backends) / sizeof((backends)[0]), &contextConfig, &data->context);
+	ma_result result = ma_context_init(nullptr, 0, &contextConfig, &data->context);
+	if (result != MA_SUCCESS)
+	{
+		if (data->logInitialized)
+			ma_log_uninit(&data->log);
+		delete data;
+		aSoloud->mBackendData = nullptr;
+		switch (result)
+		{
+		case MA_INVALID_ARGS:
+			return INVALID_PARAMETER;
+		case MA_OUT_OF_MEMORY:
+			return OUT_OF_MEMORY;
+		case MA_NO_BACKEND:
+			return NOT_IMPLEMENTED;
+		default:
+			return UNKNOWN_ERROR;
+		}
+	}
+	data->contextInitialized = true;
+
+	// configure device
+	ma_device_config config = ma_device_config_init(ma_device_type_playback);
+	config.playback.format = ma_format_unknown; // default device format, we'll do the conversion ourselves
+	config.playback.channels = aChannels;
+	config.dataCallback = soloud_miniaudio_audiomixer;
+	config.pUserData = (void *)aSoloud;
+	config.noPreSilencedOutputBuffer = true;
+	config.noClip = true;
+	config.performanceProfile = ma_performance_profile_low_latency;
+
+	if (aSamplerate > 0) // respect miniaudio default (avoids extra resampling if we use the device native sample rate)
+		config.sampleRate = aSamplerate;
+	else
+		config.sampleRate = 0;
+
+	if (aBuffer > 0) // respect miniaudio default
+		config.periodSizeInFrames = aBuffer;
+	else
+	{
+		config.periodSizeInFrames = 0;
+#if defined(_WIN32) || defined(_WIN64) || defined(_MSC_VER)
+		config.periodSizeInMilliseconds = 1; // probably redundant with the define above
+#endif
+	}
+
+	// backend-specific settings
+	config.wasapi.noAutoConvertSRC = true; // soloud handles resampling
+	config.wasapi.noDefaultQualitySRC = true;
+	config.alsa.noAutoFormat = true;
+	config.alsa.noAutoChannels = true;
+	config.alsa.noAutoResample = true;
+
+	result = ma_device_init(&data->context, &config, &data->device);
+	if (result != MA_SUCCESS)
+	{
+		ma_context_uninit(&data->context);
+		if (data->logInitialized)
+			ma_log_uninit(&data->log);
+		delete data;
+		aSoloud->mBackendData = nullptr;
+
+		switch (result)
+		{
+		case MA_INVALID_ARGS:
+			return INVALID_PARAMETER;
+		case MA_OUT_OF_MEMORY:
+			return OUT_OF_MEMORY;
+		case MA_FORMAT_NOT_SUPPORTED:
+			return INVALID_PARAMETER;
+		case MA_DEVICE_NOT_INITIALIZED:
+			// return UNKNOWN_ERROR;
+		case MA_DEVICE_ALREADY_INITIALIZED:
+			// return UNKNOWN_ERROR;
+		case MA_DEVICE_NOT_STARTED:
+			// return UNKNOWN_ERROR;
+		case MA_DEVICE_NOT_STOPPED:
+			// return UNKNOWN_ERROR;
+		default:
+			return UNKNOWN_ERROR;
+		}
+	}
+	data->deviceInitialized = true;
+
+	// use the actual device configuration that was negotiated
+	unsigned int actualSampleRate = data->device.sampleRate;
+	unsigned int actualBufferSize = data->device.playback.internalPeriodSizeInFrames;
+	unsigned int actualChannels = data->device.playback.channels;
+	// actual format available as data->device.playback.internalFormat
+
+	aSoloud->postinit_internal(actualSampleRate, actualBufferSize, aFlags, actualChannels);
+
+	aSoloud->mBackendCleanupFunc = soloud_miniaudio_deinit;
+	aSoloud->mBackendPauseFunc = soloud_miniaudio_pause;
+	aSoloud->mBackendResumeFunc = soloud_miniaudio_resume;
+
+	result = ma_device_start(&data->device);
+	if (result != MA_SUCCESS)
+	{
+		soloud_miniaudio_deinit(aSoloud);
+		return UNKNOWN_ERROR;
+	}
+
+	aSoloud->mBackendString = "MiniAudio";
+	return SO_NO_ERROR;
+}
+}; // namespace SoLoud
 #endif
diff --git a/src/core/soloud.cpp b/src/core/soloud.cpp
index 4e83123..0a5ea89 100644
--- a/src/core/soloud.cpp
+++ b/src/core/soloud.cpp
@@ -215,8 +215,13 @@ result Soloud::init(unsigned int aFlags, unsigned int aBackend, unsigned int aSa
 
 	if (aSamplerate != Soloud::AUTO)
 		samplerate = aSamplerate;
+	else
+		samplerate = Soloud::AUTO;
+
 	if (aBufferSize != Soloud::AUTO)
 		buffersize = aBufferSize;
+	else
+		buffersize = Soloud::AUTO;
 
 #if defined(WITH_SDL1_STATIC)
 	if (!inited && (aBackend == Soloud::SDL1 || aBackend == Soloud::AUTO))
@@ -257,9 +262,6 @@ result Soloud::init(unsigned int aFlags, unsigned int aBackend, unsigned int aSa
 #if defined(WITH_SDL3_STATIC)
 	if (!inited && (aBackend == Soloud::SDL3 || aBackend == Soloud::AUTO))
 	{
-		if (aBufferSize == Soloud::AUTO)
-			buffersize = 2048;
-
 		int ret = sdl3static_init(this, aFlags, samplerate, buffersize, aChannels);
 		if (ret == 0)
 		{
@@ -311,9 +313,6 @@ result Soloud::init(unsigned int aFlags, unsigned int aBackend, unsigned int aSa
 #if defined(WITH_MINIAUDIO)
 	if (!inited && (aBackend == Soloud::MINIAUDIO || aBackend == Soloud::AUTO))
 	{
-		if (aBufferSize == Soloud::AUTO)
-			buffersize = 2048;
-
 		int ret = miniaudio_init(this, aFlags, samplerate, buffersize, aChannels);
 		if (ret == 0)
 		{
@@ -2343,6 +2342,13 @@ void Soloud::mix(float *aBuffer, unsigned int aSamples)
 	interlace_samples_float(mScratch.mData, aBuffer, aSamples, mChannels, stride);
 }
 
+void Soloud::mixUnsigned8(unsigned char *aBuffer, unsigned int aSamples)
+{
+	unsigned int stride = (aSamples + 15) & ~0xf;
+	mix_internal(aSamples, stride);
+	interlace_samples_u8(mScratch.mData, aBuffer, aSamples, mChannels, stride);
+}
+
 void Soloud::mixSigned16(short *aBuffer, unsigned int aSamples)
 {
 	unsigned int stride = (aSamples + 15) & ~0xf;
@@ -2350,6 +2356,20 @@ void Soloud::mixSigned16(short *aBuffer, unsigned int aSamples)
 	interlace_samples_s16(mScratch.mData, aBuffer, aSamples, mChannels, stride);
 }
 
+void Soloud::mixSigned24(unsigned char *aBuffer, unsigned int aSamples)
+{
+	unsigned int stride = (aSamples + 15) & ~0xf;
+	mix_internal(aSamples, stride);
+	interlace_samples_s24(mScratch.mData, aBuffer, aSamples, mChannels, stride);
+}
+
+void Soloud::mixSigned32(int *aBuffer, unsigned int aSamples)
+{
+	unsigned int stride = (aSamples + 15) & ~0xf;
+	mix_internal(aSamples, stride);
+	interlace_samples_s32(mScratch.mData, aBuffer, aSamples, mChannels, stride);
+}
+
 void interlace_samples_float(const float *aSourceBuffer, float *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride)
 {
 	// 111222 -> 121212
@@ -2366,6 +2386,27 @@ void interlace_samples_float(const float *aSourceBuffer, float *aDestBuffer, uns
 	}
 }
 
+void interlace_samples_u8(const float *aSourceBuffer, unsigned char *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride)
+{
+	// 111222 -> 121212, convert from [-1,1] float to [0,255] unsigned 8-bit
+	unsigned int i, j, c;
+	c = 0;
+	for (j = 0; j < aChannels; j++)
+	{
+		c = j * aStride;
+		for (i = j; i < aSamples * aChannels; i += aChannels)
+		{
+			int sample = (int)(aSourceBuffer[c] * 127.0f + 128.0f);
+			if (sample < 0)
+				sample = 0;
+			if (sample > 255)
+				sample = 255;
+			aDestBuffer[i] = (unsigned char)sample;
+			c++;
+		}
+	}
+}
+
 void interlace_samples_s16(const float *aSourceBuffer, short *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride)
 {
 	// 111222 -> 121212
@@ -2382,6 +2423,54 @@ void interlace_samples_s16(const float *aSourceBuffer, short *aDestBuffer, unsig
 	}
 }
 
+void interlace_samples_s24(const float *aSourceBuffer, unsigned char *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride)
+{
+	// 111222 -> 121212, convert from [-1,1] float to 24-bit signed (3 bytes per sample, little endian)
+	unsigned int i, j, c;
+	c = 0;
+	for (j = 0; j < aChannels; j++)
+	{
+		c = j * aStride;
+		for (i = j; i < aSamples * aChannels; i += aChannels)
+		{
+			int sample = (int)(aSourceBuffer[c] * 8388607.0f); // 0x7fffff
+			if (sample < -8388608)
+				sample = -8388608;
+			if (sample > 8388607)
+				sample = 8388607;
+
+			// store as little endian 3-byte signed integer
+			unsigned int destIdx = i * 3;
+			aDestBuffer[destIdx] = (unsigned char)(sample & 0xff);
+			aDestBuffer[destIdx + 1] = (unsigned char)((sample >> 8) & 0xff);
+			aDestBuffer[destIdx + 2] = (unsigned char)((sample >> 16) & 0xff);
+			c++;
+		}
+	}
+}
+
+void interlace_samples_s32(const float *aSourceBuffer, int *aDestBuffer, unsigned int aSamples, unsigned int aChannels, unsigned int aStride)
+{
+	// 111222 -> 121212, convert from [-1,1] float to 32-bit signed
+	unsigned int i, j, c;
+	c = 0;
+	for (j = 0; j < aChannels; j++)
+	{
+		c = j * aStride;
+		for (i = j; i < aSamples * aChannels; i += aChannels)
+		{
+			// use double precision for better accuracy with 32-bit range
+			double sample = (double)aSourceBuffer[c] * 2147483647.0;
+			if (sample < -2147483648.0)
+				sample = -2147483648.0;
+			if (sample > 2147483647.0)
+				sample = 2147483647.0;
+			aDestBuffer[i] = (int)sample;
+			c++;
+		}
+	}
+}
+
 void Soloud::lockAudioMutex_internal()
 {
 	if (mAudioThreadMutex)
-- 
2.49.0

